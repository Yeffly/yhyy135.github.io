<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Acuario</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://acuario.xyz/"/>
  <updated>2019-08-24T08:48:24.249Z</updated>
  <id>https://acuario.xyz/</id>
  
  <author>
    <name>Acuario</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《Modern PHP》学习笔记</title>
    <link href="https://acuario.xyz/modern-php-summary/"/>
    <id>https://acuario.xyz/modern-php-summary/</id>
    <published>2019-08-24T08:33:23.000Z</published>
    <updated>2019-08-24T08:48:24.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="命名空间（namespace）"><a href="#命名空间（namespace）" class="headerlink" title="命名空间（namespace）"></a>命名空间（namespace）</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>PHP 命名空间与操作系统的物理文件系统不同，这是一个虚拟概念，没必要和文件系统中的目录结构完全对应。但是大多数 PHP 组件为了兼容 PSR-4 自动加载器标准，会把子命名空间放到文件系统的子目录中。</li><li>从技术层面来看，命名空间只是 PHP 语言中的一种记号，PHP 解释器会将其作为前缀添加到类、接口、函数和常量的名称前面。</li><li>不同代码可能使用相同的类名、接口名、函数名或常量名，如果不使用命名空间，名称会起冲突，导致 PHP 执行出错。而使用命名空间，把代码放在唯一的厂商命名空间中，这样不同命名空间下的代码就可以使用相同的名称命名类、接口、函数和常量。</li><li>在同一个命名空间或子命名空间中的所有类没必要在同一个 PHP 文件中声明。你可以在 PHP 文件的顶部指定一个命名空间或子命名空间，此时，这个文件中的代码就是该命名空间或子命名空间的一部分。因此，我们可以在不同的文件中编写属于同一个命名空间的多个类。</li></ul><a id="more"></a><h2 id="导入和别名"><a href="#导入和别名" class="headerlink" title="导入和别名"></a>导入和别名</h2><ul><li><strong>导入</strong>是指在每个 PHP 文件中告诉 PHP 想使用哪个命名空间、类、接口、函数和常量。导入后就不用输入全名了。</li><li><strong>创建别名</strong>是指告诉 PHP 我要使用简单的名称引用导入的类、接口、函数或常量。</li><li>使用 <code>use</code> 关键字导入代码时无需在开头加上符号，因为 PHP 假定导入的是<strong>完全限定</strong>的命名空间。</li><li><code>use</code> 关键字必须出现在<strong>全局作用域</strong>中（即不能在类或函数中），因为这个关键字在编译时使用。不过，use 关键字可以在命名空间声明语句之后使用，导入其他命名空间中的代码。</li><li>导入函数和常量:</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">use func Namespace\functionName;</span><br><span class="line">use constant Namespace\CONST_NAME;</span><br><span class="line">functionName();</span><br><span class="line">echo CONST_NAME;</span><br></pre></td></tr></table></figure><ul><li><strong>一个文件定义一个类</strong>，一个文件只使用一个命名空间。</li><li>有些代码可能没有命名空间，这些代码在全局命名空间中。如果需要在命名空间中引用其他命名空间中的类、接口、函数或常量，必须使用完全限定的 PHP 类名（命名空间类名）。在命名空间中引用全局命名空间中的代码时，要在类、接口、函数或常量的名称前加上 <code>\</code> 符号。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace My\App;</span><br><span class="line"></span><br><span class="line">Class Foo</span><br><span class="line">&#123;</span><br><span class="line">    public function dosomething() &#123;</span><br><span class="line">        $exception1 = new Exception();      // \My\App\Exception 类中搜索</span><br><span class="line">        $exception2 = new \Exception();     // PHP 原生的 Exception 类</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="接口（interface）"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a>接口（interface）</h1><ul><li>接口是两个 PHP 对象之间的契约，其目的不是让一个对象依赖另一个对象的身份，而是依赖另一个对象的能力。</li><li>接口将项目代码和依赖解耦，并允许项目代码依赖任何实现了预期接口的第三方代码而<strong>不用关心第三方代码是如何实现接口的，只关心第三方代码是否实现了指定的接口</strong>。</li></ul><p>例程（<a href="https://github.com/codeguy/modern-php/tree/master/02-features/interfaces" target="_blank" rel="noopener">完整版</a>）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$documentStore = new DocumentStore();</span><br><span class="line"></span><br><span class="line">// Add HTML document</span><br><span class="line">$htmlDoc = new HtmlDocument(&apos;http://php.net&apos;);</span><br><span class="line">$documentStore-&gt;addDocument($htmlDoc);</span><br><span class="line"></span><br><span class="line">// Add terminal command document</span><br><span class="line">$cmdDoc = new CommandOutputDocument(&apos;cat /etc/hosts&apos;);</span><br><span class="line">$documentStore-&gt;addDocument($cmdDoc);</span><br><span class="line"></span><br><span class="line">print_r($documentStore-&gt;getDocuments());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class DocumentStore</span><br><span class="line">&#123;</span><br><span class="line">    protected $data = [];</span><br><span class="line">    public function addDocument(Documentable $document)</span><br><span class="line">    &#123;</span><br><span class="line">        $key = $document-&gt;getId();</span><br><span class="line">        $value = $document-&gt;getContent();</span><br><span class="line">        $this-&gt;data[$key] = $value;</span><br><span class="line">    &#125;</span><br><span class="line">    public function getDocuments()</span><br><span class="line">    &#123;</span><br><span class="line">        return $this-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Documentable</span><br><span class="line">&#123;</span><br><span class="line">    public function getId();</span><br><span class="line">    public function getContent();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CommandOutputDocument implements Documentable</span><br><span class="line">&#123;</span><br><span class="line">    protected $command;</span><br><span class="line"></span><br><span class="line">    public function __construct($command)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;command = $command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function getId()</span><br><span class="line">    &#123;</span><br><span class="line">        return $this-&gt;command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function getContent()</span><br><span class="line">    &#123;</span><br><span class="line">        return shell_exec($this-&gt;command);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class HtmlDocument implements Documentable</span><br><span class="line">&#123;</span><br><span class="line">    protected $url;</span><br><span class="line"></span><br><span class="line">    public function __construct($url)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;url = $url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function getId()</span><br><span class="line">    &#123;</span><br><span class="line">        return $this-&gt;url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function getContent()</span><br><span class="line">    &#123;</span><br><span class="line">        $ch = curl_init();</span><br><span class="line">        curl_setopt($ch, CURLOPT_URL, $this-&gt;url);</span><br><span class="line">        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);</span><br><span class="line">        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 3);</span><br><span class="line">        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);</span><br><span class="line">        curl_setopt($ch, CURLOPT_MAXREDIRS, 3);</span><br><span class="line">        $html = curl_exec($ch);</span><br><span class="line">        curl_close($ch);</span><br><span class="line"></span><br><span class="line">        return $html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="性状（trait）"><a href="#性状（trait）" class="headerlink" title="性状（trait）"></a>性状（trait）</h1><ul><li>性状既不是类也不是接口，而是类的部分实现（即常量，属性和方法），可以混入一个或多个现有的 PHP 类中。</li><li>性状的作用：<ol><li>表明类可以做什么（类似接口）；</li><li>提供模块化实现（类似类）。</li></ol></li><li>性状能把模块化的实现方式注入多个无关的类中。而且性状还能促进代码重用。</li><li>使用性状的场景：<ol><li>创建一个基类，然后共同集成这个基类，将共用方法写在基类中。但无关的两个类并不应集成相同的父类。</li><li>创建接口，然后在两个类中分别实现该接口并使用。但如果实现方法相同，则违背了 DRY（Don’t Repeat Yourself）原则。</li></ol></li><li>与定义类和接口一样，一个文件只定义一个性状。</li><li>命名空间、类、接口函数和常量<strong>在类的定义体外</strong>导入，而性状<strong>在类的定义体内</strong>导入。</li><li>PHP 解释器在编译时会把性状复制粘贴到类的定义体中，但是<strong>不会处理这个操作引入的不兼容问題</strong>。如果性状假定类中有特定的属性或方法（在性状中没有定义），要确保相应的类中有对应的属性和方法。</li></ul><p>例程：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$adapter = new \Ivory\HttpAdapter\CurlHttpAdapter();</span><br><span class="line">$geocoder = new \Geocoder\Provider\GoogleMaps($adapter);</span><br><span class="line"></span><br><span class="line">$store = new RetailStore();</span><br><span class="line">$store-&gt;setAddress(&apos;420 9th Avenue, New York, NY 10001 USA&apos;);</span><br><span class="line">$store-&gt;setGeocoder($geocoder);</span><br><span class="line"></span><br><span class="line">$latitude = $store-&gt;getLatitude();</span><br><span class="line">$longitude = $store-&gt;getLongitude();</span><br><span class="line"></span><br><span class="line">echo $latitude, &apos;:&apos;, $longitude;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class RetailStore</span><br><span class="line">&#123;</span><br><span class="line">    use TraitExample;</span><br><span class="line"></span><br><span class="line">    //......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">trait Geocodable</span><br><span class="line">&#123;</span><br><span class="line">    /** @var string */</span><br><span class="line">    protected $address;</span><br><span class="line"></span><br><span class="line">    /** @var \Geocoder\Geocoder */</span><br><span class="line">    protected $geocoder;</span><br><span class="line"></span><br><span class="line">    /** @var \Geocoder\Model\AddressCollection */</span><br><span class="line">    protected $geocoderResult;</span><br><span class="line"></span><br><span class="line">    public function setGeocoder(\Geocoder\Geocoder $geocoder)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;geocoder = $geocoder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function setAddress($address)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;address = $address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function getLatitude()</span><br><span class="line">    &#123;</span><br><span class="line">        if (!isset($this-&gt;geocoderResult)) &#123;</span><br><span class="line">            $this-&gt;geocodeAddress();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return $this-&gt;geocoderResult-&gt;first()-&gt;getLatitude();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function getLongitude()</span><br><span class="line">    &#123;</span><br><span class="line">        if (!isset($this-&gt;geocoderResult)) &#123;</span><br><span class="line">            $this-&gt;geocodeAddress();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return $this-&gt;geocoderResult-&gt;first()-&gt;getLongitude();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected function geocodeAddress()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;geocoderResult = $this-&gt;geocoder-&gt;geocode($this-&gt;address);</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="生成器（generator）"><a href="#生成器（generator）" class="headerlink" title="生成器（generator）"></a>生成器（generator）</h1><ul><li>生成器是简单的<strong>迭代器</strong>。</li><li>PHP 生成器不要求类实现 <code>Iterator</code> 接口，并会根据需求即时计算并产出要迭代的值，不占用宝贵的内存资源。</li><li>生成器是<strong>一次性的</strong>，无法多次迭代同个生成器，但可以重建或克隆生成器</li><li>每次产出一个值之后，生成器的内部状态都会停顿；向生成器请求下一个值时，内部状态又会恢复。生成器的内部状态会一直在停顿和恢复之间切换，直到抵达函数定义体的末尾或遇到空的 return；语句为止。</li><li>生成器是<strong>只能向前进的迭代器</strong>，不能使用生成器在数据集中执行后退、快进或査找操作，只能让生成器计算并产生下一个值。迭代大型数据集或数列时最适合使用生成器，因为这样占用的系统内存量极少。</li><li>更多技巧与实践：<a href="https://www.twitter.com/ircmaxell" target="_blank" rel="noopener">@ircmaxell</a> - <a href="https://blog.ircmaxell.com/2012/07/what-generators-can-do-for-you.html" target="_blank" rel="noopener">What Generators Can Do For You</a></li></ul><p>例程一：生成一个范围内的数值数组且善用内存</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function makeRange($length) &#123;</span><br><span class="line">    for ($i = 0; $i &lt; $length; $i++) &#123;</span><br><span class="line">        yield $i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foreach (makeRange(1000000) as $i) &#123;</span><br><span class="line">    echo $i . PHP_EOL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例程二：读取一个超过 PHP 可用内存上限的 CSV 文件。只为 CSV 文件中的一行分配内存，而不会把整个 CSV 文件都读取到内存中。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function getRows($file) &#123;</span><br><span class="line">    $handle = fopen($file, &apos;rb&apos;);</span><br><span class="line">    if (!$handle) &#123;</span><br><span class="line">        throw new Exception();</span><br><span class="line">    &#125;</span><br><span class="line">    while (!feof($handle)) &#123;</span><br><span class="line">        yield fgetcsv($handle);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose($handle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foreach (getRows(&apos;data.csv&apos;) as $row) &#123;</span><br><span class="line">    print_r($row);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="闭包（closure）"><a href="#闭包（closure）" class="headerlink" title="闭包（closure）"></a>闭包（closure）</h1><ul><li><strong>闭包</strong>是指在创建时封装周围状态的函数。即便闭包所在的环境不存在了，闭包中封装的状态依然存在。</li><li><strong>匿名函数</strong>就是没有名称的函数，可以调用，还可以传入参数。</li><li>匿名函数<strong>可以赋值给变量</strong>，还能像对象那样传递。</li><li>匿名函数适合作为函数或方法的回调。</li><li>在 PHP 中，匿名函数 = 闭包。</li><li>闭包和匿名函数是<strong>伪装成函数的对象</strong>。</li><li>PHP 闭包不会自动封装应用的状态，必须手动调用闭包对象的 <code>bindto()</code> 方法或者使用 <code>use</code> 关键字，把状态附加到 PHP 闭包上，这样即便返回的闭包对象跳出了其函数的作用域，它也会记住参数的值，即将应用状态封装起来。</li><li>与任何其他 PHP 对象类似，每个闭包实例都可以使用 $this 关键字获取闭包的内部状态。<code>bindto()</code> 方法可以把 Closure 对象的内部状态绑定到其他对象上。</li><li>闭包可以访问绑定闭包的对象中受保护和私有的成员变量。</li></ul><p>例程一：普通闭包</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$numbersPlusOne = array_map(function ($number) &#123;</span><br><span class="line">    return $number + 1;</span><br><span class="line">&#125;, [1,2,3]);</span><br><span class="line"></span><br><span class="line">print_r($numbersPlusOne);</span><br><span class="line"></span><br><span class="line">// Outputs --&gt; [2,3,4]</span><br></pre></td></tr></table></figure><p>例程二：封装应用状态的闭包</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function enclosePerson($name) &#123;</span><br><span class="line">    return function ($doCommand) use ($name) &#123;</span><br><span class="line">        return sprintf(&apos;%s, %s&apos;, $name, $doCommand);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Enclose &quot;Clay&quot; string in closure</span><br><span class="line">$clay = enclosePerson(&apos;Clay&apos;);</span><br><span class="line"></span><br><span class="line">// Invoke closure with command</span><br><span class="line">echo $clay(&apos;get me sweet tea!&apos;);</span><br><span class="line">// Outputs --&gt; &quot;Clay, get me sweet tea!&quot;</span><br></pre></td></tr></table></figure><h1 id="Zend-OPcache"><a href="#Zend-OPcache" class="headerlink" title="Zend OPcache"></a>Zend OPcache</h1><ul><li>PHP 是解释型语言，PHP 解释器执行 PHP 脚本时会解析 PHP 脚本代码，把 PHP 代码编译成一系列 <a href="http://bit.ly/zend-opcode" target="_blank" rel="noopener">Zend 操作码</a>，然后执行字节码。Zend OPcache 可以让 PHP 解释器从内存中读取预先编译好的字节码，然后立即执行。这样能节省很多时间，极大地提升应用的性能。</li><li><p>启用步骤：</p><ol><li>编译：<code>$ ./configure --enable-opcache</code></li><li>启用扩展：<code>zend_extension=/path/to/opcache.so</code></li><li><p>配置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">opcache.validate_timestamps = 1 //检测 PHP 脚本变动。建议生产环境设为 0</span><br><span class="line">opcache.revalidate_freq = 0 //检査 PHP 脚本内容变化的周期，单位秒。</span><br><span class="line">opcache.memory_consumption = 64 // 为操作码缓存分配的内存量（单位是 MB）。分配的内存量应该够保存应用中所有 PHP 脚本编译得到的操作码。</span><br><span class="line">opcache.interned_strings_buffer = 16 // 用来存储驻留字符串（interned string）的内存量（单位是 MB）。默认值为 4MB。</span><br><span class="line">opcache.max_accelerated_files = 4000 // 操作码缓存中最多能存储多少个 PHP 脚本。</span><br><span class="line">opcache.fast_shutdown = 1 // 设置操作码使用更快的停机步骤</span><br></pre></td></tr></table></figure></li></ol></li></ul><h1 id="内置的-HTTP-服务器"><a href="#内置的-HTTP-服务器" class="headerlink" title="内置的 HTTP 服务器"></a>内置的 HTTP 服务器</h1><ul><li>从 PHP 5.4.0 起，PHP 内置了 Web 服务器。</li><li>启动本地运行：<code>$ php -S localhost:4000</code></li><li>启动局域网访问：<code>$ php -S 0.0.0.0:4000</code></li><li>指定配置文件启动：<code>$ php -S localhost:8000 -c app/config/php.ini</code></li><li>指定路由器脚本启动：<code>$ php -S localhost:8000 router.php</code></li><li>内置的 HTTP 服务器仅用于本地开发调试，不应使用于生产环境。</li></ul><h1 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h1><ul><li>PHP Framework Interop Group（简称 PHP-FIG，<a href="http://www.php-fig.org" target="_blank" rel="noopener">http://www.php-fig.org</a> ）。PHP-FIG 由一些 PHP 框架代表组成，PHP-FIG 制定了推荐规范，PHP 框架可以自愿实现这些规范，改进与其他框架的通信和共享功能。</li><li>PHP-FIG 的使命是实现框架的互操作性：通过接口、自动加载机制和标准的风格，让框架相互合作。</li><li>接口：框架通过 PHP 接口假定第三方依赖提供了什么方法，而不关心依赖是如何实现接口的。<ul><li>自动加载：PHP 解释器在运行时按需自动找到并加载 PHP 类的过程。只需使用一个自动加载器就能混合搭配多个 PHP 组件。</li><li>风格：指定如何使用空格、大小写和括号的位置（等等）之类的代码格式规范。</li></ul></li></ul><h2 id="PSR-1：基本的代码风格"><a href="#PSR-1：基本的代码风格" class="headerlink" title="PSR-1：基本的代码风格"></a>PSR-1：基本的代码风格</h2><ul><li>PHP 标签：使用 <code>&lt;?php ?&gt;</code> 或 <code>&lt;?= ?&gt;</code></li><li>编码：使用 <code>UTF-8</code> 编码</li><li>目的：一个 PHP 文件只处理一件事</li><li>自动加载：PHP 命名空间和类必须遵守 PSR-4 自动加载器标准</li><li>类的名称：PHP 类的名称必须一直使用<strong>大驼峰式</strong>（CamelCase）</li><li>常量名称：PHP 常量的名称必须全部使用<strong>大写</strong>字母</li><li>方法名称：PHP 方法的名称必须一直使用<strong>小驼峰式</strong>（camelCase）</li></ul><h2 id="PSR-2：严格的代码风格"><a href="#PSR-2：严格的代码风格" class="headerlink" title="PSR-2：严格的代码风格"></a>PSR-2：严格的代码风格</h2><ul><li>贯彻 PSR-1</li><li>缩进：使用四个空格缩进。</li><li>文件和代码行：使用 UNIX 换行符（LF），文末<strong>留一个空行</strong>，<strong>不使用</strong> PHP 关闭标签 <code>?&gt;</code>。每行代码<strong>不超过</strong> 80 个字符，<strong>至少不能超过</strong> 120 个字符。每行末尾<strong>不能有空格</strong>。</li><li>关键字：使用<strong>小写字母</strong>。</li><li>命名空间：命名空间声明语句和 <code>use</code> 声明语句后<strong>留一个空行</strong>。</li><li>类：类定义体的起始括号在类名之后<strong>新起一行写</strong>。扩展类或实现接口的 <code>extends</code> 和 <code>implements</code> 关键字必须和类名<strong>写在同一行</strong>。</li><li>方法：方法定义体的起始括号要在方法名之后<strong>新起一行写</strong>。方法定义体的结束括号要在方法定义体之后新起一行写。起始圆括号之后<strong>没有空格</strong>，结束圆括号之前<strong>没有空格</strong>。方法的参数后面有<strong>一个逗号和空格</strong>。</li><li>可见性：类中的每个属性和方法都要声明可见性。<code>abstract</code> 或 <code>final</code> 限定符放在可见性关键字<strong>之前</strong>，<code>static</code> 限定符放在可见性关键字<strong>之后</strong>。</li><li>控制结构：所有控制结构关键字（<code>if</code>、<code>elseif</code>、<code>else</code>、<code>switch</code>、<code>case</code>、<code>while</code>、<code>do while</code>、<code>for</code>、<code>foreach</code>、<code>try</code>、<code>catch</code>）后面都要有<strong>一个空格</strong>。控制结构关键字后面的起始圆括号后面<strong>没有空格</strong>，结束圆括号之前<strong>没有空格</strong>，起始括号和控制结构关键字<strong>写在同一行</strong>，结束括号<strong>单独写在一行</strong>。</li></ul><h2 id="PSR-3：日志记录器接口"><a href="#PSR-3：日志记录器接口" class="headerlink" title="PSR-3：日志记录器接口"></a>PSR-3：日志记录器接口</h2><ul><li>PSR-3 是一个接口，规定 PHP 日志记录器组件可以实现的方法。</li><li>PSR-3 要求日志记录器必须实现 9 个方法：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace Psr\Log;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * See https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-3-logger-interface.md</span><br><span class="line"> * for the full interface specification.</span><br><span class="line"> */</span><br><span class="line">interface LoggerInterface</span><br><span class="line">&#123;</span><br><span class="line">    public function emergency($message, array $context = array());</span><br><span class="line">    public function alert($message, array $context = array());</span><br><span class="line">    public function critical($message, array $context = array());</span><br><span class="line">    public function error($message, array $context = array());</span><br><span class="line">    public function warning($message, array $context = array());</span><br><span class="line">    public function notice($message, array $context = array());</span><br><span class="line">    public function info($message, array $context = array());</span><br><span class="line">    public function debug($message, array $context = array());</span><br><span class="line">    public function log($level, $message, array $context = array());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>推荐使用符合 PSR-3 规范的日志记录器 <a href="https://packagist.org/packages/monolog/monolog" target="_blank" rel="noopener">monolog/monolog</a></li></ul><h2 id="PSR-4：自动加载器"><a href="#PSR-4：自动加载器" class="headerlink" title="PSR-4：自动加载器"></a>PSR-4：自动加载器</h2><ul><li>PSR-4 是一个标准的自动加载器策略，规定运行时按需査找 PHP 类、接口或性状，并将其载入 PHP 解释器。</li><li>自动加载器的引入解决了使用 <code>require()</code> 函数和 <code>include()</code> 函数手动引入文件的繁琐。</li><li>PSR-4 推荐规范不要求改变代码的实现方式，只建议如何使用文件系统目录结构和 PHP 命名空间组织代码。</li><li>PSR-4 自动加载器策略依赖 PHP 命名空间和文件系统目录结构査找并加载 PHP 类、接口和性状。</li><li>PSR-4 会把命名空间的前缀和文件系统中的目录对应起来。命名空间的前缀可以是顶层命名空间，也可以是顶层命名空间加上任意一个子命名空间。</li><li>推荐使用依赖管理器 <a href="https://getcomposer.org/" target="_blank" rel="noopener">Composer</a> 来自动生成符合 PSR-4 规范的自动加载器。</li></ul><h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><ul><li>PHP 组件是一系列相关的类、接口和性状，用于解决某个具体问题。组件中的类、接口和性状通常放在同一个命名空间中。</li><li>好的 PHP 组件具有以下特征：<ul><li>作用单一：专注于解决一个问题，而且使用简单的接口封装功能。</li><li>小型：只包含解决某个问题所需的最少代码。</li><li>合作：PHP 组件之间能良好合作。把代码放在自己的命名空间中，防止与其他组件有名称冲突。</li><li>测试良好：组件本身会提供测试，而且有充足的测试覆盖度。</li><li>文档完善：有个 README 文件，说明组件的作用，如何安装，以及如何使用。抑或有网站介绍详细信息。</li></ul></li><li>如果是能通过一些 PHP 组件准确解决问题的小型项目，那就使用组件。如果是有多个团队成员开发的大型项目，而且能从框架提供的约定、准则和结构中受益，那就使用框架。</li><li>查找组件目录：<a href="https://packagist.org/" target="_blank" rel="noopener">Packagist</a></li><li>安装组件的工具：<a href="https://getcomposer.org/" target="_blank" rel="noopener">Composer</a></li><li>自动加载是指在不使用 <code>require()</code>、<code>require_once()</code>、<code>include()</code> 或 <code>include_once()</code> 函数的情况下按需自动加载 PHP 类。</li><li>在较旧的 PHP 版本中可以使用 <code>autoload()</code> 函数自己编写自动加载器；实例化尚未加载的类时，PHP 解释器会自动调用这个函数。后来，PHP 在 SPL 库中引入了更灵活的 <code>sql_autoload_register()</code> 函数。如何自动加载 PHP 类完全由开发者决定。依赖管理器 Composer 为项目中的所有 PHP 组件自动生成符合 PSR 标准的自动加载器。Composers 有效抽象了依赖管理和自动加载。</li><li>Composer 和 Packagisti 都使用 <code>vendor/package</code> 这种命名约定，避免不同厂商的 PHP 组件有名称冲突。</li><li>PHP 组件版本号（如，1.13.2)语义：<ol><li>第一个数字是主版本号，用于破坏了向后兼容性的版本更新。</li><li>第二个数字是次版本号，用于没破坏向后兼容性的小幅功能更新。</li><li>第三个数字是修订版本号，用于对向后兼容的缺陷的修正。</li></ol></li><li><code>composer install</code> 命令不会安装比 <code>composer.lock</code> 文件中列出的版本号新的版本。</li><li><code>composer update</code> 命令会把组件更新到最新稳定版，还会更新 <code>composer.lock</code> 文件，写入 PHP 组件的新版本号。</li><li>Composer 创建的自动加载器就是 <code>vendor/autoload.php</code> 文件。Composer 下载各个 PHP 组件时会检査每个组件的 <code>composer.json</code> 文件，确定如何加载该组件。</li><li>Composer 仓库的凭据 <code>auth.php</code> 文件放在和 <code>composer.json</code> 文件同级目录，且不应加入版本控制：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;http-basic&quot;: &#123;</span><br><span class="line">        &quot;example.org&quot; :&#123;</span><br><span class="line">            &quot;username&quot;: &quot;your-name&quot;,</span><br><span class="line">            &quot;password&quot;: &quot;your-password&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>composer.json</code> 文件结构：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;组件名称&quot;,</span><br><span class="line">    &quot;description&quot;: &quot;描述&quot;,</span><br><span class="line">    &quot;keywords&quot;: [关键词],</span><br><span class="line">    &quot;homepage&quot;: &quot;组件主页&quot;,</span><br><span class="line">    &quot;license&quot;: &quot;软件许可协议&quot;,</span><br><span class="line">    &quot;authors&quot;: [作者信息],</span><br><span class="line">    &quot;support&quot;: &#123;获取技术支持的方式&#125;,</span><br><span class="line">    &quot;require&quot;: &#123;依赖的组件&#125;,</span><br><span class="line">    &quot;require-dev&quot;: &#123;开发该组件时依赖的组件&#125;,</span><br><span class="line">    &quot;suggest&quot;: &#123;建议安装的组件&#125;,</span><br><span class="line">    &quot;autoload&quot;: &#123;自动加载方式&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Packagist 从组件的 <code>composer.json</code> 文件中读取了组件的名称、描述、关键字依赖和建议。还会发现显示了仓库的分支和标签。同时 Packagist 会把仓库的标签和语言版本号对应起来。</p></li></ul><h1 id="良好实践"><a href="#良好实践" class="headerlink" title="良好实践"></a>良好实践</h1><h2 id="过滤、验证和转义"><a href="#过滤、验证和转义" class="headerlink" title="过滤、验证和转义"></a>过滤、验证和转义</h2><ul><li>不要相信任何来自不受自己直接控制的数据源中的数据。</li><li>过滤输入：转义或删除不安全的字符。在数据到达应用的存储层之前，一定要过滤输入数据。建议不使用正则表达式函数过滤 HTML，正则表达式很复杂，可能导致 HTML 无效，且出错的几率高。</li><li>验证数据：确认输入的数据符合预期，在应用的存储层保存符合特定格式的正确数据。避免数据库出现潜在的错误。</li><li>转义输出：避免渲染恶意代码，还能防止应用的用户无意中执行恶意代码。</li></ul><h2 id="密码"><a href="#密码" class="headerlink" title="密码"></a>密码</h2><ul><li>绝对不能知道用户的密码</li><li>绝对不要约束用户的密码</li><li>绝对不能通过电子邮件发送用户的密码</li><li>使用 <code>bcrypt</code> 计算用户密码的哈希值。<code>bcrypt</code> 算法会自动加盐，防止潜在的彩虹表攻击。<code>bcrypt</code> 算法永不过时，如果计算机的运算速度变快了，我们只需提高工作因子的值。<code>bcrypt</code> 算法得到了同行的大量审查，目前暂无漏洞。</li><li>加密和哈希不是一回事。加密是双向算法，加密的数据以后可以解密。而哈希是单向算法，哈希后的数据不能再还原成原始值，而且相同的数据得到的哈希值始终相同。</li></ul><h2 id="日期、时间和时区"><a href="#日期、时间和时区" class="headerlink" title="日期、时间和时区"></a>日期、时间和时区</h2><ul><li>推荐使用 <a href="https://github.com/briannesbitt/Carbon" target="_blank" rel="noopener"><code>nesbit/carbon</code></a> 组件处理日期和时间值的有用方法。</li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul><li>PDO 扩展：PDO（PHP Data Objects，PHP 数据对象）是一系列 PHP 类，抽象了不同数据库的具体实现，只通过一个用户界面就能与多种不同的 SQL 数据库通信。不管使用哪种数据库系统，使用一个接口就能编写和执行数据库査询</li><li>使用 PDO 时，建议编写符合 <code>ANSI/ISO</code> 标准的 SQL 语句，这样如果更换数据库系统 SQL 语句不会失效。</li><li>数据库凭据应保存在一个位于文档根目录之外的配置文件中，然后在需要使用凭据的 PHP 文件中导入。另外，凭据也不能纳入版本控制，避免因仓库公开而泄漏凭据。</li><li><strong>事务</strong>：指把一系列数据库语句当成单个逻辑单元（具有原子性）执行。事务中的一系列 SQL 査询要么都成功执行，要么根本不执行。</li><li>事务的一个副作用一一提升性能——事务把多个査询排成队列，一次全部执行。</li><li>PHP 中处理字符串的函数默认假设所有字符串都只使用 8 位字符，如果使用这些 PHP 原生的字符串函数处理包含多字节字符的 Unicode 字符串，可能会出错。为避免处理多字节字符串时出错，可以安装 <a href="http://php.net/manual/book.mbstring.php" target="_blank" rel="noopener"><code>mbstring</code> 扩展</a>。该扩展提供了能替代大多数 PHP 原生的且能处理多字节字符串的函数。</li><li>PHP 编码配置(<code>pip.ini</code>)：<code>default charset = &quot;utf-8&quot;</code></li></ul><h2 id="错误和异常"><a href="#错误和异常" class="headerlink" title="错误和异常"></a>错误和异常</h2><ul><li>错误会导致程序脚本停止执行，有些错误无法恢复，其他错误可使用全局错误处理程序处理。</li><li>预测測、捕获并处理异常是我们自己的责任。未捕获的异常会导致 PHP 应用终止运行，显示致命错误信息。而更糟的是，可能会暴露敏感的调试详细信息，让应用的用户看到。因此，一定要使用 <code>try/catch</code> 块捕获异常，然后使用优雅的方式处理。</li><li>捕获某种异常时只会运行其中一个 catch 块。如果 PHP 没找到适用的 catch 块，异常会向上冒泡，直到 PHP 脚本由于致命错误而终止运行。</li><li>PHP 异常可以在 PHP 应用的任何层级抛出和捕获。</li><li>PHP 异常和错误设置原则：<ul><li>一定要让 PHP 报告错误。</li><li>在开发环境中要显示错误。</li><li>在生产环境中不能显示错误。</li><li>在开发环境和生产环境中都要记录错误。</li></ul></li><li>推荐配置：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; 开发环境</span><br><span class="line">; 显示错误</span><br><span class="line">display_startup_errors = On</span><br><span class="line">display_errors = On</span><br><span class="line">; 报告所有错误</span><br><span class="line">error_reporting = -1</span><br><span class="line">; 记录错误</span><br><span class="line">log_errors = On</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;生产环境</span><br><span class="line">; 不显示错误</span><br><span class="line">display_startup_errors = Off</span><br><span class="line">display_errors = Off</span><br><span class="line">; 除了注意事项之外，报告所有其他错误</span><br><span class="line">error_reporting = E_ALL &amp; ~E_NOTICE</span><br><span class="line">; 记录错误</span><br><span class="line">log_errors = On</span><br></pre></td></tr></table></figure><ul><li>推荐使用 <a href="https://github.com/filp/whoops" target="_blank" rel="noopener"><code>Whoops</code></a> 组件在开发环境中处理 PHP 错误和异常。</li><li>推荐使用 <a href="https://github.com/Seldaek/monolog" target="_blank" rel="noopener"><code>Monolog</code></a> 组件在生产环境中记录 PHP 错误和异常。</li></ul><h1 id="主机"><a href="#主机" class="headerlink" title="主机"></a>主机</h1><ul><li>存储 PHP 应用的四种方式：<ul><li>共享服务器（Shared hosting）</li><li>虚拟私有服务器（VPS）</li><li>专用服务器</li><li>平台即服务（PasS）</li></ul></li><li>共享主机账户会与很多其他顾客的账户在同一个物理设备中。PHP 应用能使用多少设备在内存取决于这台设备中有多少账户。共享主机适合少预算，或简单需求。</li><li>虚拟私有服务器（VPS）提供了足够的系统资源，需要我们根据 PHP 应用的需求，自己动手配置和保护操作系统。</li><li>PasS 只需账号登陆，使用提供商的控制面板，单击按钮即可完成操作。有些 PasS 提供商会提供命令行工具或 Http Api，让我们部署和管理存储的 PHP 应用。适合小型 PHP 应用省心省事。</li></ul><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="PHP-FPM"><a href="#PHP-FPM" class="headerlink" title="PHP-FPM"></a>PHP-FPM</h2><ul><li>PHP-FPM 全局配置 <code>php-fpm.conf</code></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">emergency_restart_threshold = 10</span><br><span class="line">//在指定的一段时间内，如果失效的 PHP-FPM 子进程数超过这个值，PHP-FPM 主进程就优雅重启。</span><br><span class="line"></span><br><span class="line">emergency_restart_interval = 1m</span><br><span class="line">//设定 emergency_restart_threshold 设置采用的时间跨度。</span><br></pre></td></tr></table></figure><ul><li>PHP-FPM 进程池配置 <code>fpm/pool.d/*.conf</code> 或 <code>php-fpm.d/*.conf</code></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user = deploy</span><br><span class="line">//运行 PHP 应用的非根用户的用户名</span><br><span class="line"></span><br><span class="line">group = deploy</span><br><span class="line">//运行 PHP 应用的非根用户所属的用户组名</span><br><span class="line"></span><br><span class="line">listen = 127.0.0.1:9000</span><br><span class="line">//PHP-FPM 进程池监听的 IP 地址和端口号</span><br><span class="line"></span><br><span class="line">listen.allowed_clients = 127.0.0.1</span><br><span class="line">//可以向该 PHP-FPM 进程池发送请求的 IP 地址（一个或多个）。</span><br><span class="line"></span><br><span class="line">pm.max_children = 51</span><br><span class="line">//设定任何时间点 PHP-FPM 进程池中最多能有多少个进程。可以设置的值设为总内存 / 每个进程使用的内存大小</span><br><span class="line"></span><br><span class="line">pm.start_servers = 3</span><br><span class="line">//PHP-FPM 启动时 PHP-FPM 进程池中立即可用的进程数。建议设为 2 或 3。</span><br><span class="line"></span><br><span class="line">pm.min_spare_servers = 2</span><br><span class="line">//PHP 应用空闲时 PHP-FPM 进程池中可以存在的进程数量最小值。一般与 pm.start_servers 设置值一样</span><br><span class="line"></span><br><span class="line">pm.max spare servers = 4</span><br><span class="line">//PHP 应用空闲时 PHP-FPM 进程池中可以存在的进程数量最大值。一般比 pm.start_servers 设置的值大一点</span><br><span class="line"></span><br><span class="line">pm.max requests = 1000</span><br><span class="line">//回收进程之前，PHP-FPM 进程池中各个进程最多能处理的 HTP 请求数量。</span><br><span class="line"></span><br><span class="line">slowlog = /path/to/slowlog log</span><br><span class="line">//设置慢日志（处理时间超过 n 秒的 HTTP 请求信息）的绝对路径。注意 PHP-FPM 进程池所属的用户和用户组必须有这个文件的写权限。</span><br><span class="line"></span><br><span class="line">request_slowlog_timeout = 5s</span><br><span class="line">//慢日志记录的 HTTP 请求的时间下限，超过此值即记录慢日志</span><br></pre></td></tr></table></figure><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    # Nginx 监听端口</span><br><span class="line">    listen 80;</span><br><span class="line">    # 虚拟主机的域名</span><br><span class="line">    server_name example.com;</span><br><span class="line">    # HTTP 请求 URI 没指定文件时访问的默认文件</span><br><span class="line">    index index.php;</span><br><span class="line">    # Nginx 接受 HTTP 请求主体长度的最大值</span><br><span class="line">    client_max_body_size 50M;</span><br><span class="line">    # 错误日志文件路径</span><br><span class="line">    error_log /home/deploy/apps/logs/example.error.log;</span><br><span class="line">    # 访问日志文件路径</span><br><span class="line">    access_log /home/deploy/apps/logs/example_access.log;</span><br><span class="line">    # 文档根目录路径</span><br><span class="line">    root /home/deploy/apps/example.com/current/public;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        tryz_files $uri $uri/ /index.php$is_args$args;</span><br><span class="line">    &#125;</span><br><span class="line">    location ~ \.php &#123;</span><br><span class="line">        try_files $uri =404;</span><br><span class="line">        fastcgi_split_path_info ^(.+\.php)(/.+)$;</span><br><span class="line">        include fastcgi_params;</span><br><span class="line">        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">        fastcgi_param SCRIPT_NAME $fastcgi_script_name;</span><br><span class="line">        fastcgi_index index.php;</span><br><span class="line">        fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>指定匹配指定 URL 模式的 HTTP 请求。location / {} 块使用 try_files 指令依次进行如下操作：<ol><li>査找匹配所请求 URI 的文件</li><li>查找匹配所请求 URI 的目录</li><li>把 HTTP 请求的 URI 重写为 /index.php，把査询字符附加到 URI 的末尾。</li></ol></li><li>重写的 URL 和所有以 .php 结尾的 URI 都由 location ~ .php {} 块管理，上例中该块规定把 HTTP 请求转发给 PHP-FPM 进程池处理。</li></ul><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><ul><li><code>php.ini</code> 配置中，建议修改 <code>upload_max_filesize = 10MB</code> 设置允许上传文件的大小</li><li><code>php.ini</code> 配置中，建议修改 <code>max_execution_time = 5</code> 设置单个 PHP 进程在终止之前最长可以运行多少时间。</li><li>应该在较少的块中发送更多的数据，而不是在较多的块中发送较少的数据，这样能减少 HTTP 请求总数。为此需要在 <code>php.ini</code> 配置中启用 PHP 输出缓存功能：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">output_buffering = 4096 // 输出缓存区大小</span><br><span class="line">implicit_flush = false</span><br></pre></td></tr></table></figure><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p>使用 <a href="https://github.com/capistrano/capistrano" target="_blank" rel="noopener">Capistrano</a> 来进行项目部署，可以方便地进行迭代和回滚操作。Capistrano 会在远程服务器中保存之前部署的应用，而且每次部署的版本放在各自的目录中。Capistrano 会维护五个或更多之前部署的应用，以防需要回滚到早前版本。Capistrano 还会创建一个 <code>current/</code> 目录,通过符号链接指向当前部署的应用所在的目录。具体步骤如下：</p><ol><li>在本地安装 ruby 和 gem   </li><li>在本地安装 Capistrano：<code>$ gem install capistrano</code>   </li><li><p>在项目根目录进行初始化：<code>$ cap install</code>，产生的初始化文件结构如下：   </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── Capfile                 //配置文件</span><br><span class="line">├── config                  //分环境配置文件</span><br><span class="line">│   ├── deploy              //环境配置目录</span><br><span class="line">│   │   ├── production.rb   //生产环境设置</span><br><span class="line">│   │   └── staging.rb      //过渡环境设置</span><br><span class="line">│   └── deploy.rb           //所有环境的通用设置</span><br><span class="line">└── lib</span><br><span class="line">    └── capistrano</span><br><span class="line">            └── tasks</span><br></pre></td></tr></table></figure></li><li><p>在远程服务器安装 Git：<code>$ yum install git</code></p></li><li>部署时在本地执行部署命令：<code>$ cap production deploy</code></li><li>回滚时在本地执行部署命令：<code>$ cap production deploy:rollback</code></li></ol><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>不同的测试方式之间不是互斥：   </p><ul><li>单元测试：单独证实应用中的各个类、方法和函数能正常运行。PHP 通常使用 PHPUnit 单元测试框架进行单元测试。<a href="https://phpunit.de/" target="_blank" rel="noopener">PHPUnit</a> 遵守 xUnit 测试架构。</li><li>测试驱动开发（Test-Driven Development, TDD）：在编写应用代码之前先写测试。故意让测试失败以描述应用应该具有怎样的表现。开发好应用的功能后，最终测试会成功通过。</li><li>行为驱动开发（Behavior-Driven Development, BDD）：编写故事，描述应用的表现。按导向不同氛围两类，二者一般可以共存互补，使项目获得更全面的测试。<ul><li>SpecBDD 是一种单元测试，使用人类能读懂的流畅语言描述应用的实现方式。例如，可能会把某个 PHPUnit 测试命名为 <code>testrendertemplate()</code>，把等价的 SpecBDD 测试命名为 <code>itrendersthetemplate()</code>，和 Xunit 工具相比更易于阅读和理解。通常使用的 SpecBDD 测试工具是 <a href="http://www.phpspec.net/" target="_blank" rel="noopener">PHPSPEC</a></li><li>StoryBDD 也使用人类能读懂的故事，不过 StoryBDD 关注更多的是整体行为，而不是低层实现。StoryBDD 测试关注项目整体的运行结果，而 SpecBDD 测试关注开发过程中的每个细节，如类、方法的正确性。通常使用的 StoryBDD 测试工具是 [Behat](<a href="http://behat.org/）" target="_blank" rel="noopener">http://behat.org/）</a></li></ul></li></ul><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><ul><li>开发环境使用 <a href="http://xdebiug.org" target="_blank" rel="noopener">XDebug</a>：使用时会消耗大量系统资源，借助 <a href="http://kcachegrind.sourceforge.net/" target="_blank" rel="noopener">KCacheGrind</a> 和 <a href="https://sourceforge.net/projects/wincachegrind/" target="_blank" rel="noopener">WinCacheGrind</a> 查看分析报告。</li><li>生产环境使用 <a href="http://xhprof.io" target="_blank" rel="noopener">XHProf</a>：使用时会消耗的系统资源少，借助 XHGUI 查看分析报告。</li></ul><h1 id="HHVM-和-Hack"><a href="#HHVM-和-Hack" class="headerlink" title="HHVM 和 Hack"></a>HHVM 和 Hack</h1><ul><li>PHP 是传统意义上的解释型语言，而不是编译型语言。因此，在命令行或 Web 服务器调用解释器解释 PHP 代码之前，PHP 代码就是 PHP 代码。PHP 解释器会解释 PHP 脚本，把代码转换成一系列 <a href="http://php.net/manual/internals2.opcodes.php" target="_blank" rel="noopener">Zend 操作码</a>（机器码指令），再把这些操作码交给 Zend Engine 执行。但解释型语言执行的速度比編译型语言慢很多，因为每次执行解释型语言编写的代码时都要将其转换成机器码，消耗额外的系统资源。</li><li>2010 年 Facebook 开发一个 HPHPc 的编译器，把 PHP 代码编译为 C++ 代码，再把 C++ 代码编译成可执行文件。但 HPHPc 对性能的提升已经到顶。于是 Facebook 开发了下一代 HPHPc，即 HHVM。HHVM 先把 PHP 代码转换成一种字节码中间格式，而且会缓存转换得到的字节码，然后使用 JIT 编译器转换并优化缓存的字节码，将其变成 x86_64 机器码。之后 HPHPc 被废弃。</li><li><a href="http://hacklang.org" target="_blank" rel="noopener">Hack</a> 是一门服务器端语言，类似 PHP，且可以和 PHP 无缝集成。Hack 的开发者其实把 Hack 当做 PHP 的一种方言。从 PHP 转到 Hack 只需将 PHP 标签 <code>&lt;?php</code> 改为 <code>&lt;?hh</code> 即可。</li><li>Hack 既支持静态类型，也支持动态类型，且基本上能向后兼容普通的 PHP，所以其支持所有 PHP 动态类型特性。HHVM 读取 Hack 代码后会优化和缓存中间字节码，只在需要时才把 Hack 文件转换成 x86_64 机器码。Hack 充分利用了两种类型系统的特性，我们通过 Hack 的类型检査程序得到了静态类型的准确性和安全性，又通过 HVM 的 JIT 编译器得到了动态类型的灵活性和快速迭代。</li><li>Hack 自带一个单独的类型检査服务器，这个服务器在后台运行，会实时对代码做类型检査。</li><li><p>Hack 代码有三种編写模式：</p><ul><li>严格模式：<code>&lt;?hh // strict</code> 要求所有变量、函数、方法等代码都有合适的类型注解。且代码中不能有 Hack 之外的代码。</li><li>局部模式：<code>&lt;?hh // partial</code> 允许在 Hack 代码中使用还没转换成 Hack 的 PHP 代码。不要求注解函数或方法的所有参数，如果只注解部分参数，Hack 的类型检査程序也不会报错。</li><li>声明模式：<code>&lt;?php // decl</code> 允许严格模式的 Hack 代码调用未指定类型的代码。</li></ul></li><li><p>Hack 提供了 PHP 没有的新数据结构和接口数据结构：</p><ul><li><a href="https://docs.hhvm.com/hack/built-in-types/arrays" target="_blank" rel="noopener">集合</a>（矢量，映射， 集和值对。）</li><li><a href="https://docs.hhvm.com/hack/generics/introduction" target="_blank" rel="noopener">泛型</a></li><li><a href="https://docs.hhvm.com/hack/built-in-types/enumerated-types" target="_blank" rel="noopener">枚举</a></li><li><a href="https://docs.hhvm.com/hack/built-in-types/shapes" target="_blank" rel="noopener">形状</a></li><li><a href="https://docs.hhvm.com/hack/built-in-types/tuples" target="_blank" rel="noopener">元组</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;命名空间（namespace）&quot;&gt;&lt;a href=&quot;#命名空间（namespace）&quot; class=&quot;headerlink&quot; title=&quot;命名空间（namespace）&quot;&gt;&lt;/a&gt;命名空间（namespace）&lt;/h1&gt;&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;PHP 命名空间与操作系统的物理文件系统不同，这是一个虚拟概念，没必要和文件系统中的目录结构完全对应。但是大多数 PHP 组件为了兼容 PSR-4 自动加载器标准，会把子命名空间放到文件系统的子目录中。&lt;/li&gt;
&lt;li&gt;从技术层面来看，命名空间只是 PHP 语言中的一种记号，PHP 解释器会将其作为前缀添加到类、接口、函数和常量的名称前面。&lt;/li&gt;
&lt;li&gt;不同代码可能使用相同的类名、接口名、函数名或常量名，如果不使用命名空间，名称会起冲突，导致 PHP 执行出错。而使用命名空间，把代码放在唯一的厂商命名空间中，这样不同命名空间下的代码就可以使用相同的名称命名类、接口、函数和常量。&lt;/li&gt;
&lt;li&gt;在同一个命名空间或子命名空间中的所有类没必要在同一个 PHP 文件中声明。你可以在 PHP 文件的顶部指定一个命名空间或子命名空间，此时，这个文件中的代码就是该命名空间或子命名空间的一部分。因此，我们可以在不同的文件中编写属于同一个命名空间的多个类。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://acuario.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习笔记" scheme="https://acuario.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="PHP" scheme="https://acuario.xyz/tags/PHP/"/>
    
      <category term="Modern PHP" scheme="https://acuario.xyz/tags/Modern-PHP/"/>
    
  </entry>
  
  <entry>
    <title>《精通正则表达式》学习笔记（六）</title>
    <link href="https://acuario.xyz/mastering-regex-summary-6/"/>
    <id>https://acuario.xyz/mastering-regex-summary-6/</id>
    <published>2019-08-17T15:00:53.000Z</published>
    <updated>2019-08-17T15:00:57.404Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="/mastering-regex-summary-1/">《精通正则表达式》学习笔记（一）</a><br>Ch.1 正则表达式入门<br>Ch.2 入门示例拓展</li><li><a href="/mastering-regex-summary-2/">《精通正则表达式》学习笔记（二）</a><br>Ch.3 正则表达式的特性和流派概览</li><li><a href="/mastering-regex-summary-3/">《精通正则表达式》学习笔记（三）</a><br>Ch.4 表达式的匹配原理</li><li><a href="/mastering-regex-summary-4/">《精通正则表达式》学习笔记（四）</a><br>Ch.5 正则表达式实用技巧</li><li><a href="/mastering-regex-summary-5/">《精通正则表达式》学习笔记（五）</a><br>Ch.6 打造高效正则表达式</li><li><a href="/mastering-regex-summary-6/">《精通正则表达式》学习笔记（六）</a><br>Ch.10 PHP 相关的正则表达式</li></ul><hr><h1 id="PHP-的正则流派"><a href="#PHP-的正则流派" class="headerlink" title="PHP 的正则流派"></a>PHP 的正则流派</h1><ul><li>PHP 的三种正则引擎是 <code>preg</code>、<code>creg</code> 和 <code>mb_ereg</code>。</li><li>在默认情况下，preg 套件的正则表达式是以字节为单位的，所以「<code>\C</code>」默认等价于「<code>(?d:.)</code>」，由 <code>s</code> 修饰的点号。不过，如果使用了修饰符 <code>u</code>，则 preg 套件就会以 UTF-8 字母为单位，也就是说，一个字符可能由 6 个字节组成。即使这样，「<code>\C</code>」仍然匹配单个字节。</li><li>「<code>\z</code>」和「<code>\Z</code>」都能够匹配字符串的末尾，而「<code>\Z</code>」同样能够匹配最后的换行符。</li><li>「<code>$</code>」的意义取决于模式修饰符 <code>m</code> 和 <code>D</code>：如果没有设定任何修饰符，「<code>$</code>」等价于「<code>\Z</code>」（在字符串结尾的换行符，或者是字符串结尾）；如果使用了 <code>m</code>，则它能够匹配内嵌的换行符，如果使用了模式修饰符 <code>D</code>，它能够匹配「<code>\z</code>」（只有在字符串的结尾）。如果同时设置了 <code>m</code> 和 <code>D</code>，则忽略 <code>D</code>。</li><li>PHP 正则引擎的处理方式完全是<strong>程序式</strong>的。</li></ul><a id="more"></a><h1 id="Preg-函数接口"><a href="#Preg-函数接口" class="headerlink" title="Preg 函数接口"></a>Preg 函数接口</h1><table><thead><tr><th>函数</th><th>用途</th></tr></thead><tbody><tr><td><code>preg_match</code></td><td>测试正则表达式能否在字待串中找到匹配，并提取数据</td></tr><tr><td><code>preg_match_all</code></td><td>从字苻串中提取数据</td></tr><tr><td><code>preg_replace</code></td><td>在字待串的副本中替换匹配的文本</td></tr><tr><td><code>preg_replace_callback</code></td><td>对字特事中的每处匹配文本调用处理函数</td></tr><tr><td><code>preg_split</code></td><td>将字苻串切分为子串数组</td></tr><tr><td><code>preg_grep</code></td><td>选出数组中能/不能由表达式匹配的元素</td></tr><tr><td><code>preg_quote</code></td><td>转义字符串中的正则表达式元字符</td></tr></tbody></table><h2 id="pattern-参数"><a href="#pattern-参数" class="headerlink" title="pattern 参数"></a>pattern 参数</h2><ul><li><code>patten</code> 参数是包含在一对斜线（分隔符）里头的参数。分隔符后面是模式修饰符。其参数的组成：<ol><li>分隔符</li><li>正则表达式</li><li>模式修饰符</li></ol></li></ul><h3 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h3><ul><li>preg 引擎要求正则表达式两端必须有分隔符，因为设计者希望它看起来更像 Perl，尤其在模式修饰符的使用方法上更是如此。</li><li>可以使用除了字母、数字、反斜线和空白字符之外的任何 ASCI 字符做分隔符。最常见的是一对斜线，或者两个 <code>!</code>、<code>#</code>。</li><li>分隔符的选取应该考虑实际情况，避免产生嵌套。如正则表达式内如果存在括号 <code>()</code>，则应该避免使用 <code>()</code> 作为分隔符。</li></ul><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><ul><li>因为正则表达式很有可能包含反斜线，所以在以字符串文字方式提供 pattern 参数时，最好使用 PHP 的单引号字符串，这样可以省略许多额外的转义。</li></ul><h3 id="模式修饰符"><a href="#模式修饰符" class="headerlink" title="模式修饰符"></a>模式修饰符</h3><ul><li>表达式内部的模式修饰符：在正则表达式内部，模式修饰符可以单独出现，来启用或停用某些特性，其作用范围持续到对应的结束括号。</li></ul><table><thead><tr><th>标准修饰符</th><th>用途</th><th>说明</th></tr></thead><tbody><tr><td><code>i</code></td><td>「<code>(?!)</code>」</td><td>忽略大小写</td></tr><tr><td><code>m</code></td><td>「<code>(?m)</code>」</td><td>增强的行铺点模式</td></tr><tr><td><code>s</code></td><td>「<code>(?s)</code>」</td><td>点号通配模式</td></tr><tr><td><code>x</code></td><td>「<code>(?x)</code>」</td><td>宽松排列和注释模式</td></tr></tbody></table><table><thead><tr><th>PHP 特有修饰符</th><th>用途</th><th>说明</th></tr></thead><tbody><tr><td><code>u</code></td><td></td><td>在 UTF-8 编码中，非 ASCI 字符以多个字节来存储，使用 <code>u</code> 修饰符能够以 UTF-8 编码处理正则表达式和目标字符串，确保多个字节会被作为单个字符来处理。处理时也不会修改数据，只是更改正则引擎处理数据的方式</td></tr><tr><td><code>S</code></td><td></td><td>启用 PCRE 的 “study” 优化特性，预先分析正则表达式，在某些顺利的情况下，在尝试匹配时速度会大大提升</td></tr><tr><td><code>D</code></td><td></td><td>把每个「<code>$</code>」替换为「<code>\z</code>」，即「<code>$</code>」匹配字符串的末尾，而不是字符串之内的换行符。</td></tr><tr><td><code>A</code></td><td></td><td>把匹配锚定在第一次尝试的位置</td></tr><tr><td><code>X</code></td><td>「<code>(?X)</code>」</td><td>启用 PCRE “额外功能（extra stuff）”，报告非无法识别的反斜线序列</td></tr><tr><td><code>e</code></td><td></td><td>将 replacement 作为 PHP 代吗（只用于 <code>preg_replace</code>)</td></tr><tr><td><code>U</code></td><td>「<code>(?U)</code>」</td><td>交换「<code>*</code>」和「<code>*?</code>」的匹配优先含义，<strong>建议不使用</strong></td></tr></tbody></table><h1 id="Preg-函数罗列"><a href="#Preg-函数罗列" class="headerlink" title="Preg 函数罗列"></a>Preg 函数罗列</h1><h2 id="preg-match"><a href="#preg-match" class="headerlink" title="preg_match"></a><code>preg_match</code></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int preg_match ( string $pattern , string $subject [, array &amp;$matches [, int $flags = 0 [, int $offset = 0 ]]] )</span><br></pre></td></tr></table></figure><ul><li><code>$matches</code> 末尾的空字符串都会被忽略。</li><li>使用命名捕获会使代码更易读，但使用了命名捕获，按数字编号的捕获仍然会插人 <code>$matches</code>。所以不推荐同时使用命名和数字编号来访问 <code>$matches</code> 的元素。</li></ul><p><img src="https://i.loli.net/2019/08/06/2tTh3QbLRim67zO.png" alt="命名捕获"></p><ul><li>参数 flags 可使用参数值：<code>PREG_OFFSET_CAPTURE</code> 使第 1 个元素是匹配的文本，第 2 个元素是这段文本在目标字符串中的偏移值。其通常按照<strong>字节</strong>来计数。</li></ul><h2 id="preg-match-all"><a href="#preg-match-all" class="headerlink" title="preg_match_all"></a><code>preg_match_all</code></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int preg_match_all ( string $pattern , string $subject [, array &amp;$matches [, int $flags = PREG_PATTERN_ORDER [, int $offset = 0 ]]] )</span><br></pre></td></tr></table></figure><ul><li>每个匹配都会创建一个包含匹配数据的数组，所以最后 matches 变量就是一个二维数组，其中的每个子数组对应一次匹配。</li><li>参数 flags 可使用参数值 <code>PREG_PATTERN_ORDER</code> 和 <code>PREG_SET_ORDER</code> 用于制定排列方式：</li></ul><table><thead><tr><th>类型</th><th>标志位</th><th>说明及示例</th></tr></thead><tbody><tr><td>按分组号</td><td><code>PREG_PATTERN_ORDER</code></td><td>将各次匹配中同样编号的分组编在一起</td></tr><tr><td>堆叠</td><td><code>PREG_SET_ORDER</code></td><td>将每次匹配的数据集中保存</td></tr></tbody></table><h2 id="preg-replace"><a href="#preg-replace" class="headerlink" title="preg_replace"></a><code>preg_replace</code></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] )</span><br></pre></td></tr></table></figure><ul><li>对文本进行査找-替换的办法。</li><li><code>subject</code> 也可以是一个字符串数组，搜索和替换是对每个字符串依次进行的。</li><li><code>pattern</code> 和 <code>replacement</code> 参数也可以是字符申数组。</li><li>如果 <code>subject</code> 参数是数组，则依次处理数组中的每个元素，返回值也是字符串数组。</li><li><code>preg_replace</code> 的程序要使用 <code>each()</code> 来按照数组的内部顺序历整个数组，而不关心它们的 keys 如何。</li><li>如果 <code>pattern</code> 或 <code>replacement</code> 数组的内部顺序不同于你希望匹配的顺序，可以使用 <code>sort()</code> 函数来确保每个数组的实际顺序和外表顺序是相同的。</li></ul><h2 id="preg-replace-callback"><a href="#preg-replace-callback" class="headerlink" title="preg_replace_callback"></a><code>preg_replace_callback</code></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mixed preg_replace_callback ( mixed $pattern , callable $callback , mixed $subject [, int $limit = -1 [, int &amp;$count ]] )</span><br></pre></td></tr></table></figure><ul><li><code>replacement</code> 参数变成了 PHP 回调函数，而不是字符串或是字符串数组。</li></ul><h2 id="preg-split"><a href="#preg-split" class="headerlink" title="preg_split"></a><code>preg_split</code></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array preg_split ( string $pattern , string $subject [, int $limit = -1 [, int $flags = 0 ]] )</span><br></pre></td></tr></table></figure><ul><li><code>preg_split</code> 找出目标字符串中不能由正则表达式匹配的部分。返回目标字符串中正则表达式匹配的部分別去之后的部分。相当于 PHP 中内建的简单 <code>explode</code> 函数，不过使用的是正则表达式，而且功能更强大。</li><li><code>limit</code> 参数用来设定切分之后数组长度的上限。达到 <code>limit</code> 之后的文本内容会全部保存到最后的元素当中。</li><li>参数 flags 可使用参数值：<ul><li><code>PREG_SPLIT_OFFSET_CAPTURE</code> 标志位会修改结果数组，把每个元素变为包含两个元素的数组（元素本身和它在字符串中的偏移值）。</li><li><code>PREG_SPLIT_NO_EMPTY</code> 标志位告诉 <code>preg_split</code> 忽略空字符串。</li><li><code>PREG_SPLIT_DELIM_CAPTURE</code> 标志位在结果中包含匹配的文本，以及捕获括号匹配的文本。</li></ul></li></ul><h2 id="preg-grep"><a href="#preg-grep" class="headerlink" title="preg_grep"></a><code>preg_grep</code></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">preg_grep ( string $pattern , array $input [, int $flags = 0 ] ) : array</span><br></pre></td></tr></table></figure><ul><li><code>preg_grep</code> 生成 <code>$input</code> 数组的副本，其中只保留了 <code>$value</code> 能够匹配 <code>$pattern</code> 的元素。</li></ul><h2 id="preg-quote"><a href="#preg-quote" class="headerlink" title="preg_quote"></a><code>preg_quote</code></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">preg_quote ( string $str [, string $delimiter = NULL ] ) : string</span><br></pre></td></tr></table></figure><ul><li>转义正则表达式字符，向其中每个正则表达式语法中的字符前增加一个反斜线。 </li></ul><h1 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h1><ol><li>回调函数通常要比模式修饰符 <code>e</code> 更快；</li><li>在太长的目标字符串中使用命名捕获必须进行更多的数据拷贝。</li><li>除非把同一个表达式应用到大规模的文本，或者大量小规模文本时，オ需要考虑模式修饰符 <code>S</code>。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-1/&quot;&gt;《精通正则表达式》学习笔记（一）&lt;/a&gt;&lt;br&gt;Ch.1 正则表达式入门&lt;br&gt;Ch.2 入门示例拓展&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-2/&quot;&gt;《精通正则表达式》学习笔记（二）&lt;/a&gt;&lt;br&gt;Ch.3 正则表达式的特性和流派概览&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-3/&quot;&gt;《精通正则表达式》学习笔记（三）&lt;/a&gt;&lt;br&gt;Ch.4 表达式的匹配原理&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-4/&quot;&gt;《精通正则表达式》学习笔记（四）&lt;/a&gt;&lt;br&gt;Ch.5 正则表达式实用技巧&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-5/&quot;&gt;《精通正则表达式》学习笔记（五）&lt;/a&gt;&lt;br&gt;Ch.6 打造高效正则表达式&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-6/&quot;&gt;《精通正则表达式》学习笔记（六）&lt;/a&gt;&lt;br&gt;Ch.10 PHP 相关的正则表达式&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&quot;PHP-的正则流派&quot;&gt;&lt;a href=&quot;#PHP-的正则流派&quot; class=&quot;headerlink&quot; title=&quot;PHP 的正则流派&quot;&gt;&lt;/a&gt;PHP 的正则流派&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;PHP 的三种正则引擎是 &lt;code&gt;preg&lt;/code&gt;、&lt;code&gt;creg&lt;/code&gt; 和 &lt;code&gt;mb_ereg&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;在默认情况下，preg 套件的正则表达式是以字节为单位的，所以「&lt;code&gt;\C&lt;/code&gt;」默认等价于「&lt;code&gt;(?d:.)&lt;/code&gt;」，由 &lt;code&gt;s&lt;/code&gt; 修饰的点号。不过，如果使用了修饰符 &lt;code&gt;u&lt;/code&gt;，则 preg 套件就会以 UTF-8 字母为单位，也就是说，一个字符可能由 6 个字节组成。即使这样，「&lt;code&gt;\C&lt;/code&gt;」仍然匹配单个字节。&lt;/li&gt;
&lt;li&gt;「&lt;code&gt;\z&lt;/code&gt;」和「&lt;code&gt;\Z&lt;/code&gt;」都能够匹配字符串的末尾，而「&lt;code&gt;\Z&lt;/code&gt;」同样能够匹配最后的换行符。&lt;/li&gt;
&lt;li&gt;「&lt;code&gt;$&lt;/code&gt;」的意义取决于模式修饰符 &lt;code&gt;m&lt;/code&gt; 和 &lt;code&gt;D&lt;/code&gt;：如果没有设定任何修饰符，「&lt;code&gt;$&lt;/code&gt;」等价于「&lt;code&gt;\Z&lt;/code&gt;」（在字符串结尾的换行符，或者是字符串结尾）；如果使用了 &lt;code&gt;m&lt;/code&gt;，则它能够匹配内嵌的换行符，如果使用了模式修饰符 &lt;code&gt;D&lt;/code&gt;，它能够匹配「&lt;code&gt;\z&lt;/code&gt;」（只有在字符串的结尾）。如果同时设置了 &lt;code&gt;m&lt;/code&gt; 和 &lt;code&gt;D&lt;/code&gt;，则忽略 &lt;code&gt;D&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;PHP 正则引擎的处理方式完全是&lt;strong&gt;程序式&lt;/strong&gt;的。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://acuario.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="RegEx" scheme="https://acuario.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/RegEx/"/>
    
    
      <category term="学习笔记" scheme="https://acuario.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="精通正则表达式" scheme="https://acuario.xyz/tags/%E7%B2%BE%E9%80%9A%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="RegEx" scheme="https://acuario.xyz/tags/RegEx/"/>
    
      <category term="PHP" scheme="https://acuario.xyz/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>《精通正则表达式》学习笔记（五）</title>
    <link href="https://acuario.xyz/mastering-regex-summary-5/"/>
    <id>https://acuario.xyz/mastering-regex-summary-5/</id>
    <published>2019-08-07T16:17:53.000Z</published>
    <updated>2019-08-11T15:23:47.249Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="/mastering-regex-summary-1/">《精通正则表达式》学习笔记（一）</a><br>Ch.1 正则表达式入门<br>Ch.2 入门示例拓展</li><li><a href="/mastering-regex-summary-2/">《精通正则表达式》学习笔记（二）</a><br>Ch.3 正则表达式的特性和流派概览</li><li><a href="/mastering-regex-summary-3/">《精通正则表达式》学习笔记（三）</a><br>Ch.4 表达式的匹配原理</li><li><a href="/mastering-regex-summary-4/">《精通正则表达式》学习笔记（四）</a><br>Ch.5 正则表达式实用技巧</li><li><a href="/mastering-regex-summary-5/">《精通正则表达式》学习笔记（五）</a><br>Ch.6 打造高效正则表达式</li><li><a href="/mastering-regex-summary-6/">《精通正则表达式》学习笔记（六）</a><br>Ch.10 PHP 相关的正则表达式</li></ul><hr><ul><li>因为 NFA 引擎容许用户进行精确控制，所以我们可以用心打造正则表达式。</li><li>调校表达式时需要考虑的两个因素是<strong>准确性</strong>和<strong>效率</strong>：精确匹配文本而不包含多余的内容，且速度要快。</li><li>优化表达式的关键在于彻底理解回溯背后的过程，学习些技巧来避免可能的回溯。</li><li>不同工具可能使用不同的优化措施。如果能够预先判断目标字符串基本无法匹配（例如目标宇符串缺少一个引擎能够预知的，匹配成功必须的字符），足够聪明的实现方式可以完全不应用正则表达式。</li><li>在分析效率时，不要忘了不同正则引擎的差异。</li></ul><a id="more"></a><h2 id="多选分支的顺序优化"><a href="#多选分支的顺序优化" class="headerlink" title="多选分支的顺序优化"></a>多选分支的顺序优化</h2><p>期望：匹配引号字符串（允许转义双引号）<br>RegEx：<code>&quot;(\\.|[^\\&quot;])*&quot;</code>   </p><ul><li><strong>多选分支的顺序很重要，其会影响回溯的发生与否和发生回溯的先后顺序。</strong></li><li>调换「<code>\\.</code>」和「<code>[^\\&quot;]</code>」的顺序，只有在遇到字符串中的转义字符时才会按照多选结构进行回溯，这样增加了第一个多选分支的成功匹配次数，有效减少回溯的次数。</li><li>为提高效率修改正则表达式时最需要考虑的问题是，改动是否会影响匹配的准确性。在关注效率的时候，万不可忘记准确性。<em>重新安排多选分支的顺序</em>这种操作，只有在排序与匹配成功无关时才不会影响准确性。</li><li>在任意正则表达式中，星号会对每个普通字符进行迭代（或者说“重复”），重复进入一退出多选结构（和括号）。星号量词作用于括号内的子表达式，每次迭代都需要进入然后再退出括号，因为引擎需要记录括号内的子表达式匹配的文本。为此必须进行处理。</li><li>优化表达式时，使一次迭代中读入尽可能多的字符，尽量减少发生回溯的次数，把星号迭代的次数减少到最小：</li></ul><p><img src="https://i.loli.net/2019/07/25/5d3925bdeb92a68557.jpg" alt></p><h2 id="指数级匹配（超线性，super-linear）"><a href="#指数级匹配（超线性，super-linear）" class="headerlink" title="指数级匹配（超线性，super-linear）"></a>指数级匹配（超线性，super-linear）</h2><ul><li>表达式「<code>&quot;([^\\&quot;]+|\\.)*&quot;</code>」在 POSIX NFA 中匹配 <code>very ...... long</code> 时需要超过 3 亿亿亿次回溯。因为正则表达式中某个元素受加号限定的同时，还受括号外的星号限定，无法区分哪个量词控制哪个特殊的字符。</li><li>对正则表达式「<code>([^\\&quot;]+)*</code>」来说，加号和星号二者分割（divvy up）字符串的可能性是成指数形式增长的。</li><li>对不同类型引擎指数级匹配的差异：<ul><li>如果其中的某个表达式，即使不能匹配，也能很快给出结果，那可能就是 DFA。</li><li>如果只有在能够匹配时才很快出结果，那就是传统型 NFA。</li><li>如果总是很慢，那就是 POSIX NFA。</li></ul></li></ul><h2 id="回溯实例"><a href="#回溯实例" class="headerlink" title="回溯实例"></a>回溯实例</h2><h3 id="匹配成功的回溯"><a href="#匹配成功的回溯" class="headerlink" title="匹配成功的回溯"></a>匹配成功的回溯</h3><ul><li>从局部来看，回溯就是倒退至未尝试的分支。</li></ul><p><img src="https://i.loli.net/2019/07/26/5d3a6ab8dec8f93141.jpg" alt="图像 (9).jpg"></p><ul><li>表达式「<code>&quot;.*&quot;</code>」在 <strong>NFA</strong> 引擎中的匹配过程如图所示：   <ol><li>多次匹配失败直到 A 处   </li><li>从 <code>A-B</code> 处均匹配成功，并在每个位置（共计 46 处）撒下面包屑，记录保存状态   </li><li>从 <code>B-C</code> 开始逐步回溯，直到 <code>C</code> 处匹配成功   </li></ol></li><li>表达式「<code>&quot;.*&quot;</code>」在 <strong>POSIX NFA</strong> 引擎中的匹配过程与 <strong>NFA</strong> 类似，但为了确认<strong><em>最长的匹配</em></strong>，还需进行一些确认操作：   <ol><li>多次匹配失败直到 <code>A</code> 处   </li><li>从 <code>A-B</code> 处均匹配成功，并在每个位置（共计 46 处）撒下面包屑，记录保存状态   </li><li>从 <code>B-C</code> 开始逐步回溯，知道 <code>C</code> 处匹配成功   </li><li>尝试过程 <code>D-E-F</code> 和 <code>F-G-H</code> 类似 <code>B-C-D</code>，只是 <code>F</code> 和 <code>H</code> 会被抛弃，因为它们匹配的文本都比 <code>D</code> 更短</li><li><code>I</code> 位置完成当前匹配的所有回溯，重新启动驱动过程，进行下一轮匹配尝试。但由于已经有匹配成功的文本，所以直接返回匹配结果。</li></ol></li></ul><h3 id="无法匹配成功的回溯"><a href="#无法匹配成功的回溯" class="headerlink" title="无法匹配成功的回溯"></a>无法匹配成功的回溯</h3><p>表达式「<code>&quot;.*&quot;!</code>」无法匹配范例文本，在匹配过程中进行多轮匹配尝试，每次尝试都有回溯产生，其匹配过程如图所示：</p><p><img src="https://i.loli.net/2019/07/26/5d3a6ab8eee6752532.jpg" alt></p><h3 id="通过优化表达式来减少回溯"><a href="#通过优化表达式来减少回溯" class="headerlink" title="通过优化表达式来减少回溯"></a>通过优化表达式来减少回溯</h3><p>表达式「<code>&quot;[^&quot;]*&quot;!</code>」通过使用「<code>[^&quot;]</code>」来替代「<code>.*</code>」，通过减少可能匹配的字符，从而大大降低了回溯产生的次数。减少的回溯就是有意的<strong>伴随效应（side effect）</strong></p><p><img src="https://i.loli.net/2019/07/26/5d3a6ab8c8c5e54462.jpg" alt></p><h3 id="多选结构的回溯"><a href="#多选结构的回溯" class="headerlink" title="多选结构的回溯"></a>多选结构的回溯</h3><p>使用多选结构时，需要注意引起的回溯对性能的影响。</p><p>文本：<code>The name &quot;McDonald&#39;s&quot; is said &quot;makudonarudo&quot; in Japanese</code>.<br>期望：<code>makudonarudo</code>   </p><table><thead><tr><th>RegEx</th><th>回溯次数</th></tr></thead><tbody><tr><td>「<code>[uvwxyz]</code>」</td><td>34</td></tr><tr><td>「<code>u|v|w|x|y|z</code>」</td><td>204</td></tr></tbody></table><h2 id="常见优化原理"><a href="#常见优化原理" class="headerlink" title="常见优化原理"></a>常见优化原理</h2><ul><li>提高匹配效率的优化原理主要有：<ol><li><strong>加速某些操作</strong></li><li><strong>避免冗余操作</strong></li></ol></li><li>只有在检测优化措施是否可行所需的时间少于节省下来的匹配时间的情况下，优化才是有益的。</li><li>优化所需的时间、节省的时间、优化的可能性这三者间存在互相制约的关系。</li></ul><h3 id="应用前的优化"><a href="#应用前的优化" class="headerlink" title="应用前的优化"></a>应用前的优化</h3><ul><li>编译缓存：<ul><li>正则表达式使用之前先进行错误检查，之后编译为内部形式检查字符串。</li><li>为提高编译效率，首次编译之后的内部形式会被保存或缓存下来，在此后的循坏中复用。</li><li>集成式处理中的编译缓存：正则表达式可能每次循环都会变化，优化措施是检査插值后的结果（也就是正则表达式的具体值），只有当具体值发生变化时才重新编译。</li><li>集成式处理中的编译缓存：编译形式与表达式在程序中所处的具体位置相关，正则表达式变化时，先检査插值后的结果（即正则表达式的具体值），当具体值发生变化时才重新编译。</li><li>程序式处理中的编译缓存：<ul><li>编译形式与表达式在程序中所处的具体位置无关，每次调用函数时，正则表达式必须重新编译。</li><li>将最近使用的正则表达式模式（regex pattern）缓存后关联到最终的编译形式。</li><li>调用“应用此表达式”函数之后，作为参数的正则表达式模式会与保存的正则表达式相比较，如果已存在于缓存中，就使用缓存的版本。如果没有，就直接编译这个正则表达式，将其存入缓存。无可用缓存时，丢弃一个最久未使用的编译形式。</li></ul></li><li>面向对象式处理中的编译缓存：正则表达式何时编译完全由程序决定。通过构造函数来进行编译。通过对象析构函数抛弃编译好的正则表达式。</li></ul></li><li>预查（子）字符串优化：在实际应用正则表达式之前，在目标字符串中快速扫描，检査所需的字符或者字符串一如果不存在，根本就不需要进行任何尝试。</li><li>长度判断优化：预先判断目标文本的长度是否满足正则表达式要求的最小长度，若不满足，则不进行任何尝试。</li></ul><h3 id="传动装置的优化"><a href="#传动装置的优化" class="headerlink" title="传动装置的优化"></a>传动装置的优化</h3><table><thead><tr><th>优化策略</th><th>释义</th><th>栗子</th></tr></thead><tbody><tr><td>字符串起始 / 行锚点</td><td>任何以「<code>^</code>」开头的正则表达式只能在「<code>^</code>」能够匹配的情况下才可能匹配。</td><td>「<code>^this|^that</code>」修改为「<code>^(this|that)</code>」或 「<code>^(?:this|that)</code>」</td></tr><tr><td>隐式锚点</td><td>如果正则表达式以「<code>.*</code>」或「<code>.+</code>」开头，且没有全局性多选结构（global alternation），则可以认为此正则表达式的开头有一个看不见的「<code>^</code>」。则使用上一节的“字符串起始 / 行锚点优化”，节省大量的时间。</td><td></td></tr><tr><td>字符串结束 / 行锚点</td><td>遇到末尾为「<code>$</code>」或其他结束锚点的正则表达式时，能够从字符申末尾倒数若干字符的位置开始尝试匹配。</td><td>「<code>regex(es)?$</code>」从倒数第 8 个字符开始匹配</td></tr><tr><td>开头字符 / 字符组 / 子串识别</td><td>容许传动装置预先检查字符串中的每个字符，只在可能匹配的位置进行应用，这样能节省大量的时间。避免从错误的位置开始执行匹配尝试。</td><td>「<code>this|that|other</code>」只能从「<code>[ot]</code>」位置开始匹配</td></tr><tr><td>内嵌文字字符串检查</td><td>类似初始字符串识别优化，使用高速的 Boyer-Moore 字符串检索算法寻找目标位置。</td><td></td></tr><tr><td>长度识别传动</td><td>当前位置距离字符申末尾的长度小于成功匹配所需最小长度，传动装置会停止匹配尝试。</td><td></td></tr></tbody></table><h3 id="正则表达式本身的优化"><a href="#正则表达式本身的优化" class="headerlink" title="正则表达式本身的优化"></a>正则表达式本身的优化</h3><ul><li>文字字符串连接：把多个字符串当作整体而非分离的个体，例如将「<code>abc</code>」视为整体而非，「<code>a</code>」然后「<code>b</code>」然后「<code>c</code>」。</li><li>化简量词：约束普通元素的加号、星号之类的量词。避免普通 NFA 引擎的大部分逐步处理开销（step-by-step overhead）。例如「<code>.*</code>」和「<code>(?:.)*</code>」在逻辑上是相等的，但是在进行此优化的系统中，「<code>.*</code>」实际上更快。</li><li>消除无必要括号：使用无括号的等价的表达式进行替换。如使用「<code>.*</code>」替换「<code>(?:.)*</code>」。</li><li>消除不需要的字符组：将只包含单个字符的字符组在内部进行转换。如「<code>[.]</code>」转换为「<code>\.</code>」。</li><li>忽略优先量词之后的字符优化：忽略优先量词通常比匹配优先量词要慢。如果文字字符跟在忽略优先量词之后，只要引擎没有触及那个文字字符，忽略优先量词可以作为普通的匹配优先量词来处理，从而跳过常规的“忽略”状态。</li><li>“过度”回溯检测：限定回溯堆栈的大小，即限定回溯的次数，在“超限”时停止匹配。</li><li>避免指数级匹配：在匹配尝试进入超线性状态时进行检测，记录每个量词对应的子表达式尝试匹配的位置，绕过重复尝试。</li><li>使用占有优先量词削减状态：不保留“在此处不进行匹配”的状态，在量词全部尝试完成之后抛弃所有备用状态，每一轮迭代时抛弃上轮的备用状态。否则，如应用「<code>.*</code>」会在匹配每个字符时创造一个状态，如果字符串很长，会占用大量的内存。</li><li>量词等价转换：根据不同语言的正则表达式特性，对量词进行替换，如「<code>\d\d\d\d</code>」替换为「<code>\d{4}</code>」。</li><li>需求识别：预先取消它认为对匹配结果没有价值的工作。</li></ul><h2 id="常见优化方法"><a href="#常见优化方法" class="headerlink" title="常见优化方法"></a>常见优化方法</h2><table><thead><tr><th>优化方法</th><th>释义</th><th>栗子</th></tr></thead><tbody><tr><td>避免重新编译</td><td>编译和定义正则表达式的次数应该尽可能的少。在循环外创建正则表达式对象，在循环中重复使用。函数式处理要保证循环中使用的正则表达式的数目少于工具所能缓存的上限。集成式处理避免在循环内的正则表达式中使用变量插值。</td><td></td></tr><tr><td>使用非捕获型括号</td><td>不需要引用的文本，使用非捕获型括号「<code>(?:...)</code>」节省捕获时间，减少回溯使用的状态的数量。</td><td></td></tr><tr><td>不要滥用括号</td><td>使用括号会阻止某些优化措施。</td><td></td></tr><tr><td>不要滥用字符组</td><td>使用元字符来替代单个字符的字符组</td><td>使用「<code>\.</code>」来替代「<code>[.]</code>」</td></tr><tr><td>使用起始锚点</td><td>以「<code>.*</code>」开头的正则表达式都应该在最前面添加「<code>^</code>」或者「<code>\A</code>」。配合开头字符 / 字符串 / 字串识别优化，节省不必要的工作。</td><td></td></tr><tr><td>将文字文本独立出来</td><td>“提取”必要元素：暴露必须的匹配内容。</td><td>使用「<code>xx*</code>」替代「<code>x+</code>」暴露匹配 <code>x</code>，使用「<code>------{0,2}</code>」替代「<code>-{5,7}</code>」暴露匹配 <code>-</code>。</td></tr><tr><td>将文字文本独立出来</td><td>“提取”多选结构开头的必须元素</td><td>使用「<code>------{0,2}</code>」替代「<code>-{5,7}</code>」暴露匹配 <code>-</code>。</td></tr><tr><td>将锚点独立出来</td><td>在表达式前面独立出 <code>^</code> 和 <code>\G</code></td><td></td></tr><tr><td>将锚点独立出来</td><td>在表达式末尾独立出 <code>$</code></td><td></td></tr></tbody></table><ul><li>如果目标字符串很长：<ul><li>分号接近字符串的开头，使用忽略优先量词。</li><li>分号接近宇符串末尾的位置，使用匹配优先量词。</li><li>若是随机数据，又不知道分号接近文首或文尾，则使用匹配优先的量词。</li></ul></li><li>如果目标字符串很短，使用何种优先量词无所谓。</li><li>多个小正则表达式的速度比一个大正则表达式要快得多。</li><li>在表达式的开头添加合适的环视结构，可以让表达式对文本进行“预査”，选择合适的开始位置。</li><li>固化分组和占有优先量词能够极大地提高匹配速度，而不会改变匹配结果。</li><li>主导引擎的匹配<ul><li>将最可能匹配的多选分支放在前头：许多时候多选分支的摆放顺序比优化更重要，但如果顺序与匹配正确无关，就应该把最可能匹配的多选分支放在首位。这一点只对传统型 NFA 引擎且只有存在匹配的时候才适用。对 POSIX NFA 或不存在匹配时，所有的多选分支都必须检测，所以顺序是无关紧要的。</li><li>将结尾部分分散到多选结构内：把尾部通配表达式加到多选结构之内，匹配时不需要退出多选结构就能发现失败，则匹配失败的更快。</li></ul></li><li>各种优化都是平等的，在优化时请务必小心，不要因小失大。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-1/&quot;&gt;《精通正则表达式》学习笔记（一）&lt;/a&gt;&lt;br&gt;Ch.1 正则表达式入门&lt;br&gt;Ch.2 入门示例拓展&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-2/&quot;&gt;《精通正则表达式》学习笔记（二）&lt;/a&gt;&lt;br&gt;Ch.3 正则表达式的特性和流派概览&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-3/&quot;&gt;《精通正则表达式》学习笔记（三）&lt;/a&gt;&lt;br&gt;Ch.4 表达式的匹配原理&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-4/&quot;&gt;《精通正则表达式》学习笔记（四）&lt;/a&gt;&lt;br&gt;Ch.5 正则表达式实用技巧&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-5/&quot;&gt;《精通正则表达式》学习笔记（五）&lt;/a&gt;&lt;br&gt;Ch.6 打造高效正则表达式&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-6/&quot;&gt;《精通正则表达式》学习笔记（六）&lt;/a&gt;&lt;br&gt;Ch.10 PHP 相关的正则表达式&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;因为 NFA 引擎容许用户进行精确控制，所以我们可以用心打造正则表达式。&lt;/li&gt;
&lt;li&gt;调校表达式时需要考虑的两个因素是&lt;strong&gt;准确性&lt;/strong&gt;和&lt;strong&gt;效率&lt;/strong&gt;：精确匹配文本而不包含多余的内容，且速度要快。&lt;/li&gt;
&lt;li&gt;优化表达式的关键在于彻底理解回溯背后的过程，学习些技巧来避免可能的回溯。&lt;/li&gt;
&lt;li&gt;不同工具可能使用不同的优化措施。如果能够预先判断目标字符串基本无法匹配（例如目标宇符串缺少一个引擎能够预知的，匹配成功必须的字符），足够聪明的实现方式可以完全不应用正则表达式。&lt;/li&gt;
&lt;li&gt;在分析效率时，不要忘了不同正则引擎的差异。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://acuario.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="RegEx" scheme="https://acuario.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/RegEx/"/>
    
    
      <category term="学习笔记" scheme="https://acuario.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="精通正则表达式" scheme="https://acuario.xyz/tags/%E7%B2%BE%E9%80%9A%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="RegEx" scheme="https://acuario.xyz/tags/RegEx/"/>
    
      <category term="正则表达式的优化" scheme="https://acuario.xyz/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>SSH配置登陆密钥和别名</title>
    <link href="https://acuario.xyz/configure-ssh-host-and-keychain/"/>
    <id>https://acuario.xyz/configure-ssh-host-and-keychain/</id>
    <published>2019-07-29T16:30:07.000Z</published>
    <updated>2019-08-02T16:50:30.831Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通常在 Shell 中使用 SSH 连接远程服务器时，我们需要输入完整的 SSH 命令，如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ssh user@example.com#连接远端22端口并输入密码登陆</span><br></pre></td></tr></table></figure><p>然后根据提示输入 <code>user</code> 用户的密码登陆主机。</p><p>有两个常用的参数：</p><ul><li><code>-p</code> 指定其他 SSH 端口，如 SSH 端口非 22 端口，可用此参数指定</li><li><code>-i</code> 指定私钥通过密钥登陆，可配置好密钥后对免密登陆</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 连接远端1234端口</span><br><span class="line">$ ssh user@example.com -p 1234</span><br><span class="line"></span><br><span class="line"># 使用私钥id_rsa登陆</span><br><span class="line">$ ssh user@example.com -i ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><p>但是随着手头服务器配置的增加，而不同服务器 IP、端口、用户、使用的密钥均不同，每次繁琐地查询和输入这么多配置和参数实在是麻烦，何况我怎么记得住这么多 IP 地址啊！（主要还是因为懒</p><a id="more"></a><h1 id="配置密钥登陆"><a href="#配置密钥登陆" class="headerlink" title="配置密钥登陆"></a>配置密钥登陆</h1><p>通过修改 SSH 的配置文件，为服务器预先配置好各主机的私钥和别名，之后就可以方便快捷地登陆服务器。</p><p>修改 <code>~/.ssh/config</code> 文件，格式如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host *</span><br><span class="line">AddKeysToAgent yes</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><p>上例配置 SSH 默认使用私钥 <code>~/.ssh/id_rsa</code> 进行连接。如果远端服务器已经事先将 <code>~/.ssh/id_rsa.pub</code> 添加到对应用户的 <code>~/.ssh/authorized_keys</code> 文件中，那么在本地执行命令 <code>$ ssh user@example.com</code> 后就可以自动免密登陆主机 <code>example.com</code></p><h1 id="配置主机别名"><a href="#配置主机别名" class="headerlink" title="配置主机别名"></a>配置主机别名</h1><p>对于个别不同的服务器配置，我们可以继续在 <code>~/.ssh/config</code> 文件中添加配置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host test</span><br><span class="line">Hostname localhost.test</span><br><span class="line">Port 1234</span><br><span class="line">IdentityFile ~/.ssh/test_rsa</span><br><span class="line">User ubuntu</span><br></pre></td></tr></table></figure><p>上例配置主机 <code>localhost.test:1234</code> 使用用户 <code>ubuntu</code> 和私钥 <code>~/.ssh/test_rsa</code> 进行连接。如果不配置 <code>IdentityFile</code> 则会提示输入密码才能登陆。</p><p>可以看到上述配置的 <code>Host</code> 项即为 SSH 连接的别名。该例中 <code>Host</code> 值为 <code>test</code>，那么我们在需要 SSH 连接主机 <code>localhost.test:1234</code> 的时候就可以直接执行命令立即免密登陆远端主机：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh test</span><br></pre></td></tr></table></figure><h1 id="命令别名"><a href="#命令别名" class="headerlink" title="命令别名"></a>命令别名</h1><p>如果不想这么麻烦，也可以通过设置命令别名来达到目的</p><p>修改 <code>~/.bash_profile</code> 文件，并根据服务器配置添加不同的命令别名：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alias myserver=&quot;ssh user@example.com&quot;</span><br><span class="line">alias myserver1234=&quot;ssh user@localhost.test -p 1234&quot;</span><br><span class="line">alias myserver=&quot;ssh user@remote.test -i ~/.ssh/id_rsa&quot;</span><br></pre></td></tr></table></figure><p>需要 SSH 连接主机 <code>localhost.test:1234</code> 的时候执行命令 <code>$ myserver1234</code> 即可。</p><p>真是好方便呢！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;通常在 Shell 中使用 SSH 连接远程服务器时，我们需要输入完整的 SSH 命令，如：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ ssh user@example.com			#连接远端22端口并输入密码登陆&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后根据提示输入 &lt;code&gt;user&lt;/code&gt; 用户的密码登陆主机。&lt;/p&gt;
&lt;p&gt;有两个常用的参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-p&lt;/code&gt; 指定其他 SSH 端口，如 SSH 端口非 22 端口，可用此参数指定&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-i&lt;/code&gt; 指定私钥通过密钥登陆，可配置好密钥后对免密登陆&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 连接远端1234端口&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ ssh user@example.com -p 1234&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 使用私钥id_rsa登陆&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ ssh user@example.com -i ~/.ssh/id_rsa&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是随着手头服务器配置的增加，而不同服务器 IP、端口、用户、使用的密钥均不同，每次繁琐地查询和输入这么多配置和参数实在是麻烦，何况我怎么记得住这么多 IP 地址啊！（主要还是因为懒&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="https://acuario.xyz/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="https://acuario.xyz/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="SSH" scheme="https://acuario.xyz/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>《精通正则表达式》学习笔记（四）</title>
    <link href="https://acuario.xyz/mastering-regex-summary-4/"/>
    <id>https://acuario.xyz/mastering-regex-summary-4/</id>
    <published>2019-07-23T13:44:11.000Z</published>
    <updated>2019-08-11T15:23:52.894Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="/mastering-regex-summary-1/">《精通正则表达式》学习笔记（一）</a><br>Ch.1 正则表达式入门<br>Ch.2 入门示例拓展</li><li><a href="/mastering-regex-summary-2/">《精通正则表达式》学习笔记（二）</a><br>Ch.3 正则表达式的特性和流派概览</li><li><a href="/mastering-regex-summary-3/">《精通正则表达式》学习笔记（三）</a><br>Ch.4 表达式的匹配原理</li><li><a href="/mastering-regex-summary-4/">《精通正则表达式》学习笔记（四）</a><br>Ch.5 正则表达式实用技巧</li><li><a href="/mastering-regex-summary-5/">《精通正则表达式》学习笔记（五）</a><br>Ch.6 打造高效正则表达式</li><li><a href="/mastering-regex-summary-6/">《精通正则表达式》学习笔记（六）</a><br>Ch.10 PHP 相关的正则表达式</li></ul><hr><blockquote><p>编写巧妙的正则表达式不仅仅是一种手艺(skill) 而且还是一种艺术(art)。</p></blockquote><h1 id="正则引擎的平衡法则"><a href="#正则引擎的平衡法则" class="headerlink" title="正则引擎的平衡法则"></a>正则引擎的平衡法则</h1><ul><li>只匹配期望的文本，排除不期望的文本。</li><li>易于控制和理解。</li><li>使用NFA引擎时必须保证效率——能够匹配时立即返回匹配结果，不能匹配时尽快报告匹配失败。</li></ul><a id="more"></a><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><h2 id="匹配-IP-地址"><a href="#匹配-IP-地址" class="headerlink" title="匹配 IP 地址"></a>匹配 IP 地址</h2><ul><li>「<code>[0-9]*\.[0-9]*\.[0-9]*\.[0-9]*</code>」会匹配 <code>and then ......</code></li><li>「<code>^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$</code>」字符组书写重复</li><li>「<code>^\d+\.\d+\.\d+\.\d+$</code>」会匹配非 IP 地址文本如：<code>1234.5678.9101112.131415</code></li><li>「<code>^\d\d\d\.\d\d\d\.\d\d\d\.\d\d\d$</code>」数字部分匹配不够灵活，仅能匹配 3 位数字</li><li>下面三个表达式会匹配非法 IP 地址数字 <code>999</code><ul><li>「<code>^\d{1,3}.\d{1,3}.\d{1,3}.\d{1,3}$</code>」</li><li>「<code>\d\d?\d?.\d\d?\d?.\d\d?\d?.\d\d?\d?$</code>」</li><li>「<code>\d(\d\d?)?.\d(\d\d?)?.\d(\d\d?)?.\d(\d\d?)?$</code>」</li></ul></li><li>分析 IP 地址结构可以得出以下规律：<ul><li>只包含一个或两个数字的字段，无需考虑合法性，即「<code>\d|\d\d</code>」。</li><li><code>0</code> 或 <code>1</code> 开头的三位数（<code>000</code>-<code>199</code>）都合法。即「<code>[01]\d\d</code>」。</li><li><code>2</code> 开头的三位数字，第二位数字小于 <code>5</code> 则合法（<code>255</code>），即「<code>2[0-4]\d</code>」。</li><li>若第二位数字是 <code>5</code>，第三位数字就必须小于 <code>6</code>（<code>256</code>），即「<code>25[0-5]</code>」。</li><li>上述结果为「<code>\d|\d\d|[01]\d\d|2[0-4]\d|25[0-5]</code>」</li><li>合并前三个多选分支「<code>\d|\d\d|[01]\d\d</code>」为「<code>[01]?\d\d?</code>」</li><li>综上，一个 IP 地址数字的表达式结果为「<code>[01]?\d\d?|2[0-4]\d|25[0-5]</code>」</li></ul></li><li><p>匹配一个 IP 地址的表达式为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">「^([01]?\d\d?|2[0-4]\d|25[0-5])\.([01]?\d\d?|2[0-4]\d|25[0-5])\.([01]?\d\d?|2[0-4]\d|25[0-5])\.([01]?\d\d?|2[0-4]\d|25[0-5])$」</span><br></pre></td></tr></table></figure></li><li><p>在「<code>^</code>」后添加环视「<code>(?!0+\.0+\.0+\.0+$)</code>」来避免匹配 <code>0.0.0.0</code></p></li><li>在表达式首尾添加环视「<code>(?&lt;![\w.])</code>…<code>(?![\w.])</code>」或使用「<code>(^| )</code>…<code>( |$)</code>」来保证匹配文本前后不出现「<code>[\w.]</code>」能匹配的字符，避免匹配嵌套型字符 <code>1.2.3.4.5.6</code> 中的 <code>1.2.3.4</code> 等类似 IP 地址的文本</li><li>某些时候，处理各种极端情形会降低投入产出比。更合适的做法是<strong>不依赖正则表达式完成全部工作，善用其他工具辅助验证</strong>。</li></ul><h2 id="处理文件名"><a href="#处理文件名" class="headerlink" title="处理文件名"></a>处理文件名</h2><p>文本：<code>/usr/local/bin/gcc</code><br>期望：<code>gcc</code>   </p><ol><li>去掉文件名开头的路径<br>RegEx：<code>^.*/</code><br>释义：使用匹配优先（贪婪）特性，匹配一整行，然后回溯到最后的斜线   </li></ol><ul><li>若匹配一个恰好没有斜线的字符串，正则引擎会在字符串的起始位置开始搜索。「<code>.*</code>」抵达字符串的末尾，但不断回退，直到最后它交还了匹配的所有字符，仍然无法匹配。此时，正则引擎得知<strong>在字符串的起始位</strong>不存在匹配。</li><li>之后传动装置开始工作，从第 2 个字符开始，依次尝试匹配整个正则表达式，在字符串的每个位置进行扫描回溯。若字符串很长，就可能存在大量的回溯（DFA 不存在这个问题)。</li><li>几乎所有以「<code>.*</code>」开头的正则表达式，在某个字符串的起始位置不能匹配，也就不能在其他任何位置匹配，它只会在字符串的起始位置尝试一次。</li><li>在正则表达式中写明开头位置的匹配规则更明智一些。</li></ul><ol start="2"><li>从路径中获取文件名<br>RegEx：<code>([^/]*)$</code><br>释义：在结尾设置一个锚点，忽略路径，从最后一个斜线开始匹配所有内容。   </li></ol><ul><li>该表达式的唯一要求是字符串有 <code>$</code> 能够匹配的结束位置</li><li>在 NFA 中，该表达式的效率很低，要进行 40+ 次回溯。</li></ul><ol start="3"><li>所在路径和文件名<br>RegEx：<code>^(.*)/(.*)$</code><br>释义：使用 <code>$1</code> 和 <code>$2</code> 来提取所在路径和文件名。第一个「<code>.*</code>」先捕获所有文本，不给「<code>/</code>」和 <code>$2</code> 留下任何字符，在尝试匹配「<code>/(.*)$</code>」时发生的回溯会把“交还的”部分留给后面的「<code>.*</code>」。   </li></ol><h2 id="匹配对称的括号"><a href="#匹配对称的括号" class="headerlink" title="匹配对称的括号"></a>匹配对称的括号</h2><ol><li>「<code>\(.*\)</code>」 匹配括号及括号内部的任何字符。</li><li>「<code>\([^)]*\)</code>」 匹配从一个开括号到最近的闭括号。</li><li>「<code>\([^()]*\)</code>」 匹配从一个开括号到最近的闭括号，但是不容许其中包含开括号。</li></ol><ul><li>上下述三个表达式用于匹配带括号的文本内容，匹配结果如图</li></ul><p><img src="https://i.loli.net/2019/07/17/5d2e05fe2848445405.png" alt="匹配带括号的文本"></p><ul><li>为解决<strong>正则表达式无法匹配任意深度的嵌套结构</strong>的问题，可以用正则表达式来匹<br>配特定深度的嵌套括号，但不是任意深度的嵌套括号。</li><li>处理单层嵌套的正则表达式是:「<code>\([^()]*(\([^()]*\)[^()]*)*\)</code>」</li></ul><h2 id="匹配浮点数"><a href="#匹配浮点数" class="headerlink" title="匹配浮点数"></a>匹配浮点数</h2><ul><li>「<code>-?[0-9]*\.?[0-9]*</code>」会匹配 <code>-.0</code></li><li>「<code>-?[0-9]*\.?[0-9]*</code>」会产生空匹配（匹配没有任何必须的元素），如 <code>this has no number</code>、<code>nothing here</code></li><li><strong>把真正意图表达清楚</strong>非常重要：一个浮点数必须要有至少一位数字，否则就不是一个合法的值。</li><li>「<code>-?[0-9]+</code>」用于限定浮点数含有数字的特性</li><li>「<code>(\.[0-9]*)?</code>」用于限定浮点数的<em>小数点</em>和<em>小数部分</em></li><li>综上，「<code>-?[0-9]+(\.[0-9]*)?</code>」即可用于匹配浮点数而不匹配空字符，即不产生<strong>空匹配</strong></li></ul><h2 id="匹配分隔符之内的文本"><a href="#匹配分隔符之内的文本" class="headerlink" title="匹配分隔符之内的文本"></a>匹配分隔符之内的文本</h2><p>文本：<code>a passport needs a &quot;2\&quot;x3\&quot; likeness&quot; of the holder</code><br>期望：<code>&quot;2\&quot;x3\&quot; likeness&quot;</code>   </p><ul><li>匹配分隔符之内的文本的主要步骤：<ol><li>匹配起始分隔符(opening delimiter)。</li><li>匹配正文(main text,即结束分隔符之前的所有文本)。</li><li>匹配结束分隔符。</li></ol></li><li>匹配开始和结束分隔符很容易，但匹配正文的时不能超越结束分隔符：<ul><li>匹配非引号内容：「<code>[^&quot;]</code>」   </li><li>匹配转义的反斜线需要使用环视：「<code>(?&lt;=\\)&quot;</code>」   </li><li>综上得出的表达式为「<code>&quot;([^&quot;]|(?&lt;=\\)&quot;)*&quot;</code>」，此时可以匹配 <code>2\&quot;x3\&quot;</code></li></ul></li></ul><p>文本：<code>&quot;/-|-\\&quot; or &quot;[^-^]&quot;</code><br>期望：<code>&quot;/-|-\\&quot;</code><br>RegEx：<code>&quot;([^&quot;]|(?&lt;=\\)&quot;)*&quot;</code><br>结果：<code>&quot;/-|-\\&quot; or &quot;</code>   </p><ul><li>第一个闭引号之前存在一个反斜线，该反斜线本身是被转义的，其后的引号是表示引用文本的结束。逆序环视无法识别这个被转义的反斜线。</li><li>匹配的位于开始分隔符和结東分隔符之间的文本可以包括转义的字符「<code>\\.</code>」，也可以包括非引号的任何字符「<code>[^&quot;]</code>」。</li><li>综上得出的表达式为「<code>&quot;(\\.|[^&quot;])*&quot;</code>」</li><li>匹配优先和忽略优先都期望获得匹配，如果找不到结束的引号，它就会回溯，从而降低性能。</li><li>如果回溯会导致不期望，与多选结构有关的匹配结果，可能是因为任何成功的匹配都不过是多选分支的排列顺序造成的偶然结果，</li><li>如果有<strong>占有优先量词</strong>或者是<strong>固化分组</strong>，那么这个正则表达式可以被持续优化以提升性能（特别是对于 NFA）</li></ul><h2 id="去除文本首尾的空白字符"><a href="#去除文本首尾的空白字符" class="headerlink" title="去除文本首尾的空白字符"></a>去除文本首尾的空白字符</h2><ol><li>去除文本首部的空白字符「<code>s/^\s+//</code>」<br>去除文本末尾的空白字符「<code>s/\s+$/</code>」   </li><li>去除文本首尾空白字符的表达式：「<code>s/\s*(.*?)\s*$/$1/s</code>」<br>该表达式因为忽略优先约束的点号每次应用时都要检查「<code>\s*$</code>」导致大量回溯，严重影响效率。</li><li>去除文本首尾空白字符的表达式：「<code>s/^\s*((?:.*\S)?)\s*$/$1/s</code>」后面的「<code>\S</code>」强迫回溯直到找到一个非空字符，把剩下的空白字符留给最后的「<code>\s*$</code>」，捕获括号之外的内容。</li></ol><h1 id="HTML-相关范例"><a href="#HTML-相关范例" class="headerlink" title="HTML 相关范例"></a>HTML 相关范例</h1><h2 id="匹配-HTML-Tag"><a href="#匹配-HTML-Tag" class="headerlink" title="匹配 HTML Tag"></a>匹配 HTML Tag</h2><p>RegEx：<code>&lt;(&quot;[^&quot;]*&quot;|&#39;[^&#39;]*&#39;|[^&#39;&quot;&gt;])*&gt;</code><br>释义：<br><img src="https://i.loli.net/2019/07/20/5d31ec5ad68a949796.png" alt="匹配 HTML Tag"></p><ul><li>引用字符串可能为空（例如 <code>alt=&quot;&quot;</code>）, 所以最开始的两个多选分支的引号中使用「<code>*</code>」而非「<code>+</code>」。</li><li>NFA 引擎下，多选分支之间不存在重复，所以最后的「<code>&gt;</code>」无法匹配是产生的回溯是不需要的，可使用非捕获型括号改写表达式以提高效率。</li></ul><h2 id="匹配-HTML-Link"><a href="#匹配-HTML-Link" class="headerlink" title="匹配 HTML Link"></a>匹配 HTML Link</h2><p>文本：<code>...&lt;a href=&quot;http://www.oreilly.com&quot;&gt;O&#39;Reilly Media&lt;/a&gt;...</code><br>期望：<code>http://www.oreilly.com</code> 和 <code>O&#39;Reilly Media</code><br>RegEx：<code>\b HRFF\s* = \s*(?:&quot;([^&quot;]*)&quot;|&#39;([^&#39;]*)&#39;|([^&#39;&quot;&gt;\S]+))</code><br>释义：<br><img src="https://i.loli.net/2019/07/20/5d31f0a71ac2934742.png" alt="匹配 HTML Link"></p><h2 id="校验-HTTP-URL"><a href="#校验-HTTP-URL" class="headerlink" title="校验 HTTP URL"></a>校验 HTTP URL</h2><p>将 URL 地址分解为主机名（hostname）和路径（path）两部分。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^http://        # 匹配协议</span><br><span class="line">([^/:]+)        # 捕获主机名</span><br><span class="line">(:(\d+))?       # 匹配端口号（可能没有）</span><br><span class="line">(/.*)?$         # 捕获路径</span><br></pre></td></tr></table></figure><h2 id="提取-URL"><a href="#提取-URL" class="headerlink" title="提取 URL"></a>提取 URL</h2><p>从纯文本中提取 URL 的正则表达式框架如下：<br><img src="https://i.loli.net/2019/07/22/5d34a44a170a511410.png" alt="提取纯文本中的URL"></p><h2 id="几个保持数据协调性的原则"><a href="#几个保持数据协调性的原则" class="headerlink" title="几个保持数据协调性的原则"></a>几个保持数据协调性的原则</h2><p>手动保持正则引擎的协调，才能忽略不需要的文本。有时为了提高表达式的效率，应该选择跳过不需要的文本，而非使用正向思维直接匹配目标文本。</p><ol><li>根据期望保持匹配的协调性<br>合理使用忽略优先量词，在后面的表达式失败之前，优先忽略容易引起大范围匹配成功的匹配操作。跳过我们希望跳过的文本而进行匹配。</li><li>不匹配时也应当保证协调性   </li><li>使用「<code>\G</code>」保证协调<br>「<code>\G</code>」用于匹配上一次匹配结束的位置。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-1/&quot;&gt;《精通正则表达式》学习笔记（一）&lt;/a&gt;&lt;br&gt;Ch.1 正则表达式入门&lt;br&gt;Ch.2 入门示例拓展&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-2/&quot;&gt;《精通正则表达式》学习笔记（二）&lt;/a&gt;&lt;br&gt;Ch.3 正则表达式的特性和流派概览&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-3/&quot;&gt;《精通正则表达式》学习笔记（三）&lt;/a&gt;&lt;br&gt;Ch.4 表达式的匹配原理&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-4/&quot;&gt;《精通正则表达式》学习笔记（四）&lt;/a&gt;&lt;br&gt;Ch.5 正则表达式实用技巧&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-5/&quot;&gt;《精通正则表达式》学习笔记（五）&lt;/a&gt;&lt;br&gt;Ch.6 打造高效正则表达式&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-6/&quot;&gt;《精通正则表达式》学习笔记（六）&lt;/a&gt;&lt;br&gt;Ch.10 PHP 相关的正则表达式&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;编写巧妙的正则表达式不仅仅是一种手艺(skill) 而且还是一种艺术(art)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;正则引擎的平衡法则&quot;&gt;&lt;a href=&quot;#正则引擎的平衡法则&quot; class=&quot;headerlink&quot; title=&quot;正则引擎的平衡法则&quot;&gt;&lt;/a&gt;正则引擎的平衡法则&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;只匹配期望的文本，排除不期望的文本。&lt;/li&gt;
&lt;li&gt;易于控制和理解。&lt;/li&gt;
&lt;li&gt;使用NFA引擎时必须保证效率——能够匹配时立即返回匹配结果，不能匹配时尽快报告匹配失败。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://acuario.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="RegEx" scheme="https://acuario.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/RegEx/"/>
    
    
      <category term="学习笔记" scheme="https://acuario.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="精通正则表达式" scheme="https://acuario.xyz/tags/%E7%B2%BE%E9%80%9A%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="RegEx" scheme="https://acuario.xyz/tags/RegEx/"/>
    
      <category term="正则引擎" scheme="https://acuario.xyz/tags/%E6%AD%A3%E5%88%99%E5%BC%95%E6%93%8E/"/>
    
      <category term="平衡法则" scheme="https://acuario.xyz/tags/%E5%B9%B3%E8%A1%A1%E6%B3%95%E5%88%99/"/>
    
      <category term="正则表达式实例" scheme="https://acuario.xyz/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AE%9E%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>《精通正则表达式》学习笔记（三）</title>
    <link href="https://acuario.xyz/mastering-regex-summary-3/"/>
    <id>https://acuario.xyz/mastering-regex-summary-3/</id>
    <published>2019-07-14T15:27:11.000Z</published>
    <updated>2019-08-11T15:23:57.508Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="/mastering-regex-summary-1/">《精通正则表达式》学习笔记（一）</a><br>Ch.1 正则表达式入门<br>Ch.2 入门示例拓展</li><li><a href="/mastering-regex-summary-2/">《精通正则表达式》学习笔记（二）</a><br>Ch.3 正则表达式的特性和流派概览</li><li><a href="/mastering-regex-summary-3/">《精通正则表达式》学习笔记（三）</a><br>Ch.4 表达式的匹配原理</li><li><a href="/mastering-regex-summary-4/">《精通正则表达式》学习笔记（四）</a><br>Ch.5 正则表达式实用技巧</li><li><a href="/mastering-regex-summary-5/">《精通正则表达式》学习笔记（五）</a><br>Ch.6 打造高效正则表达式</li><li><a href="/mastering-regex-summary-6/">《精通正则表达式》学习笔记（六）</a><br>Ch.10 PHP 相关的正则表达式</li></ul><hr><h1 id="正则引擎的分类"><a href="#正则引擎的分类" class="headerlink" title="正则引擎的分类"></a>正则引擎的分类</h1><p>正则引擎主要分为 3 类：</p><ol><li>DFA（符合或不符合 POSIX 标准的都属此类）</li><li>传统型 NFA</li><li>POSIX NFA</li></ol><table><thead><tr><th>引擎类型</th><th>程序</th><th>忽略优先量词（懒惰）</th><th>捕获型括号</th><th>回溯</th></tr></thead><tbody><tr><td>DFA</td><td><code>awk</code>（大多数版本）、<code>egrep</code>（大多数版本）、<code>flex</code>、<code>lex</code>、MySQL、Procmail</td><td>不支持</td><td>不支持</td><td>不支持</td></tr><tr><td>传统型 NFA</td><td>GNU Emacs、Java、<code>grep</code>（大多数版本）、<code>less</code>、<code>more</code>、.NET 语言、PCRE library、Perl、PHP（所有三套正则库）、Python、Ruby、sed（大多数版本）、<code>vi</code></td><td>支持</td><td>支持</td><td>支持，但性能差</td></tr><tr><td>POSIX NFA</td><td><code>mawk</code>、Mortice Kern Systems’utilities、GNU Emacs（明确指定时使用）</td><td>不支持</td><td>支持</td><td>支持，但性能差</td></tr><tr><td>DFA/NFA 混合</td><td>GNU <code>awk</code>、GNU <code>grep/egrep</code>、Tcl</td><td>支持</td><td>支持</td><td>DFA 支持</td></tr></tbody></table><ul><li>判断是否传统型 NFA：是否支持忽略优先量词（懒惰）。使用正则表达式 <code>nfa|nfa not</code> 来匹配字符串 <code>nfa not</code>，如果只匹配了 <code>nfa</code>，这就是传统型 NFA。如果整个 <code>nfa not</code> 都能匹配，则此引擎要么是 POSIXNFA，要么是 DFA。</li></ul><a id="more"></a><h1 id="匹配的基础"><a href="#匹配的基础" class="headerlink" title="匹配的基础"></a>匹配的基础</h1><p>普适规则：</p><ol><li>优先选择最左端（最靠开头）的匹配结果。</li><li>标准的匹配量词（<code>*</code>、<code>+</code>、<code>?</code> 和 <code>{m，n}</code>）是匹配优先（greedy，贪婪）的。</li></ol><ul><li>标准匹配量词的结果“可能”并非所有可能中最长的，但它们总是尝试匹配尽可能多的字符，直到<strong>匹配上限</strong>为止。如果最终结果并非该表达式的所有可能中最长的，原因肯定是匹配字符过多导致匹配失败。</li><li>「<code>.*</code>」永远不会失败，因为“不匹配任何字符”也是「<code>.*</code>」的可能结果之一。</li><li>「<code>(.*).*</code>」结果没有变化。开头的「<code>.*</code>」（括号中的）会霸占整个标题的文本，而不给第二个「<code>.*</code>」留下任何字符。而第二个「<code>.*</code>」的匹配失败并不要紧，因为「<code>.*</code>」不匹配任何字符也能成功。如果我们给第二个「<code>.*</code>」也加上括号，<code>$2</code>将会是空白。</li><li>表达式中的某些部分可能“<strong>强迫</strong>”之前匹配优先的部分“释放”（或者说“交还（unmatch）”） 某些字符。例如：「<code>^.*([0-9][0-9])</code>」将“<strong>强迫</strong>”「<code>.*</code>」交还两个数字使得匹配成功。</li><li>多个贪婪贪婪量词之间遵循「<strong>先来先服务</strong>」原则。例如：「<code>^.*([0-9]+)</code>」试图匹配 <code>copyright 2003</code> 时，「<code>([0-9]+)</code>」只能匹配到「3」而非「2003」，在该例子中，首先服务「<code>^.*</code>」，使其满足最贪婪的要求，然后才服务「<code>([0-9]+)</code>」。</li></ul><h1 id="表达式主导与文本主导"><a href="#表达式主导与文本主导" class="headerlink" title="表达式主导与文本主导"></a>表达式主导与文本主导</h1><ul><li>DFA：确定型有穷自动机</li><li>NFA：非确定型有穷自动机</li></ul><blockquote><p>NFA 以表达式本身为依据，进行匹配尝试，DFA 以匹配文本为依据，观察子表达式是否匹配成功。</p></blockquote><ul><li>NFA 引擎：表达式主导（regex-directed）——表达式中的控制权在不同的元素之间转换。正则表达式每次检查一部分（由引擎查看表达式的一部分），同时检查“当前文本（current text）”是否匹配表达式的当前部分。如果是，则继续表达式的下一部分，如此继续，直到表达式的所有部分都能匹配，即整个表达式能够匹配成功。</li><li>DFA 引擎：文本主导（text-directed）——在扫描字符串时，会记录“当前有效（currently in the works）”的所有匹配可能。</li><li>DFA引擎在扫描字符串时，会记录“当前有效（currently in the works）”的所有匹配可能。</li><li>DFA 扫描的字符串中的每个字符都对引擎进行了控制。在本例中，某个未完成的匹配也许是任意多个（只要可行）匹配的开始。不合适的匹配可能在扫描后继文字时会被去除。文本中出现的某个字符会令所有处理中的匹配可能失效，就会返回某个之前保留的完整匹配。如果不存在这样的完整匹配，则要报告在当前位置无法匹配。</li></ul><h2 id="NFA-和-DFA-比较"><a href="#NFA-和-DFA-比较" class="headerlink" title="NFA 和 DFA 比较"></a>NFA 和 DFA 比较</h2><ul><li>一般情况下，文本主导的 DFA 引擎要快一些。正则表达式主导的 NFA 引擎，因为需要对同样的文本尝试不同的子表达式匹配，可能会浪费时间。</li><li>在 NFA 的匹配过程中，目标文本中的某个字符可能会被正则表达式中的不同部分重复检测（甚至有可能被同一部分反复检测）。</li><li>DFA 引擎则是确定型的（deterministic）——目标文本中的每个字符只会检查（最多）一遍。</li><li>DFA 引擎会同时记录所有的匹配选择，所以不同表达式最终能够捕获的文本相同，在写法上的差异并无意义，选择哪一个表达式并无区别。</li><li>DFA 匹配很迅速、一致。</li></ul><h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><ul><li>如果正则表达式中余下的部分最终匹配失败，引擎会知道需要<strong>回溯</strong>到之前做出选择的地方，选择其他的备用分支继续尝试。</li><li>回溯仅发生于 NFA 引擎执行匹配时，这是由 NFA 的特性导致——NFA 引擎是表达式主导，在每次扫描文本后都检测是否满足量词和多选结构，如果不满足且无待扫描文本，则会一次又一次「撤销」扫描，取出最近一次满足匹配的结果。这个回滚动作就是「回溯」。</li><li><p>回溯的机制类似于面包屑 / 压栈（LIFO，Last In First Out，后进先出），也可以说面包屑即为压栈存储的一个个<strong>备用状态</strong>。</p><p>举个栗子，用「<code>[0-9+]</code>」来匹配 <code>a 1234 num</code> 的过程中：</p><p><img src="https://i.loli.net/2019/06/21/5d0c38074ab5f56669.png" alt></p><p>锚点从上到下形如面包屑，在匹配失败时回到上一级继续尝试匹配。<br>四个锚点的的状态都会作为保留状态记录下来，依次查看最长的匹配文本，并在匹配失败时一个接一个回溯回来。</p></li><li><p>回溯机制不但需要重新计算正则表达式和文本的对应位置，也需要维护括号内的子表达式所匹配文本的状态。</p></li><li>在匹配过程中，每次回溯都把当前状态中正则表达式的对应位置指向括号之前。</li><li>回溯对括号的这种处理，不但需要同时维护 <code>$1</code> 的状态，也会影响匹配的效率。</li><li>由星号（或其他任何匹配优先量词）限定的部分不受后面元素影响，而只是匹配尽可能多的内容。</li><li>忽略优先的匹配（懒惰）的原因在于，其首先考虑尝试忽略，如「<code>b??</code>」中的懒惰量词「<code>??</code>」会首先<strong>匹配零个</strong>文本 <code>b</code>（注意并不是<strong>不匹配</strong>）</li><li>简单说，懒惰量词就是匹配其能力的下限，比如「<code>b{3,8}?</code>」在匹配 <code>bbbbbbb</code> 时只匹配 3 个 <code>b</code>；「<code>b+?</code>」在匹配 <code>bbbbbbb</code> 时只匹配 1 个 <code>b</code>。</li></ul><h1 id="关于贪婪、懒惰和回溯的要点"><a href="#关于贪婪、懒惰和回溯的要点" class="headerlink" title="关于贪婪、懒惰和回溯的要点"></a>关于贪婪、懒惰和回溯的要点</h1><ul><li><p>由于「<code>*</code>」是贪婪的量词，所以在使用时还需谨慎，不能过分依赖。举个栗子：<br>文本：<code>The name &quot;McDonald&#39;s&quot; is said &quot;makudonarudo&quot; in Japanese.</code></p><ol><li><p>RegEx：<code>&quot;.*&quot;</code><br>结果：<code>&quot;McDonald&#39;s&quot; is said &quot;makudonarudo&quot;</code><br>释义：贪婪量词尽可能多地进行匹配</p></li><li><p>RegEx：<code>&quot;[^&quot;]*&quot;</code><br>结果：<code>&quot;McDonald&#39;s&quot;</code><br>释义：「<code>[^&quot;]</code>」尽可能多地匹配非<code>&quot;</code>的字符，即<code>&quot;</code>前的字母</p></li></ol></li><li><p>善用<strong>懒惰量词</strong>解决成对标签的问题。举个栗子：<br>文本：<code>...&lt;B&gt;Billions&lt;/B&gt; and &lt;B&gt;Zillions&lt;/B&gt; of suns....</code><br>期望：<code>&lt;B&gt;Billions&lt;/B&gt;</code></p><ol><li><p>RegEx：<code>&lt;B&gt;[^&lt;/B&gt;]&lt;/B&gt;</code><br>结果：匹配失败<br>释义：<code>[]</code>是字符范围元字符，无法表达<code>非&lt;/B&gt;</code>的含义，可以使用环视功能进行匹配</p></li><li><p>RegEx：<code>&lt;B&gt;.*?&lt;/B&gt;</code><br>结果：<code>&lt;B&gt;Billions&lt;/B&gt;</code><br>释义：「<code>*?</code>」为懒惰量词，可以尽可能少地匹配文本</p></li></ol></li><li><p>懒惰量词有时在处理成对符号时并不完美。举个栗子：<br>文本：<code>...&lt;B&gt;Billions and &lt;B&gt;Zillions&lt;/B&gt; of suns....</code><br>期望：<code>&lt;B&gt;Zillions&lt;/B&gt;</code></p><ol><li><p>RegEx：<code>&lt;B&gt;.*?&lt;/B&gt;</code><br>结果：<code>&lt;B&gt;Billions and &lt;B&gt;Zillions&lt;/B&gt;</code><br>释义：「<code>.*?</code>」会匹配左边的<code>&lt;B&gt;</code>标签，这是不满足期望的，可以使用<strong>排除环视</strong>功能进行匹配</p></li><li><p>RegEx：<br><img src="https://i.loli.net/2019/07/04/5d1e1c173fa1470167.png" alt><br>结果：<code>&lt;B&gt;Billions&lt;/B&gt;</code></p></li><li><p>RegEx：<br><img src="https://i.loli.net/2019/07/04/5d1e1c6c2cb0387976.png" alt><br>结果：<code>&lt;B&gt;Billions&lt;/B&gt;</code></p></li></ol></li><li><p>有一些问题是贪婪和懒惰都无法解决的问题，举个例子：<br>文本：<code>1.62500000002828</code>，<code>9.43</code>，<code>27.625</code><br>期望：替换过长小数为三位小数 <code>1.625</code>，<code>9.43</code>，<code>27.625</code></p><ol><li><p>RegEx：<code>$prive =~ s/(\.\d\d[1-9]?)\d*/$1/;</code><br>结果：<code>$1 = 1.625</code><br>释义：对于匹配三位小数，此表达式效率还不够高，部分匹配过程存在浪费</p></li><li><p>RegEx：<code>$prive =~ s/(\.\d\d[1-9]?)\d+/$1/;</code><br>结果：<code>$1 = 1.625</code>（正常替换），<code>$1 = 9.43</code> （不替换），<code>$1 = 27.62</code><br>释义：「<code>\.\d\d</code>」匹配了 <code>27.62</code>，「<code>\d+</code>」匹配了 <code>5</code>，「<code>[1-9]?</code>」为可选分支，优先级别比「<code>\d+</code>」低，不进行任何匹配，于是最终导致 <code>27.625</code> 被替换为 <code>27.62</code></p></li></ol></li><li><p>在<strong>只有一条可能的匹配路径时</strong>，使用<em>贪婪</em>和<em>懒惰</em>量词的正则表达式对结果无影响,只是因其尝试路径的次序不同，引擎尝试匹配的次数不同，即<strong>效率不同</strong>。</p></li></ul><h1 id="固化分组"><a href="#固化分组" class="headerlink" title="固化分组"></a>固化分组</h1><ul><li>在固化分组「<code>(?&gt;……)</code>」匹配结束时，它已经匹配的文本已经固化为一个单元，只能作为整体而保留或放弃。回溯永远也不能选择其中的状态。举个例子：「<code>(\.\d\d(?&gt;[1-9]?))\d+</code>」中固化分组「<code>(?&gt;[1-9]?)</code>」使得 <code>.625</code> 末尾的 5 会遭遇 「<code>[1-9]?</code>」的固化匹配，然后再「<code>\d+</code>」需要回溯时匹配失败，从而导致 <code>.625</code> 整个文本匹配失败，从而不被处理，提升执行效率。</li><li>贪婪和懒惰影响检测顺序，固化分组影响备用状态（面包屑）的取舍。</li><li>[<code>(?&gt;.*?)</code>」是一个相当复杂的正则表达式，它永远无法匹配任何字符。「<code>.*?</code>」是「<code>.*</code>」的忽略优先（懒惰）表示，它限定的是一个点号，所以首选的分支是忽略点号，把匹配点号的状态保留下来备用。但该备用状态马上又会因为匹配退出了固化分组而被放弃。</li><li>「<code>^\w+:</code>」无法匹配 <code>Subject</code>，但正则表达式必须从末尾依次向前尝试匹配各种备用状态后才能得出匹配失败的结论。使用固化分组正则表达式「<code>^(?&gt;\w+):</code>」将在尝试「<code>:</code>」匹配失败后直接抛弃固化分组内容「<code>\w+</code>」，即只需尝试 1 次匹配便得出匹配失败结论。<strong>大大提高匹配效率。</strong></li></ul><h1 id="环视"><a href="#环视" class="headerlink" title="环视"></a>环视</h1><ul><li>环视结构的匹配尝试结束，它就不会留下任何备用状态。</li><li>在肯定环视中使用捕获括号，就能模拟实现固化分组和占有优先量词。「<code>(?&gt;regex)</code>」可以用「<code>(?=(regex))\1</code>」来模拟。举个栗子：<ul><li>「<code>(?&gt;\w+):</code>」为固化分组表达式</li><li>「<code>^(?=(\w+))\1:</code>」为环视表达式，环视中的「<code>\w+</code>」是贪婪匹配的，匹配整个单词。当环视结束之后，备用状态都会被放弃(和固化分组一样)。但与固化分组不同：虽然此时捕获了单词，但它不是全局匹配的一部分。「<code>\1</code>」的使用是为了把匹配从这个单词结束的位置进行下去。</li></ul></li></ul><h1 id="多选结构"><a href="#多选结构" class="headerlink" title="多选结构"></a>多选结构</h1><ul><li>对 NFA 来说，多选结构既<strong>不是匹配优先的</strong>，也<strong>不是忽略优先的</strong>，而是<strong>按顺序排列</strong>的。</li><li>对 DFA 来说，多选结构匹配所有多选分支中能匹配最多文本的那个。</li><li>如果多选分支是<strong>按顺序排列</strong>的。，而能够匹配同样文本的多选分支又<strong>不只一个</strong>，就要小心安排多选分支的<strong>先后顺序</strong>。</li></ul><p>文本：<code>Jan 31 is Dad&#39;s birthday</code><br>期望：<code>Jan 31</code></p><ol><li><p>RegEx：<code>Jan (0?[1-9]|[12][0-9]|3[01])</code><br>结果：<code>Jan 3</code><br>释义：「<code>0?</code>」不会匹配成功，但后续的「<code>[0-9]</code>」会匹配 <code>3</code>，此时完成所有匹配需求，故匹配成功。</p></li><li><p>RegEx：<code>Jan ([12][0-9]|3[01]|0?[1-9])</code><br>RegEx：<code>Jan (31|[123]0|[012?[1-9]])</code><br>结果：<code>Jan 31</code><br>释义：上述两个 RegeEx 的多选结构顺序保证了匹配的内容与期望相符</p></li><li><p>RegEx：<code>Jan (0[1-9]|[12][0-9]?|3[01]?|[4-9])</code><br>结果：<code>Jan 31</code><br>释义：上述多选结构不受内部多选分支的顺序影响，均可匹配成功</p></li></ol><h1 id="NFA、DFA-和-POSIX"><a href="#NFA、DFA-和-POSIX" class="headerlink" title="NFA、DFA 和 POSIX"></a>NFA、DFA 和 POSIX</h1><p>NFA 和 DFA 引擎理应匹配相同文本，提供相同功能。但在实际中，因为人们需要更强的功能，更具表达能力的正则表达式，它们各自的表达式语意（解析方式）发生了变化。</p><h2 id="最左最长规则"><a href="#最左最长规则" class="headerlink" title="最左最长规则"></a>最左最长规则</h2><ul><li>如果传动装置在文本的某个特定位置启动 DFA 引擎，而在此位置又有一个或多个匹配的可能，DFA 就会选择这些可能中最长的。</li><li>POSIX 标准规定，如果在字符串的某个位置存在多个可能的匹配，应当返回的是最长的匹配。</li></ul><h2 id="速度和效率"><a href="#速度和效率" class="headerlink" title="速度和效率"></a>速度和效率</h2><ul><li>POSIX NFA 需要进行更多的回溯，尝试正则表达式的所有变体。所以表达式的差异会极大影响其匹配的效率。</li><li>DFA 引擎用更多时间和空间来换取匹配效率。</li></ul><table><thead><tr><th></th><th>DFA</th><th>NFA</th></tr></thead><tbody><tr><td>预编译阶段</td><td>优化措施的效果更好</td><td>编译更快，所需内存更少</td></tr><tr><td>匹配速度</td><td>与表达式无关</td><td>与表达式有关</td></tr><tr><td>匹配速度</td><td></td><td>NFA 尝试表达式的所有变体后才报告匹配失败，POSIX NFA 尝试匹配最长文本</td></tr><tr><td>匹配结果</td><td>返回最左最长文本</td><td>NFA 返回最左最长文本 / 其他文本</td></tr><tr><td>匹配能力</td><td></td><td>1. 支持捕获括号内的子表达式的文本（eg. 反向引用 / 后匹配信息）</td></tr><tr><td>匹配能力</td><td></td><td>2. 支持环视和其他零长度确认</td></tr><tr><td>匹配能力</td><td></td><td>3. 支持懒惰量词和多选结构</td></tr><tr><td>匹配能力</td><td></td><td>4. 支持贪婪量词和固化分子</td></tr><tr><td>实现难度</td><td></td><td>实现简单</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-1/&quot;&gt;《精通正则表达式》学习笔记（一）&lt;/a&gt;&lt;br&gt;Ch.1 正则表达式入门&lt;br&gt;Ch.2 入门示例拓展&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-2/&quot;&gt;《精通正则表达式》学习笔记（二）&lt;/a&gt;&lt;br&gt;Ch.3 正则表达式的特性和流派概览&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-3/&quot;&gt;《精通正则表达式》学习笔记（三）&lt;/a&gt;&lt;br&gt;Ch.4 表达式的匹配原理&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-4/&quot;&gt;《精通正则表达式》学习笔记（四）&lt;/a&gt;&lt;br&gt;Ch.5 正则表达式实用技巧&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-5/&quot;&gt;《精通正则表达式》学习笔记（五）&lt;/a&gt;&lt;br&gt;Ch.6 打造高效正则表达式&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-6/&quot;&gt;《精通正则表达式》学习笔记（六）&lt;/a&gt;&lt;br&gt;Ch.10 PHP 相关的正则表达式&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&quot;正则引擎的分类&quot;&gt;&lt;a href=&quot;#正则引擎的分类&quot; class=&quot;headerlink&quot; title=&quot;正则引擎的分类&quot;&gt;&lt;/a&gt;正则引擎的分类&lt;/h1&gt;&lt;p&gt;正则引擎主要分为 3 类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DFA（符合或不符合 POSIX 标准的都属此类）&lt;/li&gt;
&lt;li&gt;传统型 NFA&lt;/li&gt;
&lt;li&gt;POSIX NFA&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;引擎类型&lt;/th&gt;
&lt;th&gt;程序&lt;/th&gt;
&lt;th&gt;忽略优先量词（懒惰）&lt;/th&gt;
&lt;th&gt;捕获型括号&lt;/th&gt;
&lt;th&gt;回溯&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;DFA&lt;/td&gt;
&lt;td&gt;&lt;code&gt;awk&lt;/code&gt;（大多数版本）、&lt;code&gt;egrep&lt;/code&gt;（大多数版本）、&lt;code&gt;flex&lt;/code&gt;、&lt;code&gt;lex&lt;/code&gt;、MySQL、Procmail&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;传统型 NFA&lt;/td&gt;
&lt;td&gt;GNU Emacs、Java、&lt;code&gt;grep&lt;/code&gt;（大多数版本）、&lt;code&gt;less&lt;/code&gt;、&lt;code&gt;more&lt;/code&gt;、.NET 语言、PCRE library、Perl、PHP（所有三套正则库）、Python、Ruby、sed（大多数版本）、&lt;code&gt;vi&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持，但性能差&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;POSIX NFA&lt;/td&gt;
&lt;td&gt;&lt;code&gt;mawk&lt;/code&gt;、Mortice Kern Systems’utilities、GNU Emacs（明确指定时使用）&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持，但性能差&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DFA/NFA 混合&lt;/td&gt;
&lt;td&gt;GNU &lt;code&gt;awk&lt;/code&gt;、GNU &lt;code&gt;grep/egrep&lt;/code&gt;、Tcl&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;DFA 支持&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;判断是否传统型 NFA：是否支持忽略优先量词（懒惰）。使用正则表达式 &lt;code&gt;nfa|nfa not&lt;/code&gt; 来匹配字符串 &lt;code&gt;nfa not&lt;/code&gt;，如果只匹配了 &lt;code&gt;nfa&lt;/code&gt;，这就是传统型 NFA。如果整个 &lt;code&gt;nfa not&lt;/code&gt; 都能匹配，则此引擎要么是 POSIXNFA，要么是 DFA。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://acuario.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="RegEx" scheme="https://acuario.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/RegEx/"/>
    
    
      <category term="学习笔记" scheme="https://acuario.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="精通正则表达式" scheme="https://acuario.xyz/tags/%E7%B2%BE%E9%80%9A%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="RegEx" scheme="https://acuario.xyz/tags/RegEx/"/>
    
      <category term="正则引擎" scheme="https://acuario.xyz/tags/%E6%AD%A3%E5%88%99%E5%BC%95%E6%93%8E/"/>
    
      <category term="NFA" scheme="https://acuario.xyz/tags/NFA/"/>
    
      <category term="DFA" scheme="https://acuario.xyz/tags/DFA/"/>
    
      <category term="POSIX NFA" scheme="https://acuario.xyz/tags/POSIX-NFA/"/>
    
  </entry>
  
  <entry>
    <title>播客札记（三）</title>
    <link href="https://acuario.xyz/podcast-note-3/"/>
    <id>https://acuario.xyz/podcast-note-3/</id>
    <published>2019-06-07T05:04:59.000Z</published>
    <updated>2019-08-22T16:21:39.086Z</updated>
    
    <content type="html"><![CDATA[<h1 id="八分-第-80-期-剧透的思考练习：言论自由还是道德错误？"><a href="#八分-第-80-期-剧透的思考练习：言论自由还是道德错误？" class="headerlink" title="八分 第 80 期 | 剧透的思考练习：言论自由还是道德错误？"></a>八分 第 80 期 | 剧透的思考练习：言论自由还是道德错误？</h1><p><a href="https://overcast.fm/+Oh0W-o4Pc" target="_blank" rel="noopener">Episode Archive</a></p><ul><li>剧透的伦理学基础：功利主义（效用主义）。</li><li>功利主义含义：所谓最大善的计算则必须依靠此行为所涉及的每个个体之苦乐感觉的总和，其中每个个体都被视为具相同分量，且快乐与痛苦是能够换算的，痛苦仅是 “负的快乐”。判断一件事的好坏，依据就是其是否增进人类最大的善，即增加人类的总体快乐。</li><li>剧透带来的双成伤害：<ol><li>剧透减少了观影的悬疑性，破坏了观影过程的乐趣；</li><li>剧透破坏了观影前对影视作品的期待与喜悦。</li></ol></li><li>剧透的言论自由基础：卡尔·波普尔在《开放社会及其敌人》中提出的「宽容悖论」。</li><li><p>宽容悖论：</p><blockquote><p>无限的宽容必然导致宽容的消失。如果我们把无限的宽容延伸到那些不宽容的人身上，如果我们不准备捍卫宽容社会以抵抗不宽容的冲击，那么宽容将被摧毁，并且我们还将容忍他们。</p></blockquote></li><li><p>穆勒认为，除非某个人的言论或行为伤害（肉体或利益受损）而非冒犯（情绪、尊严受损）到一个人，否则其言论或行为不应被任何力量禁止。</p></li><li>剧透是否是对肉体和精神的真实伤害？还是仅仅只是一种冒犯？</li><li>剧透与权利的关系：如果剧透者是创作者本人，其是否有权剧透？这一剧透行为是否有合理性？</li><li>剧透与历史的关系：历史作品是否可以剧透？</li><li>真正伟大的作品不惧怕剧透。类型文学 / 作品是不可被剧透的。</li><li>剧透的另一种观赏乐趣：心平气和地感受作品的细节。</li><li>互联网的出现为剧透文化带来的改变：电影预告片即是对剧透文化的利用。</li><li>希区柯克的《惊魂记》告诫观众请勿剧透，助长了影片本身的神秘性。</li></ul><a id="more"></a><hr><h1 id="翻电-Special-VOL02-如何看待外卖行业和我们的责任？"><a href="#翻电-Special-VOL02-如何看待外卖行业和我们的责任？" class="headerlink" title="翻电 Special VOL02 | 如何看待外卖行业和我们的责任？"></a>翻电 Special VOL02 | 如何看待外卖行业和我们的责任？</h1><p><a href="https://overcast.fm/+GsFhie5AY" target="_blank" rel="noopener">Episode Archive</a></p><h2 id="劳动异化理论"><a href="#劳动异化理论" class="headerlink" title="劳动异化理论"></a>劳动异化理论</h2><ul><li>劳动者是否掌握生产资料</li><li>如果劳动者被劳动以外的要素强迫，且劳动目的不属于自己、劳动对象不是自己，则该劳动过程将出现劳动异化</li></ul><h2 id="外卖工作为何是劳动异化的极端"><a href="#外卖工作为何是劳动异化的极端" class="headerlink" title="外卖工作为何是劳动异化的极端"></a>外卖工作为何是劳动异化的极端</h2><p>现代社会普遍存在劳动异化，外卖是劳动异化的极端例子：</p><ol><li>外卖的工作空间为社会飞地，工作时没有任何主要（固定）的社会空间，完全游离于世界之外；</li><li>外卖者对外交流的对象并不固定，且人际交流时间非常短暂。相比之下，出租车司机与乘客也有相对长时间的共处；</li><li>外卖工作不掌握任何生产资料，在社会生产链条中一无所有，没有任何生产实践。相比之下，风投工作亦是如此；</li><li>外卖工作不具备任何工作经验、技能的积累，纵使有产生了经验、技能，也很难复用到其他工作。</li></ol><h2 id="为何作为一个工作，外卖依然有伦理风险"><a href="#为何作为一个工作，外卖依然有伦理风险" class="headerlink" title="为何作为一个工作，外卖依然有伦理风险"></a>为何作为一个工作，外卖依然有伦理风险</h2><ul><li>社会底线不是维持社会成为一个好社会的标准，而是维持社会不崩溃的标准</li><li>外卖工作虽没有触及社会底线，但却是劳动异化最极端的状态。</li><li>「谁雇佣谁负责 / 谁施行谁负责」是缺乏说服力的，由自我需求产生的特定现实需要需求方承担社会责任。反例为儿童色情 / 毒品问题。</li></ul><h2 id="为何我们不是雇佣者也应该关注外卖"><a href="#为何我们不是雇佣者也应该关注外卖" class="headerlink" title="为何我们不是雇佣者也应该关注外卖"></a>为何我们不是雇佣者也应该关注外卖</h2><ul><li>外卖需求建立在手机、互联网之上。消费者为了避免与人交流，产生了这样「过度的」需求，这样的需求是商品社会「方便主义」至上的后果，它把心理负担和成本转嫁到外卖者身上。没有买卖就没有伤害。</li><li>大众具有选择性的同理心。体谅和同理心的适用对象不应只限于特殊岗位，如公权力赋权的对象，比如消防员。</li><li>同理心的对象不应以利益绑定为标准。仅对利益共同体给与同理心是功利主义的，若长此以往，互助互利的社会风气将会逐渐消解。</li><li>由于存在实然和应然的问题，带着负罪感的作为至少比毫不反思和理解要好，尝试理解外卖工作的特殊性和其中存在的道德风险，胜过以方便主义理所应当享用外卖服务。</li></ul><h2 id="问题反思"><a href="#问题反思" class="headerlink" title="问题反思"></a>问题反思</h2><p>主要的问题在于：</p><ol><li>要在多大程度上对马克思经济学的基本概念进行外延？</li><li>导致事情极端，不是一个因素的决定，而是多个因素的共同作用</li><li>劳动异化简而言之是：站在人的自身发展、自我意志的角度，来看待人与工作的关系。异化程度越高，对人本身的发展越不利。其他方面按下不表，因为前述论点足够进行话题讨论。</li></ol><p>反思结论如下：</p><ol><li>劳动异化这个概念，是对资本主义框架的一种解释。在讨论成熟的商业行为时，我们不妨先用该理论作为基础进行分析，当然也可以有其他理论的探讨。</li><li>现代性中很重要的一点就是时间和空间的概念与古时不同，城市的出现本就是一个以空间作为明显标志的产物。所以工作空间的固定对劳动者本身的劳动异化是有弱化作用的，这一点对城市内的从业者更加明显。</li><li>工作的技能经验在此可以理解为对某一工作本身熟悉度的掌握，对外卖行业而言这一点无从谈起。更加熟悉路况、地形，然后应用到出租车行业？除此之外的积累又有几多？出租车行业本身在其他几点上的情况也极其糟糕，劳动异化程度也不低。</li><li>对前述论点举特例无非是五十步笑一百步，劳动异化是多因素的共同作用，而非某一单一因素，恰恰只有外卖行业在前述劳动异化的极端性 (1)(2)(3)(4) 点上均有涉及，且程度不小，所以才可以讨论其职业道德风险的问题。而其他例子总能因某一因素的缺失而削弱其劳动异化程度。比如程序员寡言、风投行业不掌握生产资料，但其获得的回报（物质、心理、社会层面）在一定程度上能够弥补劳动异化带来的损失（物质 &amp; 精神层面）。</li><li>「方便无罪」让我想到「技术无罪」论，手机和互联网的出现在社会层面的积极作用当然不用多说，但如果基于功利主义来讨论「外卖是否更利于人与人的交流」的话，笔者认为答案是否定的。而且笔者也不认为「方便」在多大程度上促进了外卖从业者自我人格的发展。倒是在消费者口中助长了工具理性的态度。我们现在反对和反思的不恰恰就是工具理性的消费主义吗？</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;八分-第-80-期-剧透的思考练习：言论自由还是道德错误？&quot;&gt;&lt;a href=&quot;#八分-第-80-期-剧透的思考练习：言论自由还是道德错误？&quot; class=&quot;headerlink&quot; title=&quot;八分 第 80 期 | 剧透的思考练习：言论自由还是道德错误？&quot;&gt;&lt;/a&gt;八分 第 80 期 | 剧透的思考练习：言论自由还是道德错误？&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://overcast.fm/+Oh0W-o4Pc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Episode Archive&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;剧透的伦理学基础：功利主义（效用主义）。&lt;/li&gt;
&lt;li&gt;功利主义含义：所谓最大善的计算则必须依靠此行为所涉及的每个个体之苦乐感觉的总和，其中每个个体都被视为具相同分量，且快乐与痛苦是能够换算的，痛苦仅是 “负的快乐”。判断一件事的好坏，依据就是其是否增进人类最大的善，即增加人类的总体快乐。&lt;/li&gt;
&lt;li&gt;剧透带来的双成伤害：&lt;ol&gt;
&lt;li&gt;剧透减少了观影的悬疑性，破坏了观影过程的乐趣；&lt;/li&gt;
&lt;li&gt;剧透破坏了观影前对影视作品的期待与喜悦。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;剧透的言论自由基础：卡尔·波普尔在《开放社会及其敌人》中提出的「宽容悖论」。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;宽容悖论：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;无限的宽容必然导致宽容的消失。如果我们把无限的宽容延伸到那些不宽容的人身上，如果我们不准备捍卫宽容社会以抵抗不宽容的冲击，那么宽容将被摧毁，并且我们还将容忍他们。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;穆勒认为，除非某个人的言论或行为伤害（肉体或利益受损）而非冒犯（情绪、尊严受损）到一个人，否则其言论或行为不应被任何力量禁止。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;剧透是否是对肉体和精神的真实伤害？还是仅仅只是一种冒犯？&lt;/li&gt;
&lt;li&gt;剧透与权利的关系：如果剧透者是创作者本人，其是否有权剧透？这一剧透行为是否有合理性？&lt;/li&gt;
&lt;li&gt;剧透与历史的关系：历史作品是否可以剧透？&lt;/li&gt;
&lt;li&gt;真正伟大的作品不惧怕剧透。类型文学 / 作品是不可被剧透的。&lt;/li&gt;
&lt;li&gt;剧透的另一种观赏乐趣：心平气和地感受作品的细节。&lt;/li&gt;
&lt;li&gt;互联网的出现为剧透文化带来的改变：电影预告片即是对剧透文化的利用。&lt;/li&gt;
&lt;li&gt;希区柯克的《惊魂记》告诫观众请勿剧透，助长了影片本身的神秘性。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="播客札记" scheme="https://acuario.xyz/categories/%E6%92%AD%E5%AE%A2%E6%9C%AD%E8%AE%B0/"/>
    
    
      <category term="Podcast" scheme="https://acuario.xyz/tags/Podcast/"/>
    
      <category term="播客" scheme="https://acuario.xyz/tags/%E6%92%AD%E5%AE%A2/"/>
    
      <category term="翻转电台" scheme="https://acuario.xyz/tags/%E7%BF%BB%E8%BD%AC%E7%94%B5%E5%8F%B0/"/>
    
      <category term="剧透" scheme="https://acuario.xyz/tags/%E5%89%A7%E9%80%8F/"/>
    
      <category term="言论自由" scheme="https://acuario.xyz/tags/%E8%A8%80%E8%AE%BA%E8%87%AA%E7%94%B1/"/>
    
      <category term="外卖" scheme="https://acuario.xyz/tags/%E5%A4%96%E5%8D%96/"/>
    
      <category term="功利主义" scheme="https://acuario.xyz/tags/%E5%8A%9F%E5%88%A9%E4%B8%BB%E4%B9%89/"/>
    
      <category term="劳动异化" scheme="https://acuario.xyz/tags/%E5%8A%B3%E5%8A%A8%E5%BC%82%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>《精通正则表达式》学习笔记（二）</title>
    <link href="https://acuario.xyz/mastering-regex-summary-2/"/>
    <id>https://acuario.xyz/mastering-regex-summary-2/</id>
    <published>2019-06-05T13:35:55.000Z</published>
    <updated>2019-08-11T15:24:03.854Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="/mastering-regex-summary-1/">《精通正则表达式》学习笔记（一）</a><br>Ch.1 正则表达式入门<br>Ch.2 入门示例拓展</li><li><a href="/mastering-regex-summary-2/">《精通正则表达式》学习笔记（二）</a><br>Ch.3 正则表达式的特性和流派概览</li><li><a href="/mastering-regex-summary-3/">《精通正则表达式》学习笔记（三）</a><br>Ch.4 表达式的匹配原理</li><li><a href="/mastering-regex-summary-4/">《精通正则表达式》学习笔记（四）</a><br>Ch.5 正则表达式实用技巧</li><li><a href="/mastering-regex-summary-5/">《精通正则表达式》学习笔记（五）</a><br>Ch.6 打造高效正则表达式</li><li><a href="/mastering-regex-summary-6/">《精通正则表达式》学习笔记（六）</a><br>Ch.10 PHP 相关的正则表达式</li></ul><hr><h1 id="正则表达式的发展历程"><a href="#正则表达式的发展历程" class="headerlink" title="正则表达式的发展历程"></a>正则表达式的发展历程</h1><ul><li><p>1968 年 Ken Thompson 的文章 Regular Expression Search Algorithm 描述了一种正则表达式编译器，该编译器生成了 IBM7094 的 object 代码。由此也诞生了他的 <code>qed</code>，这种编辑器后来成了 Unix 中 <code>ed</code> 编辑器的基础。</p></li><li><p><code>ed</code> 有条命令 <code>g/Regular Expression/p</code>，读作 <em>Gjobal Regular Expression，Print</em>（应用正则表达式的全局输出）。这个功能最终成为独立的工具 <code>grep</code>，之后又产生了 <code>egrep</code>(Extended grep)。</p><ul><li>POSIX（Portable Operating System Interface，可移植操作系统接口）诞生于 1986 年，它是一系列标准，确保操作系统之间的移植性。POSIX 把各种常见的流派分为两大类：<br>Basic Regular Expressions（BREs）和 Extended Regular Expressions（EREs）。POSIX 程序必须支持其中的任意一种。</li></ul></li></ul><p><img src="https://i.loli.net/2019/05/30/5cef9d6eddef290952.png" alt="POSIX 正则表达式流派"></p><ul><li><p>Perl 的特性中值得一提的是，它提供了传统上只有专用工具 <code>sed</code> 和 <code>awk</code> 才提供的正则表达式操作符——这在通用脚本语言中是个首创。正则引擎的代码来自一个早期的项目——Larry 的新闻阅读器 <code>rn</code>（其中的正则表达式代码来自 James Gosling 的 <code>Emacs</code>。（James Gosling 后来去开发他自己的语言 <code>Java</code>，Java 1.4 提供了一个标准的正则表达式包。）</p></li><li><p>1997 年 Philip Hazel 开发了 <code>PCRE</code>，这是一套兼容 Perl 正则表达式的库，全面仿制 Perl 的正则表达式的语法和语义。其他的开发人员可以把 PCRE 整合到自己的工具和语言中，许多流行的软件都使用了 PCRE，例如 <code>PHP</code>、<code>Apache 2</code>、<code>Exim</code>、<code>Postfix</code> 和 <code>Nmap</code>。</p><a id="more"></a></li></ul><h1 id="正则表达式的注意事项和处理方法"><a href="#正则表达式的注意事项和处理方法" class="headerlink" title="正则表达式的注意事项和处理方法"></a>正则表达式的注意事项和处理方法</h1><p><img src="https://i.loli.net/2019/06/03/5cf503b6304ca16665.png" alt="若干常用工具的 Flavor 的简要考察"></p><ul><li><p>一款工具软件能够利用正则表达式实现的功能，通常比它所属的正则流派更重要。</p></li><li><p>程序设计语言有 3 种处理正则表达式的方式：</p><ol><li>集成式（integrated）：直接内建在语言之中，如 Perl。</li><li>程序式（procedural）</li><li>面向对象式（object-oriented）</li></ol><ul><li>程序式和面向对象式，是由普通的函数接收普通的字符串，把它们作为正则表达式进行处理。由不同的函数进行不同的、关系到一个或多个正则表达式的操作。</li></ul></li></ul><h1 id="字符串、字符编码和匹配模式"><a href="#字符串、字符编码和匹配模式" class="headerlink" title="字符串、字符编码和匹配模式"></a>字符串、字符编码和匹配模式</h1><ul><li><p><code>Unicode</code> 是一组字符设定，或者是从数字和字符之间的逻辑映射的<strong>概念编码</strong>。一个 “代码点（code point）”，通常用十六进制来表示，以 “<code>U+</code>” 开头。</p></li><li><p>支持 Unicode 的程序中的正则表达式通常支持 <code>\unum</code> 元序列，用来匹配一个具体的 Unicode 字符。</p></li><li><p>Unicode Version 3.1 诞生于 2001 年中期，增加了 <code>u+FFFF</code> 之后的代码点。例如，代表音乐谱号 <code>C</code>（Clef）的字符对应代码点 <code>U+1D121</code>。之前那些仅支持低于 <code>U+FPPP</code> 字符的程序无法处理这种情况。大多数程序的 <code>\unum</code> 只能支持最多 4 位十六进制数值。</p></li><li><p>能够处理这类新字符的程序通常提供了 <code>\x{nuwm}</code> 序列，<code>num</code> 可以为任意多位数字（这是为了增强只支持 4 位数字的 <code>\unum</code> 表示法）。你可以使用 <code>\x{1D121}</code> 来匹配这类 “谱号 <code>C</code>” 之类的字符。</p></li><li><p>正则模式和匹配模式</p><ul><li>不区分大小写的匹配模式：在匹配过程中会忽略字母的大小写。</li><li>宽松排列和注释模式：忽略字符组外部的所有空白字符。字符组内部的空白字符仍然有效，<code>#</code> 符号和换行符之间的内容视为注释。</li><li>点号通配模式（dot-match-all match mode，也叫 single-line mode “单行模式 “）：点号不受限制，可以匹配任何字符，包括换行符。修改了点号处理换行符的方式，从 “需要特殊处理” 变为 “不需要特殊处理”</li><li>增强的行锚点模式（Enhanced line-anchor match mode，也叫 “多行文本模式 “）：「<code>^</code>」能够匹配字符串中内嵌的文本行的开头位置，「<code>$</code>」能够匹配字符串中内嵌的文本行的换行符。改变了「<code>^</code>」和「<code>$</code>」匹配换行符的方式，从 “不需要特殊处理” 变为 “需要特殊处理”。</li><li>文字文本模式：几乎不识别任何正则表达式元字符。</li></ul></li></ul><h1 id="常用的元字符和特性"><a href="#常用的元字符和特性" class="headerlink" title="常用的元字符和特性"></a>常用的元字符和特性</h1><ul><li><p>字符表示法</p><ul><li>字符缩略表示法：<code>\n</code>、<code>\t</code>、<code>\a</code>、<code>\b</code>、<code>\e</code>、<code>\f</code>、<code>\r</code>、<code>\v</code>…</li><li>八进制转义：<code>\num</code></li><li>十六进制 /Unicode 转义：<code>\xnum</code>、<code>\x{num}</code>、<code>\unum</code>、<code>\Unum</code>…</li><li>控制字符：<code>\cchar</code></li></ul></li><li><p>字符组及相关结构</p><ul><li>普通字符组：<code>[a-z]</code> 和 <code>[*a-z]</code></li><li>几乎能匹配任何字符的元字符：点号</li><li>单个字节：<code>\C</code></li><li>Unicode 组合字符序列：<code>\X</code></li><li>字符组缩略表示法：<code>\w</code>、<code>\d</code>、<code>\s</code>、<code>\W</code>、<code>\D</code>、<code>\S</code></li><li>Unicode 属性、区块和分类：<code>\p{Prop}</code>、<code>\P{Prop}</code></li><li>字符组运算符：<code>[[a-z]&amp;&amp;[^aeiou]]</code></li></ul></li><li><p>锚点及其他 “零长度断言”</p><ul><li>行 / 字符串起点：<code>^</code>、<code>\A</code></li><li>行 / 字符串终点：<code>$</code>、<code>\Z</code>、<code>\z</code></li><li>本次匹配的开始位置（或者上次匹配的结束位置）：<code>\G</code></li><li>单词分界符：<code>\b</code>、<code>\B</code>、<code>\&lt;</code>、<code>\&gt;</code>…</li><li>顺序环视 <code>(?=…)</code>、<code>(?!…)</code>；</li><li>逆序环视 <code>(?&lt;=…)</code>、<code>(?&lt;!…)</code></li></ul></li><li><p>注释和模式修饰词</p><ul><li>模式修饰词：<code>(?modifier)</code>，例如 <code>(?i)</code> 或 <code>(?-i)</code></li><li>模式作用范围：<code>(?modifier:…)</code>，例如 <code>(?i:…)</code></li><li>注释：<code>(?#…)</code> 和 <code>#…</code></li><li>文字文本范围：<code>\Q…\E</code></li></ul></li><li><p>分组，捕获，条件判断和控制：</p><ul><li>捕获 / 分组括号：<code>(…)</code>、<code>\1</code>、<code>\2</code>，…</li><li>仅用于分组的括号：<code>(?:…)</code></li><li>命名捕获：<code>(?&lt;Name&gt;…)</code></li><li>固化分组：<code>(?&gt;…)</code> 永远也不会 “交还” 分组内已经匹配的任何内容。</li><li>多选结构：<code>…|…|…</code></li><li>条件判断：<code>(?if then|else)</code></li><li>匹配优先量词：<code>*</code>、<code>+</code>、<code>?</code>、<code>{num，num}</code> 贪心（greedy）模式，<strong>默认的</strong>量词匹配模式，匹配尽可能多的内容。</li><li>忽略优先量词：<code>*?</code>、<code>+?</code>、<code>??</code>、<code>{num，num)?</code> 懒惰模式，匹配尽可能少的内容，只需要满足下限，匹配就能成功。</li><li>占有优先量词：<code>*+</code>、<code>++</code>、<code>?+</code>、<code>{nuwm，nuwm}+</code> 类似固化分组，一旦匹配某些内容，就不会“交还”。</li></ul></li><li><p>固化分组就是一个<strong>只进不出</strong>的栈，被匹配入栈的内容不会交还，这导致若匹配了更多无关内容，将导致匹配失败（因为之前的匹配无法交还），最终的匹配结果将为空。例如：<code>!.+!</code> 可以匹配 <code>!Hola!</code>，但 <code>!(?&gt;.+)!</code> 无法匹配 <code>!Hola!</code>。其首先匹配尽可能多的内容 <code>Hola!</code>，但是之后的 <code>!</code> 无法匹配，会强迫 <code>.+</code> 释放之前匹配的 <code>!</code>，但固化分组无法释放，最终导致匹配失败。</p></li><li><p>所有的正则引擎都不会对单词进行语意分析：它们认为 “NE14AD8” 是一个单词，而 “M.I.T.” 不是。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-1/&quot;&gt;《精通正则表达式》学习笔记（一）&lt;/a&gt;&lt;br&gt;Ch.1 正则表达式入门&lt;br&gt;Ch.2 入门示例拓展&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-2/&quot;&gt;《精通正则表达式》学习笔记（二）&lt;/a&gt;&lt;br&gt;Ch.3 正则表达式的特性和流派概览&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-3/&quot;&gt;《精通正则表达式》学习笔记（三）&lt;/a&gt;&lt;br&gt;Ch.4 表达式的匹配原理&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-4/&quot;&gt;《精通正则表达式》学习笔记（四）&lt;/a&gt;&lt;br&gt;Ch.5 正则表达式实用技巧&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-5/&quot;&gt;《精通正则表达式》学习笔记（五）&lt;/a&gt;&lt;br&gt;Ch.6 打造高效正则表达式&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-6/&quot;&gt;《精通正则表达式》学习笔记（六）&lt;/a&gt;&lt;br&gt;Ch.10 PHP 相关的正则表达式&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&quot;正则表达式的发展历程&quot;&gt;&lt;a href=&quot;#正则表达式的发展历程&quot; class=&quot;headerlink&quot; title=&quot;正则表达式的发展历程&quot;&gt;&lt;/a&gt;正则表达式的发展历程&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1968 年 Ken Thompson 的文章 Regular Expression Search Algorithm 描述了一种正则表达式编译器，该编译器生成了 IBM7094 的 object 代码。由此也诞生了他的 &lt;code&gt;qed&lt;/code&gt;，这种编辑器后来成了 Unix 中 &lt;code&gt;ed&lt;/code&gt; 编辑器的基础。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;ed&lt;/code&gt; 有条命令 &lt;code&gt;g/Regular Expression/p&lt;/code&gt;，读作 &lt;em&gt;Gjobal Regular Expression，Print&lt;/em&gt;（应用正则表达式的全局输出）。这个功能最终成为独立的工具 &lt;code&gt;grep&lt;/code&gt;，之后又产生了 &lt;code&gt;egrep&lt;/code&gt;(Extended grep)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;POSIX（Portable Operating System Interface，可移植操作系统接口）诞生于 1986 年，它是一系列标准，确保操作系统之间的移植性。POSIX 把各种常见的流派分为两大类：&lt;br&gt;Basic Regular Expressions（BREs）和 Extended Regular Expressions（EREs）。POSIX 程序必须支持其中的任意一种。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/05/30/5cef9d6eddef290952.png&quot; alt=&quot;POSIX 正则表达式流派&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Perl 的特性中值得一提的是，它提供了传统上只有专用工具 &lt;code&gt;sed&lt;/code&gt; 和 &lt;code&gt;awk&lt;/code&gt; 才提供的正则表达式操作符——这在通用脚本语言中是个首创。正则引擎的代码来自一个早期的项目——Larry 的新闻阅读器 &lt;code&gt;rn&lt;/code&gt;（其中的正则表达式代码来自 James Gosling 的 &lt;code&gt;Emacs&lt;/code&gt;。（James Gosling 后来去开发他自己的语言 &lt;code&gt;Java&lt;/code&gt;，Java 1.4 提供了一个标准的正则表达式包。）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;1997 年 Philip Hazel 开发了 &lt;code&gt;PCRE&lt;/code&gt;，这是一套兼容 Perl 正则表达式的库，全面仿制 Perl 的正则表达式的语法和语义。其他的开发人员可以把 PCRE 整合到自己的工具和语言中，许多流行的软件都使用了 PCRE，例如 &lt;code&gt;PHP&lt;/code&gt;、&lt;code&gt;Apache 2&lt;/code&gt;、&lt;code&gt;Exim&lt;/code&gt;、&lt;code&gt;Postfix&lt;/code&gt; 和 &lt;code&gt;Nmap&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://acuario.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="RegEx" scheme="https://acuario.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/RegEx/"/>
    
    
      <category term="学习笔记" scheme="https://acuario.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="精通正则表达式" scheme="https://acuario.xyz/tags/%E7%B2%BE%E9%80%9A%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="RegEx" scheme="https://acuario.xyz/tags/RegEx/"/>
    
      <category term="正则流派" scheme="https://acuario.xyz/tags/%E6%AD%A3%E5%88%99%E6%B5%81%E6%B4%BE/"/>
    
      <category term="正则特性" scheme="https://acuario.xyz/tags/%E6%AD%A3%E5%88%99%E7%89%B9%E6%80%A7/"/>
    
      <category term="正则元字符" scheme="https://acuario.xyz/tags/%E6%AD%A3%E5%88%99%E5%85%83%E5%AD%97%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>如何加固Linux服务器[译]</title>
    <link href="https://acuario.xyz/how-to-secure-your-linux-server/"/>
    <id>https://acuario.xyz/how-to-secure-your-linux-server/</id>
    <published>2019-04-27T08:54:32.000Z</published>
    <updated>2019-04-29T14:53:29.810Z</updated>
    
    <content type="html"><![CDATA[<p><em>原文 <a href="https://medium.com/servers-101/how-to-secure-your-linux-server-6026cfcdefd8" target="_blank" rel="noopener">How To Secure Your Linux Server In 7 Easy Steps</a> 由 <a href="https://medium.com/@mutendebrian" target="_blank" rel="noopener">Brian Mutende</a> 发布于 Medium，翻译转载已获作者允许。<br>为配合博客目录系统显示，对原文章节名略有修改。</em></p><hr><p>大多数服务器经常会被黑客攻击。所以我决定写一篇简短的教程，让读者轻松加固自己的 Linux 服务器。</p><p>这并不是一篇完整的安全指南，但是它可以帮你阻断近九成常见的后端攻击，例如<strong>暴力破解</strong>和 <strong>DDoS</strong>。</p><p>最棒的是，你可以在一两个小时内就完成操作。</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ol><li>你需要一台Linux服务器。</li><li>你需要对命令行有基本的了解。<a href="https://learncodethehardway.org/unix/bash_cheat_sheet.pdf" target="_blank" rel="noopener">这里</a>提供一份 cheet sheet 供你使用。</li></ol><p>如果你已万事俱备，那就开始吧。</p><a id="more"></a><h1 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h1><h2 id="配置-SSH-密钥"><a href="#配置-SSH-密钥" class="headerlink" title="配置 SSH 密钥"></a>配置 SSH 密钥</h2><p>要访问远程服务器，你务必使用 SSH 密钥登录而不是使用密码登录。</p><p>密码登录的问题在于其很容易被暴力破解（你将在下文学到如何进一步防止这种情况）。另外，在每次访问服务器时，你都必须输入密码。为避免上述缺点，你必须设置 <strong>SSH 密钥验证</strong>。它比使用密码更安全，因为黑客无法将其暴力破解。除此以外，使用密钥也可以更方便和快速地连接服务器，而无需输入密码。</p><p>下面介绍如何为服务器设置 SSH 身份验证。</p><ul><li><p>在本地计算机上，运行下列命令生成 SSH 密钥对：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure><p>上述命令将引导你在几步之内生成 SSH 密钥。当然别忘了记住你保存密钥文件的位置。</p></li><li><p>使用以下命令将公钥添加到服务器：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-copy-id username@remote_host</span><br></pre></td></tr></table></figure><p>务必使用你的用户名和服务器的 IP 地址替换 <em>username</em> 和 <em>remote_host</em>。系统将提示你输入密码。</p></li><li><p>尝试使用以下命令登录服务器：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh username@remote_host</span><br></pre></td></tr></table></figure><p>别忘了将 <em>username</em> 和 <em>remote_host</em> 替换为服务器的详细信息。这时你会注意到，本次登录不再提示你输入密码。</p></li></ul><h2 id="保持系统时间最新"><a href="#保持系统时间最新" class="headerlink" title="保持系统时间最新"></a>保持系统时间最新</h2><p>许多安全协议依托于你的系统时间来执行定时任务，生成当天的日志和执行其他关键任务。</p><p>如果你的系统时间有误，可能会对你的服务器造成危害。为防止这种情况发生，你可以安装 NTP 客户端。该程序将使你的系统时间与全球 NTP 服务器保持同步。</p><p>安装 NTP 客户端命令如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install ntp</span><br></pre></td></tr></table></figure><p>之后你再也不用担心设置系统日期。</p><h2 id="查看活动端口"><a href="#查看活动端口" class="headerlink" title="查看活动端口"></a>查看活动端口</h2><p>服务器程序会暴露某些端口，以便于网络中的其他应用程序对其进行访问。黑客也可以在你的服务器上安装后门并暴露端口，从而控制你的服务器。因此，我们不希望服务器上的未知端口被请求侦听。</p><p>要查看活动端口，可以使用以下命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ss -lntup</span><br></pre></td></tr></table></figure><p>查看输出并检查任何你并不熟悉的端口或进程。尝试发现并追踪可能有害的服务和流程。如果你不知从何下手，请可以查看这份<a href="https://www.garykessler.net/library/bad_ports.html" target="_blank" rel="noopener">《「糟糕的」TCP/UDP 端口列表》</a>。</p><h2 id="设置防火墙"><a href="#设置防火墙" class="headerlink" title="设置防火墙"></a>设置防火墙</h2><p>防火墙允许你控制服务器上传入 / 传出特定端口的网络流量。通常我使用 UFW（<em>uncomplicated firewall</em>，简单防火墙）。（译者注：UFW 是 Ubuntu 系统上默认的防火墙组件）</p><p>你可以配置下述规则来控制 UFW 的运行：</p><ul><li>允许 / 禁止</li><li>传入流量 / 传出流量</li><li>流量目的地 / 流量源</li><li>特定端口 / 所有端口</li></ul><p>完成下面的例子，你将阻止白名单之外的所有网络流量。如果之后安装了其他程序，别忘了将运行所需的必要端口加入白名单。</p><h3 id="设置-UFW"><a href="#设置-UFW" class="headerlink" title="设置 UFW"></a>设置 UFW</h3><ul><li>安装ufw。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ufw</span><br></pre></td></tr></table></figure><ul><li>你可以禁止所有传出流量</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ufw default deny outgoing comment &apos;deny all outgoing traffic&apos;</span><br></pre></td></tr></table></figure><ul><li>或者允许所有传出流量</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ufw default allow outgoing comment &apos;allow all outgoing traffic&apos;</span><br></pre></td></tr></table></figure><ul><li>接下来，我们要禁止所有传入的流量……</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ufw default deny incoming comment &apos;deny all incoming traffic&apos;</span><br></pre></td></tr></table></figure><ul><li>…将 SSH 连接加入例外，以便访问系统。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ufw limit in ssh comment &apos;allow SSH connections in&apos;</span><br></pre></td></tr></table></figure><ul><li>如果你将 UFW 配置为禁止所有传出流量，别忘了根据需要允许特定流量。比如：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#允许端口 53 的流量输出 -  DNS </span><br><span class="line">sudo ufw allow out 53 comment &apos;allow DNS calls out&apos;</span><br><span class="line"></span><br><span class="line">#允许端口 123 的流量输出 -  NTP </span><br><span class="line">sudo ufw allow out 123 comment &apos;allow NTP out&apos;</span><br><span class="line"></span><br><span class="line">#允许 HTTP，HTTPS 或 FTP 的流量</span><br><span class="line">#根据你使用的 apt 源的不同，apt 可能需要如下设置</span><br><span class="line">sudo ufw allow out http comment &apos;allow HTTP traffic out&apos;</span><br><span class="line">sudo ufw allow out https comment &apos;allow HTTPS traffic out&apos;</span><br><span class="line">sudo ufw allow out ftp comment &apos;allow FTP traffic out&apos;</span><br><span class="line"></span><br><span class="line">#允许 whois</span><br><span class="line">sudo ufw allow out whois comment &apos;allow whois&apos;</span><br><span class="line"></span><br><span class="line">#允许端口 68 的流量输出 -  DHCP 客户端</span><br><span class="line">#如果你正在使用 DHCP，则需要如下设置</span><br><span class="line">sudo ufw allow out 68 comment &apos;allow the DHCP client to update&apos;</span><br></pre></td></tr></table></figure><ul><li>如需拒绝端口 99 上的任何流量，可使用以下命令：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ufw deny 99</span><br></pre></td></tr></table></figure><ul><li>最后，使用以下命令启动 UFW：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ufw enable</span><br></pre></td></tr></table></figure><p>你还可以使用以下命令查看 UFW 状态：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ufw status</span><br></pre></td></tr></table></figure><h2 id="防止自动化攻击"><a href="#防止自动化攻击" class="headerlink" title="防止自动化攻击"></a>防止自动化攻击</h2><p>你可以使用两个程序来阻止大多数自动化攻击：</p><ul><li><a href="http://www.cipherdyne.org/psad/" target="_blank" rel="noopener">PSAD</a></li><li><a href="https://www.fail2ban.org/" target="_blank" rel="noopener">Fail2Ban</a></li></ul><h3 id="PSAD-和-Fail2Ban-之间的区别"><a href="#PSAD-和-Fail2Ban-之间的区别" class="headerlink" title="PSAD 和 Fail2Ban 之间的区别"></a>PSAD 和 Fail2Ban 之间的区别</h3><p>我们知道，端口可以提供给服务器上的应用程序进行访问。攻击者为了访问你的服务器，也许会扫描你的服务器目前开放的端口。</p><p><strong>PSAD</strong> 监视网络活动，以检测并自定义阻止端口扫描和其他类型的可疑流量，如 DDoS 攻击或操作系统指纹识别尝试。</p><p><strong>Fail2Ban</strong> 扫描各种应用程序（如 FTP）的日志文件，并自动封禁有明显恶意行为（如自动登录尝试）的 IP。</p><p>以下指南将向你展示如何安装和配置 PSAD 和 Fail2Ban，以便它们与 UFW 一起使用。</p><ul><li><a href="https://zaiste.net/intro_fail2ban_with_ufw/" target="_blank" rel="noopener">安装 Fail2Ban</a></li><li><a href="https://gist.github.com/netson/c45b2dc4e835761fbccc" target="_blank" rel="noopener">安装 PSAD</a></li></ul><h2 id="安装-logwatch"><a href="#安装-logwatch" class="headerlink" title="安装 logwatch"></a>安装 logwatch</h2><p>服务器上的应用程序通常会将日志消息保存到日志文件中。除非你要手动监控日志文件，否则需要安装 logwatch。logwatch 将扫描系统日志文件并对其进行汇总。</p><p>你可以直接从命令行或计划任务运行 logwatch。例如，你可以配置 logwatch 将日志文件的每日摘要以电子邮件的形式发送给你。注意确保你的服务器可以正常发送电子邮件。</p><p>logwatch 通过 service 文件来获取读取和汇总日志文件的方式。你可以在 <code>/usr/share/logwatch/scripts/services</code> 中查看所有 service 文件。</p><p>logwatch 默认配置文件是 <code>/usr/share/logwatch/default.conf/logwatch.conf</code>。你可以通过使用命令行参数更改配置。</p><p>在 Ubuntu 或 Debian 上安装 logwatch，可运行以下命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install logwatch</span><br></pre></td></tr></table></figure><p>对于其他 Linux 发行版的用户，请查看 Linode 的<a href="https://www.linode.com/docs/uptime/monitoring/monitor-systems-logwatch/" target="_blank" rel="noopener">这篇指南</a>。</p><p>如果你需要查看 logwatch 收集的日志样本，你可以尝试直接运行 logwatch。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo /usr/sbin/logwatch --output stdout --format text --range yesterday --service all</span><br></pre></td></tr></table></figure><p>最后，然后 logwatch 每天发送一封电子邮件，其中包含我们日志文件的摘要。为实现此需求，可以打开文件 <em>/etc/cron.daily/00logwatch</em> 并找到 <em>execute</em> 行，然后将其更改为以下内容：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/usr/sbin/logwatch --output mail --format html --mailto root --range yesterday --service all</span><br></pre></td></tr></table></figure><h2 id="执行安全审计"><a href="#执行安全审计" class="headerlink" title="执行安全审计"></a>执行安全审计</h2><p>在加固 Linux 服务器后，你应该进行安全审计，以便排查任何可能被忽视的安全漏洞。为此，你可以使用 Lynis，这是一个可以实现以下功能的开源软件：</p><ul><li>安全审计。</li><li>一致性测试（例如 PCI，HIPAA，SOx）。</li><li>渗透测试。</li><li>漏洞检测。</li><li>系统强化。</li></ul><h3 id="如何使用-Lynis"><a href="#如何使用-Lynis" class="headerlink" title="如何使用 Lynis"></a>如何使用 Lynis</h3><p>首先，通过克隆其 Github 仓库来安装 Lynis。这可确保安装的是最新版本的 Lynis。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/CISOfy/lynis</span><br></pre></td></tr></table></figure><p>切换到我们克隆 Lynis 的目录：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd lynis</span><br></pre></td></tr></table></figure><p>最后，使用以下命令运行第一次安全审计：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lynis audit system</span><br></pre></td></tr></table></figure><p>你可以在 Lynis 的<a href="https://cisofy.com/lynis/" target="_blank" rel="noopener">官方网站</a>上了解更多相关信息。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>很高兴你能阅读这篇有关加固 Linux 服务器的 how-to 指南。希望你能从中获益。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;原文 &lt;a href=&quot;https://medium.com/servers-101/how-to-secure-your-linux-server-6026cfcdefd8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;How To Secure Your Linux Server In 7 Easy Steps&lt;/a&gt; 由 &lt;a href=&quot;https://medium.com/@mutendebrian&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Brian Mutende&lt;/a&gt; 发布于 Medium，翻译转载已获作者允许。&lt;br&gt;为配合博客目录系统显示，对原文章节名略有修改。&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;大多数服务器经常会被黑客攻击。所以我决定写一篇简短的教程，让读者轻松加固自己的 Linux 服务器。&lt;/p&gt;
&lt;p&gt;这并不是一篇完整的安全指南，但是它可以帮你阻断近九成常见的后端攻击，例如&lt;strong&gt;暴力破解&lt;/strong&gt;和 &lt;strong&gt;DDoS&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;最棒的是，你可以在一两个小时内就完成操作。&lt;/p&gt;
&lt;h1 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;你需要一台Linux服务器。&lt;/li&gt;
&lt;li&gt;你需要对命令行有基本的了解。&lt;a href=&quot;https://learncodethehardway.org/unix/bash_cheat_sheet.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;提供一份 cheet sheet 供你使用。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果你已万事俱备，那就开始吧。&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="https://acuario.xyz/categories/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Linux" scheme="https://acuario.xyz/categories/%E6%95%99%E7%A8%8B/Linux/"/>
    
    
      <category term="教程" scheme="https://acuario.xyz/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Linux" scheme="https://acuario.xyz/tags/Linux/"/>
    
      <category term="命令行" scheme="https://acuario.xyz/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
      <category term="服务器安全" scheme="https://acuario.xyz/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>播客札记（二）</title>
    <link href="https://acuario.xyz/podcast-note-2/"/>
    <id>https://acuario.xyz/podcast-note-2/</id>
    <published>2019-04-24T16:00:00.000Z</published>
    <updated>2019-04-28T09:23:43.218Z</updated>
    
    <content type="html"><![CDATA[<h1 id="翻电-Special-VOL04-996-不仅是道德问题"><a href="#翻电-Special-VOL04-996-不仅是道德问题" class="headerlink" title="翻电 Special VOL04 | 996 不仅是道德问题"></a>翻电 Special VOL04 | 996 不仅是道德问题</h1><p><a href="https://overcast.fm/+GsFgwEus4" target="_blank" rel="noopener">Episode Archive</a></p><h2 id="996-的现状和成因"><a href="#996-的现状和成因" class="headerlink" title="996 的现状和成因"></a>996 的现状和成因</h2><ul><li>超时工作 / 加班最多的工作往往处于社会两端：高收入者（高管、投行）和低收入者（工厂工人、出租车司机、快递员、外卖员）。</li><li>高收入者超时工作的原因：由于社会分工程度有上限，具有创造性的工作实际难以再被细节分工。而此类工作大多是无法分工的高产出单人项目。</li><li>低收入者超时工作的原因：此类工作是计件工资制度，多劳多得。</li><li>正常工作是固定工资模式，其处于高收入者和低收入者之间，涉及的创造性的工作和计件工作不多。</li><li>996 运动的爆发来源于高收入者工作模式对正常工作，即固定工资模式的侵入。</li><li>互联网行业的军备竞赛导致了对 996 工作制的需求。</li><li>不患寡而患不均，996 的出现往往是企业文化的整体问题，而非个别部门的个别现象。</li></ul><h2 id="商业模式与-996-的关系"><a href="#商业模式与-996-的关系" class="headerlink" title="商业模式与 996 的关系"></a>商业模式与 996 的关系</h2><ul><li>普通企业的盈利是基于商品的利润。工作量增多带来的投入产出比相对较低。</li><li>互联网行业的盈利是基于股本的增值。估值方法为公司的产品能力、用户数等因素。</li><li>劳动与劳动的区分不在于脑体，而在于资本密集程度。资本市场的存在催生互联网行业和投行等领域的高薪 996。</li><li>八小时工作制最早由英国空想社会主义者罗伯特・欧文于 1817 年 8 月提出。其后由于欧美资本家对劳工的剥削不断加剧，1886 年 5 月 1 日美国芝加哥爆发了历史最大的罢工，倡导实行八小时工作制。</li><li>经济下行期强调、诉求加班文化的企业将会越来越多。在经济下行期，加班将不再只是劳资问题，而将是企业与企业之间军备竞赛的问题。企业主认为在经济下行期控制支出成本的同时提高工作产出，形成企业与企业之间的重商主义。为合理化这一观念，将会出现越来越多提倡奋斗、勤劳文化的论调。</li></ul><a id="more"></a><hr><h1 id="翻转问答-VOL19-应该成为多才多艺的人吗？"><a href="#翻转问答-VOL19-应该成为多才多艺的人吗？" class="headerlink" title="翻转问答 VOL19 | 应该成为多才多艺的人吗？"></a>翻转问答 VOL19 | 应该成为多才多艺的人吗？</h1><p><a href="https://overcast.fm/+GsFiolXRY" target="_blank" rel="noopener">Episode Archive</a></p><h2 id="多样的人生有什么样的假设基础"><a href="#多样的人生有什么样的假设基础" class="headerlink" title="多样的人生有什么样的假设基础"></a>多样的人生有什么样的假设基础</h2><ul><li>假设基础：世间的很多禀赋没有高下之分，各种的才能之间都是平等的。</li><li>上述假设是多元主义的，同时也具有平民主义的特点。</li></ul><h2 id="过去的年代人们有什么样的生活重心"><a href="#过去的年代人们有什么样的生活重心" class="headerlink" title="过去的年代人们有什么样的生活重心"></a>过去的年代人们有什么样的生活重心</h2><ul><li>中世纪社会认为人寻求救赎、追求彼岸最重要，所以僧侣的地位最高。</li><li>法国大革命将第一阶级和第三阶级平等化，不因不同社会分工而地位不同。</li><li>古希腊没有社会分工，专业化只存在于奴隶中。但依然有依据城邦的存续而发展出来的作为人的第一要务——成为伟大的战士、成为关心城邦政事的自由民。eg.埃斯库罗斯的墓志铭</li><li>儒家的承礼启仁是古时的时代精神。</li><li>现代社会多才多艺的精英来自于文艺复兴时期的知识分子。</li></ul><h2 id="今天为何生活失去重心"><a href="#今天为何生活失去重心" class="headerlink" title="今天为何生活失去重心"></a>今天为何生活失去重心</h2><ul><li>今天的时代失去重心，一切问题没有被化解和体认，而是被掩盖起来，最终导致了现代社会推崇多元精英。</li><li>我们不应宣扬没有实指的东西（eg. 优秀、厉害），而应该宣扬找到自己的使命和重心。</li></ul><h2 id="技术化生活的起点和有效性"><a href="#技术化生活的起点和有效性" class="headerlink" title="技术化生活的起点和有效性"></a>技术化生活的起点和有效性</h2><ul><li>一切多元精英论调的滥觞——《高效人士的 7 个习惯》。</li><li>网络上充斥的技术化指导实际难有成效，如：<ol><li><em>有效时间内提高产出</em>；</li><li><em>如何面临抉择</em>。</li></ol></li><li>上述技术化指导有效的前提假设是：一个人只要改变想法就可以改变行为，改变行为就可以改变生活。但是改变想法、改变行为和改变生活之间并未有很强的联系。</li></ul><h2 id="每一个时代都有唯一重要的事"><a href="#每一个时代都有唯一重要的事" class="headerlink" title="每一个时代都有唯一重要的事"></a>每一个时代都有唯一重要的事</h2><ul><li>每一个时代都有唯一重要和可欲的事，不代表所有人必须做同样的事。根据人的理解不同，切入点可以不同。</li><li>可欲的事非常少，每个人都应以自己的方式体认这个时代的时代精神，并以自己的特殊性和个体性切入行事当中。</li></ul><h2 id="面向真相敞开"><a href="#面向真相敞开" class="headerlink" title="面向真相敞开"></a>面向真相敞开</h2><ul><li>如果要接近时代症结，就需要面向真相敞开。由于现代社会语言已经弱化和腐化，从语言的方向接近真相已经比较困难，所以可以尝试回到身体感受，从具有个体性的身体感受开始找回自己的重心，不要被人为的概念和方法影响。</li><li>我们不应该要求自己成为一个比别人更优秀和厉害的人，因为在任何领域毫无止境的比较将把人拉入没有赢面的游戏之中。</li><li>不仅仅接受哲学道理，而是感悟其人的经历和经历对其道理带来的影响。eg. 维特根斯坦</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;翻电-Special-VOL04-996-不仅是道德问题&quot;&gt;&lt;a href=&quot;#翻电-Special-VOL04-996-不仅是道德问题&quot; class=&quot;headerlink&quot; title=&quot;翻电 Special VOL04 | 996 不仅是道德问题&quot;&gt;&lt;/a&gt;翻电 Special VOL04 | 996 不仅是道德问题&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://overcast.fm/+GsFgwEus4&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Episode Archive&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;996-的现状和成因&quot;&gt;&lt;a href=&quot;#996-的现状和成因&quot; class=&quot;headerlink&quot; title=&quot;996 的现状和成因&quot;&gt;&lt;/a&gt;996 的现状和成因&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;超时工作 / 加班最多的工作往往处于社会两端：高收入者（高管、投行）和低收入者（工厂工人、出租车司机、快递员、外卖员）。&lt;/li&gt;
&lt;li&gt;高收入者超时工作的原因：由于社会分工程度有上限，具有创造性的工作实际难以再被细节分工。而此类工作大多是无法分工的高产出单人项目。&lt;/li&gt;
&lt;li&gt;低收入者超时工作的原因：此类工作是计件工资制度，多劳多得。&lt;/li&gt;
&lt;li&gt;正常工作是固定工资模式，其处于高收入者和低收入者之间，涉及的创造性的工作和计件工作不多。&lt;/li&gt;
&lt;li&gt;996 运动的爆发来源于高收入者工作模式对正常工作，即固定工资模式的侵入。&lt;/li&gt;
&lt;li&gt;互联网行业的军备竞赛导致了对 996 工作制的需求。&lt;/li&gt;
&lt;li&gt;不患寡而患不均，996 的出现往往是企业文化的整体问题，而非个别部门的个别现象。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;商业模式与-996-的关系&quot;&gt;&lt;a href=&quot;#商业模式与-996-的关系&quot; class=&quot;headerlink&quot; title=&quot;商业模式与 996 的关系&quot;&gt;&lt;/a&gt;商业模式与 996 的关系&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;普通企业的盈利是基于商品的利润。工作量增多带来的投入产出比相对较低。&lt;/li&gt;
&lt;li&gt;互联网行业的盈利是基于股本的增值。估值方法为公司的产品能力、用户数等因素。&lt;/li&gt;
&lt;li&gt;劳动与劳动的区分不在于脑体，而在于资本密集程度。资本市场的存在催生互联网行业和投行等领域的高薪 996。&lt;/li&gt;
&lt;li&gt;八小时工作制最早由英国空想社会主义者罗伯特・欧文于 1817 年 8 月提出。其后由于欧美资本家对劳工的剥削不断加剧，1886 年 5 月 1 日美国芝加哥爆发了历史最大的罢工，倡导实行八小时工作制。&lt;/li&gt;
&lt;li&gt;经济下行期强调、诉求加班文化的企业将会越来越多。在经济下行期，加班将不再只是劳资问题，而将是企业与企业之间军备竞赛的问题。企业主认为在经济下行期控制支出成本的同时提高工作产出，形成企业与企业之间的重商主义。为合理化这一观念，将会出现越来越多提倡奋斗、勤劳文化的论调。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="播客札记" scheme="https://acuario.xyz/categories/%E6%92%AD%E5%AE%A2%E6%9C%AD%E8%AE%B0/"/>
    
    
      <category term="Podcast" scheme="https://acuario.xyz/tags/Podcast/"/>
    
      <category term="播客" scheme="https://acuario.xyz/tags/%E6%92%AD%E5%AE%A2/"/>
    
      <category term="翻转电台" scheme="https://acuario.xyz/tags/%E7%BF%BB%E8%BD%AC%E7%94%B5%E5%8F%B0/"/>
    
      <category term="996" scheme="https://acuario.xyz/tags/996/"/>
    
      <category term="加班文化" scheme="https://acuario.xyz/tags/%E5%8A%A0%E7%8F%AD%E6%96%87%E5%8C%96/"/>
    
      <category term="多才多艺的人生" scheme="https://acuario.xyz/tags/%E5%A4%9A%E6%89%8D%E5%A4%9A%E8%89%BA%E7%9A%84%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB 与 MyISAM 的区别</title>
    <link href="https://acuario.xyz/differences-between-innodb-and-myisam/"/>
    <id>https://acuario.xyz/differences-between-innodb-and-myisam/</id>
    <published>2019-04-21T09:24:56.000Z</published>
    <updated>2019-04-21T10:12:49.618Z</updated>
    
    <content type="html"><![CDATA[<p>目前 MySQL 的数据库引擎一般使用 InnoDB 和 MyISAM，但两者存在一些差别。网上零零散散的文章看起来比较麻烦，这里以表格汇总对比二者区别。如有纰漏，还望读者在评论区指正。</p><table><thead><tr><th></th><th>InnoDB</th><th>MyISAM</th></tr></thead><tbody><tr><td>MySQL 默认引擎</td><td>✅</td><td>❌</td></tr><tr><td>事务</td><td>✅</td><td>❌</td></tr><tr><td>并发</td><td>表级锁 ✅<br>行级锁 ✅，采用 MVCC 来支持高并发，有可能死锁</td><td>表级锁 ✅<br>行级锁 ❌</td></tr><tr><td>外键</td><td>✅</td><td>❌</td></tr><tr><td>在线热备份</td><td>✅</td><td>❌</td></tr><tr><td>COUNT (*)</td><td>无 meta-data 缓存，查全表获取</td><td>有 meta-data 缓存，直接获取</td></tr><tr><td>崩溃恢复</td><td>通过事务日志来恢复数据库</td><td>损坏率高，恢复速度慢，不能安全恢复</td></tr><tr><td>其他</td><td>默认隔离级别是可重复读（REPEATABLE READ），通过多版本并发控制（MVCC）+ 间隙锁（Next-Key Locking）防止幻影读</td><td>设计简单，数据以紧密格式存储</td></tr><tr><td>索引特性</td><td>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</td><td>DELAY_KEY_WRITE 选项：修改后，新索引数据写入内存中的键缓冲区，清理键缓冲区或者关闭表时才写入磁盘。极大提升写入性能，但崩溃时会造成索引损坏</td></tr><tr><td>全文索引</td><td>>= MySQL 5.6.4 ✅<br>  &lt; MySQL 5.6.4 ❌</td><td>✅<br>支持 BLOB 和 TEXT 的前 500 个字符索引</td></tr><tr><td>自有特性</td><td>内部优化：<br>1. 可预测性读加快读操作<br>2. 自适应哈希索引加速插入操作的插入缓冲区</td><td>1. 支持压缩表和空间数据索引<br>2.并发插入（CONCURRENT INSERT）：在表有读取操作的同时，也可以往表中插入新的记录</td></tr></tbody></table><hr><p>参考链接：<br><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/MySQL.md#%E4%B8%89%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E" target="_blank" rel="noopener">技术面试必备基础知识：MySQL</a><br><a href="http://cxymrzero.github.io/blog/2015/08/17/myisam-innodb/" target="_blank" rel="noopener">MyISAM 与 InnoDB 区别</a><br><a href="https://juejin.im/post/5b1685bef265da6e5c3c1c34" target="_blank" rel="noopener">MySQL 常见的两种存储引擎：MyISAM 与 InnoDB 的爱恨情仇</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目前 MySQL 的数据库引擎一般使用 InnoDB 和 MyISAM，但两者存在一些差别。网上零零散散的文章看起来比较麻烦，这里以表格汇总对比二者区别。如有纰漏，还望读者在评论区指正。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Inno
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://acuario.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="MySQL" scheme="https://acuario.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://acuario.xyz/tags/MySQL/"/>
    
      <category term="数据库" scheme="https://acuario.xyz/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="学习笔记" scheme="https://acuario.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>播客札记（一）</title>
    <link href="https://acuario.xyz/podcast-note-1/"/>
    <id>https://acuario.xyz/podcast-note-1/</id>
    <published>2019-04-11T16:00:00.000Z</published>
    <updated>2019-04-28T09:22:12.282Z</updated>
    
    <content type="html"><![CDATA[<h1 id="翻转问答-VOL8-亲密关系"><a href="#翻转问答-VOL8-亲密关系" class="headerlink" title="翻转问答 VOL8 | 亲密关系"></a>翻转问答 VOL8 | 亲密关系</h1><p><a href="https://overcast.fm/+GsFgR-JZI" target="_blank" rel="noopener">Episode Archive</a></p><h2 id="亲密关系的特点"><a href="#亲密关系的特点" class="headerlink" title="亲密关系的特点"></a>亲密关系的特点</h2><ul><li>个人主义社会——代表排除共同体、排除外部主张的合理性，关注自我的合理性，且自我合理性不与所处共同体相关，是一种纯粹的根本的自我。</li><li>亲密关系是一种纯粹关系，与个人主义的自我产生关联，过去的亲密关系属于共同体（家庭、集体），如今属于自我。</li><li>现代自我拥有物理和心理意义上更多的私人空间，亲密关系与私人空间的冲突恰是其特殊性。</li><li>亲密关系可以充分满足自我认可。因为：<ol><li>亲密关系是自信心和基础安全感的来源；</li><li>亲密关系是制度化社会中几乎唯一的非制度要素的情景，用以释放制度压抑（福柯提出性和药物释放制度压抑）；</li><li>荣格心理学认为，亲密关系是人与自身异性人格（anima 和 animus）达成和解的要素，即是自身自信。</li></ol></li></ul><h2 id="亲密关系为何脆弱"><a href="#亲密关系为何脆弱" class="headerlink" title="亲密关系为何脆弱"></a>亲密关系为何脆弱</h2><ul><li>现代生活中，维系亲密关系的外部必然性消失，促使人反思自身的亲密关系，但亲密关系本身禁不起反思。</li><li>社会流动性越来越大，增加了更多亲密关系的选择。</li><li>亲密关系博弈成为囚徒困境博弈，结合亲密关系边际效应使人更愿意考虑成本和收益而做出选择。</li><li>开放式关系看似消解了亲密关系的囚徒困境，但依旧无法达成 anima 和 animus 和解，且个人主义的本质下，亲密关系是一对一的。</li></ul><a id="more"></a><h2 id="现代知识异化中对亲密关系的-5-种关键隐喻"><a href="#现代知识异化中对亲密关系的-5-种关键隐喻" class="headerlink" title="现代知识异化中对亲密关系的 5 种关键隐喻"></a>现代知识异化中对亲密关系的 5 种关键隐喻</h2><ol><li>健康——感情健康。根本原因是纯粹的亲密关系失去了基础。难免被套用到客观评判体系，引入制度和技术对亲密关系进行调和。</li><li>企业——如何「经营」感情。</li><li>镜像神经元——充分了解对方、完全换位思考理解对方。</li><li>信仰——亲密关系是心诚则灵的东西。信仰在宗教中只照顾生活中与自我存在相关的绝对要素，如救赎——而不是现实功利主义在乎的东西。</li><li>自我——爱别人首先要爱自己。这是纯粹个人主义对亲密关系的排除。但除了自恋之外的「爱」本身就是否定自我的过程，要爱自己，不得不承认宾我与主我的存在，并反对接受宾我的反思。能够做到彻底的自爱的人，定是一个绝对自私的人。</li></ol><h2 id="如何保卫亲密关系"><a href="#如何保卫亲密关系" class="headerlink" title="如何保卫亲密关系"></a>如何保卫亲密关系</h2><ol><li>不仅保卫亲密关系，也要保卫其他真正的关系——如亲情关系、友情关系。</li><li>通过其他真正的关系来锻炼自己承担人际风险的能力，从而减弱自己的胆怯和容易在亲密关系中收到的伤害。</li></ol><hr><h1 id="翻转问答-VOL9-如何看待中医和西医的对比"><a href="#翻转问答-VOL9-如何看待中医和西医的对比" class="headerlink" title="翻转问答 VOL9 | 如何看待中医和西医的对比"></a>翻转问答 VOL9 | 如何看待中医和西医的对比</h1><p><a href="https://overcast.fm/+GsFjiSGOA" target="_blank" rel="noopener">Episode Archive</a></p><ul><li>伪科学是指任何经宣称为科学，或描述方式看起来像科学，但实际上并不符合科学方法基本要求的知识、缺乏支持证据，经不起可信性测试，或缺乏科学形式，伪科学常常使用模糊的、自相矛盾的、夸张的或无法证明的主张，过度依赖确认而不是严格的反驳，缺乏其它专家的公开确认，缺乏系统化、理性化的理论过程。</li><li>中医是“伪科学”还是“非科学”？</li><li>科学还原论试图将各种领域完全祛魅，进行彻底的科学化。中医是否需要像艺术、宗教一样进行科学化？人的身体和医学一定要“科学化”吗？</li></ul><h2 id="物理世界是否必须科学化？"><a href="#物理世界是否必须科学化？" class="headerlink" title="物理世界是否必须科学化？"></a>物理世界是否必须科学化？</h2><ul><li>物理世界的分类：<ol><li>真实感受建构的世界：食物-味觉，按摩-触觉；</li><li>目的建构的世界：与目的高度相关——交通、建筑；</li><li>数学建构的世界：完全的抽象世界。</li></ol></li><li>真实感受的物理世界的语汇与科学的语汇存在范式差异：如味觉「鲜」（厨师烹饪时加糖提鲜）实际并非用科学语境下的「鲜味」。所以并非所有场景都要用科学语汇来替代真实感受的物理世界的语汇。</li><li>目的的物理世界由于存在理论与实践的差异，但并非所有实践都需要确切的理论认识：如鸟的飞行行为本身并不依赖于理论认识；部分尖端科技的发现（认识）是实践（实验）中的偶然，并非现有认识才有实践。</li><li>数学（及其相关）的物理世界由于完全抽象而进行了科学化：如天文学的观测结果、基因层面的理论等。</li></ul><h2 id="医学是否应该属于数学的物理世界？"><a href="#医学是否应该属于数学的物理世界？" class="headerlink" title="医学是否应该属于数学的物理世界？"></a>医学是否应该属于数学的物理世界？</h2><ul><li>基础假设：科学构筑了现象世界以外的不能被感官感知的现象，这些东西是比被感官感知的东西更本质的原因。即如果能找到非无感现象的原因，则五感现象基本都是偏见和错误。</li><li>相信科学即相信上述基础假设。</li><li>现代医学的专业化细分使其可以属于数学的物理世界这一范畴。西医对细节化学现象的分析、对人体化学还原的做法是逻辑自洽的。</li><li>医学自洽是对细节化学现象的自洽，而非对人整体的自洽。</li><li>副作用的存在没有证伪任何化学理论，而是提出了更多难以解释的现象。</li></ul><h2 id="证伪是什么意思？证伪很重要吗？"><a href="#证伪是什么意思？证伪很重要吗？" class="headerlink" title="证伪是什么意思？证伪很重要吗？"></a>证伪是什么意思？证伪很重要吗？</h2><ul><li>「证伪 = 求真」是语言误用。</li><li>被证伪不代表因果性不存在。</li><li>只有科学可以被证伪，但日常医学实践并未以证伪的方式推进科学。</li><li>证伪、实证并非最重要的方法论。</li></ul><h2 id="西医的现状和逻辑问题"><a href="#西医的现状和逻辑问题" class="headerlink" title="西医的现状和逻辑问题"></a>西医的现状和逻辑问题</h2><ul><li>西医治疗的是微观的现象（症状），而非整个人体本身。</li><li>人体的健康状况不是细节现象，而整体宏观秩序。</li><li>西医的统计学基础决定了受众是社会整体，而非单个个体，西医以社会工程学为基础，而非个体研究为基础。临床检验流程，是从社会工程学角度确定药物对社会的安全性，而非对独立个体的安全性。同时，统计样本的选取，也左右着西医实际参考价值。个体差异的复杂性导致个体参与医学治疗的差异性。</li></ul><h2 id="中医有没有理论？"><a href="#中医有没有理论？" class="headerlink" title="中医有没有理论？"></a>中医有没有理论？</h2><ul><li>专家崇拜是现代性的一大问题。以信托的方式相信专家，是存在实际风险和问题的。</li><li>中医并非没有理论，而是非科学理论。</li><li>中医的理论前提是阴阳五行的信念，西医的理论前提是数学理论的实在。</li><li>实用主义角度来看，阴阳五行理论在某种程度上阐释了身体的现象和关系。我们承认其有理，但为何我们否认其「真」？</li></ul><h2 id="我们需要的一种“本体论”清醒"><a href="#我们需要的一种“本体论”清醒" class="headerlink" title="我们需要的一种“本体论”清醒"></a>我们需要的一种“本体论”清醒</h2><ul><li>认为科学发展可以一往无前，将有科学宗教和科学迷信的风险。</li><li>大多数科学的发现是应用领域的新应用，而非原理领域的新发现。</li><li>科学意义的「存在」和我们五感的「存在」并非相同意义，我们虽未以五感方式认知其科学「存在」，但我们对其有信任。这与阴阳五行理论的「存在」并无本质差异。</li><li>真理掌握我们，而非我们掌握真理。</li></ul><h2 id="为何中医话题敏感？"><a href="#为何中医话题敏感？" class="headerlink" title="为何中医话题敏感？"></a>为何中医话题敏感？</h2><ul><li>以公共说理和公共舆论为重要基础，科学的公共话题变得比较敏感。</li><li>人被隔绝的日常实践，通过口头表达和表达被人承认获得自我认知和实现。</li><li>随着互联网发展，公共言论和公共舆论与权力高度相关。</li><li>在公共说理领域，面对多变的环境和不确定性的受众，我们需要一种货币一样的硬通货来说理——普遍主义。</li><li>启蒙理性和科学，诞生于对神学的批判，但在批驳的同时继承了神学的确定性和普遍主义。</li><li>科学无法争取的普遍主义的领域，将被权力斥为不重要和无意义。如艺术、形而上学、人生价值。</li><li>认为「一个领域必须留给其专业的、有其实践经验的人」的想法，是十分傲慢、不负责任、导致社会进一步切割的观念。专家崇拜是现代性涌现的巨大问题，它带来社会盲目和个体自信心和安全感的丧失。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;翻转问答-VOL8-亲密关系&quot;&gt;&lt;a href=&quot;#翻转问答-VOL8-亲密关系&quot; class=&quot;headerlink&quot; title=&quot;翻转问答 VOL8 | 亲密关系&quot;&gt;&lt;/a&gt;翻转问答 VOL8 | 亲密关系&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://overcast.fm/+GsFgR-JZI&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Episode Archive&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;亲密关系的特点&quot;&gt;&lt;a href=&quot;#亲密关系的特点&quot; class=&quot;headerlink&quot; title=&quot;亲密关系的特点&quot;&gt;&lt;/a&gt;亲密关系的特点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;个人主义社会——代表排除共同体、排除外部主张的合理性，关注自我的合理性，且自我合理性不与所处共同体相关，是一种纯粹的根本的自我。&lt;/li&gt;
&lt;li&gt;亲密关系是一种纯粹关系，与个人主义的自我产生关联，过去的亲密关系属于共同体（家庭、集体），如今属于自我。&lt;/li&gt;
&lt;li&gt;现代自我拥有物理和心理意义上更多的私人空间，亲密关系与私人空间的冲突恰是其特殊性。&lt;/li&gt;
&lt;li&gt;亲密关系可以充分满足自我认可。因为：&lt;ol&gt;
&lt;li&gt;亲密关系是自信心和基础安全感的来源；&lt;/li&gt;
&lt;li&gt;亲密关系是制度化社会中几乎唯一的非制度要素的情景，用以释放制度压抑（福柯提出性和药物释放制度压抑）；&lt;/li&gt;
&lt;li&gt;荣格心理学认为，亲密关系是人与自身异性人格（anima 和 animus）达成和解的要素，即是自身自信。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;亲密关系为何脆弱&quot;&gt;&lt;a href=&quot;#亲密关系为何脆弱&quot; class=&quot;headerlink&quot; title=&quot;亲密关系为何脆弱&quot;&gt;&lt;/a&gt;亲密关系为何脆弱&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;现代生活中，维系亲密关系的外部必然性消失，促使人反思自身的亲密关系，但亲密关系本身禁不起反思。&lt;/li&gt;
&lt;li&gt;社会流动性越来越大，增加了更多亲密关系的选择。&lt;/li&gt;
&lt;li&gt;亲密关系博弈成为囚徒困境博弈，结合亲密关系边际效应使人更愿意考虑成本和收益而做出选择。&lt;/li&gt;
&lt;li&gt;开放式关系看似消解了亲密关系的囚徒困境，但依旧无法达成 anima 和 animus 和解，且个人主义的本质下，亲密关系是一对一的。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="播客札记" scheme="https://acuario.xyz/categories/%E6%92%AD%E5%AE%A2%E6%9C%AD%E8%AE%B0/"/>
    
    
      <category term="Podcast" scheme="https://acuario.xyz/tags/Podcast/"/>
    
      <category term="播客" scheme="https://acuario.xyz/tags/%E6%92%AD%E5%AE%A2/"/>
    
      <category term="翻转电台" scheme="https://acuario.xyz/tags/%E7%BF%BB%E8%BD%AC%E7%94%B5%E5%8F%B0/"/>
    
      <category term="亲密关系" scheme="https://acuario.xyz/tags/%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB/"/>
    
      <category term="中医" scheme="https://acuario.xyz/tags/%E4%B8%AD%E5%8C%BB/"/>
    
  </entry>
  
  <entry>
    <title>SS/SSR中转V2ray起飞教程</title>
    <link href="https://acuario.xyz/delegate-v2ray-traffic-to-ss-or-ssr/"/>
    <id>https://acuario.xyz/delegate-v2ray-traffic-to-ss-or-ssr/</id>
    <published>2019-04-01T07:58:18.000Z</published>
    <updated>2019-06-07T15:07:53.593Z</updated>
    
    <content type="html"><![CDATA[<p>本文目标读者：</p><ul><li>拥有自建 V2Ray 代理</li><li>有机场使用经验</li><li>没钱买高价机场 / 乐于使(bái)用(piáo)公益机场</li><li>使用机场服务，但忌惮流量安全</li></ul><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>目前市面上已经有很多机场（提供 SS/SSR 服务的网站），且不乏众多公益机场，这些机场因为拥有一些好线路的服务器，所以在使用的时候可以获得较好的突破网络封锁的体验。比起自己购买一个垃圾服务器，使用时的龟速；以及购买一个优质线路服务器，承受每月高额费用；更不用说还要担心自己服务器被 GFW 认证的风险——使用机场真是省钱省心。但是隐私问题也不容小觑，支付时的隐私泄露按下不表，本文的初衷是规避使用机场时流量隐私泄露的问题——如何使用机场服务的同时不暴露自己的流量隐私。</p><p>V2Ray 除了支持自有协议 VMess 之外，还支持 Socks、Shadowsocks 等协议，配合自带的流量中转功能，可以在保护流量隐私的同时，借助机场起飞，最大程度上提升代理使用体验。</p><p>前面说这么多，说人话就是——花最少的钱，用最好的线路，让偷窥流量 / 监控流量的机场见鬼去吧。</p><h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><p><img src="https://i.loli.net/2019/04/01/5ca1b95248225.png" alt="无标题.png"></p><a id="more"></a><p>基本原理大致如下：</p><ol><li>V2Ray 客户端先将流量使用 VMess 协议加密</li><li>按照不同的加密方法：<br> SS 中转：V2Ray 客户端再使用 SS 协议加密，把两次加密后的流量发送到机场服务器进行中转<br> SSR 中转：V2Ray 客户端把 VMess 加密流量发给 SSR 客户端，SSR 客户端再使用 SSR 协议加密，把两次加密后的流量发送到机场服务器进行中转</li><li>机场服务器对流量进行 SS/SSR 解密后再把流量（VMess 协议加密流量）发往我们自建的 V2Ray 服务器</li><li>V2Ray 服务器正常访问网站</li><li>网站返回的数据按上述步骤和处理方式原路返回</li></ol><p>由于机场服务器收到的是 VMess 协议加密后的流量，加密方法又是我们自定义的，所以机场几无可能掌握我们的真实流量。下面动手实操。</p><h1 id="SS-中转-V2Ray-流量"><a href="#SS-中转-V2Ray-流量" class="headerlink" title="SS 中转 V2Ray 流量"></a>SS 中转 V2Ray 流量</h1><p>V2Ray 自身支持 Shadowsocks 协议，所以 SS 中转 V2Ray 流量按照官方的<a href="https://toutyrater.github.io/advanced/outboundproxy.html" target="_blank" rel="noopener">白话文教程</a>来操作就行了。简单来说就是把配置文件中的 <code>outbounds</code> 部分设置为这样：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;outbounds&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;protocol&quot;: &quot;vmess&quot;,</span><br><span class="line">      &quot;settings&quot;: &#123; // 此处根据自己的V2Ray设置修改</span><br><span class="line">        &quot;vnext&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;address&quot;: &quot;1.1.1.1&quot;,</span><br><span class="line">            &quot;port&quot;: 8888,</span><br><span class="line">            &quot;users&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;alterId&quot;: 64,</span><br><span class="line">                &quot;id&quot;: &quot;b12614c5-5ca4-4eba-a215-c61d642116ce&quot;</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;proxySettings&quot;: &#123;</span><br><span class="line">          &quot;tag&quot;: &quot;transit&quot;  // 把 V2Ray 流量发给 tag 名为 transit 的代理进行转发</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;protocol&quot;: &quot;shadowsocks&quot;,</span><br><span class="line">      &quot;settings&quot;: &#123; // 此处填上机场某个 SS 服务器的配置</span><br><span class="line">        &quot;servers&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;address&quot;: &quot;2.2.2.2&quot;,</span><br><span class="line">            &quot;method&quot;: &quot;aes-256-cfb&quot;,</span><br><span class="line">            &quot;ota&quot;: false,</span><br><span class="line">            &quot;password&quot;: &quot;password&quot;,</span><br><span class="line">            &quot;port&quot;: 1024</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;tag&quot;: &quot;transit&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></p><h1 id="SSR-中转-V2Ray-流量"><a href="#SSR-中转-V2Ray-流量" class="headerlink" title="SSR 中转 V2Ray 流量"></a>SSR 中转 V2Ray 流量</h1><p>但是很多机场都是 SSR 机场，没有提供 SS 配置，那岂不是就不能用上面的骚操作了？既然 SSR 支持监听本地的 Socks 流量，V2Ray 又支持 Socks 协议传出，那我们只需要在本地同时打开 V2Ray 和 SSR 客户端，然后用 Socks 协议连接二者通信即可，相当于把上一节中 V2Ray 传出目标从服务器改为本地 SSR。那么配置文件中的 <code>outbounds</code> 部分就设置为这样：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;outbounds&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;protocol&quot;: &quot;vmess&quot;,</span><br><span class="line">      &quot;settings&quot;: &#123; // 此处根据自己的V2Ray设置修改</span><br><span class="line">        &quot;vnext&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;address&quot;: &quot;1.1.1.1&quot;,</span><br><span class="line">            &quot;port&quot;: 8888,</span><br><span class="line">            &quot;users&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;alterId&quot;: 64,</span><br><span class="line">                &quot;id&quot;: &quot;b12614c5-5ca4-4eba-a215-c61d642116ce&quot;</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;proxySettings&quot;: &#123;</span><br><span class="line">          &quot;tag&quot;: &quot;transit&quot;  // 把 V2Ray 流量发给 tag 名为 transit 的代理进行转发</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;protocol&quot;: &quot;socks&quot;,</span><br><span class="line">      &quot;settings&quot;: &#123;</span><br><span class="line">        &quot;servers&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">          &quot;address&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">          &quot;port&quot;: 1080  // 此处填写 SSR 客户端监听的本地端口</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;tag&quot;: &quot;transit&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></p><p>以 Windows 平台为例，我们可以在客户端的「选项设置」中「允许来自局域网的连接」，并且设置 SSR 客户端监听的本地端口：</p><p><img src="https://i.loli.net/2019/04/01/5ca1b95b997fe.png" alt="SSR设置"></p><p>完成设置后，在 SSR 客户端中选择想要使用的服务器节点，并且打开 V2Ray，需要代理的流量全部访问 <strong>V2Ray 客户端监听的端口</strong>即可。</p><p><img src="https://i.loli.net/2019/04/01/5ca1b95d2597b.png" alt="选择SSR服务器节点"></p><p>如果设置正确，访问不存在的网站时，可以在 V2Ray 服务端日志中看到流量全部来自于我们选择机场服务器节点。</p><p><img src="https://i.loli.net/2019/04/01/5ca1b95e30487.png" alt="V2Ray服务端日志"></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="V2Ray-配置文件"><a href="#V2Ray-配置文件" class="headerlink" title="V2Ray 配置文件"></a>V2Ray 配置文件</h2><p>刚开始使用 V2Ray 的人可能会困惑于 V2Ray 配置文件的繁琐，下面提供几个与本文相关的，本人目前正在使用的 V2Ray 完整配置文件，其中客户端配置文件集成了基本的广告屏蔽和大陆直连，本地监听端口为 <code>1082</code>，可根据自己需要进行修改。同时也提供了最简单的服务端配置文件，仅供参考：</p><ul><li><a href="https://gist.github.com/yhyy135/667251599e3e762ca6d86517d39554c8/raw/ba48ac317c5b658b55b4834516d897a4a201a473/ss-vmess-config.json" target="_blank" rel="noopener">SS 中转 V2Ray 客户端配置文件</a></li><li><a href="https://gist.github.com/yhyy135/667251599e3e762ca6d86517d39554c8/raw/ba48ac317c5b658b55b4834516d897a4a201a473/ssr-vmess-config.json" target="_blank" rel="noopener">SSR 中转 V2Ray 客户端配置文件</a></li><li><a href="https://gist.github.com/yhyy135/667251599e3e762ca6d86517d39554c8/raw/ba48ac317c5b658b55b4834516d897a4a201a473/server-config.json" target="_blank" rel="noopener">V2Ray 服务端配置文件</a></li></ul><p>另外，由于 SSR 中转 V2Ray 流量需要同时使用 SSR 客户端和 V2Ray 客户端，所以目前暂时无法在移动设备上实现，略有遗憾。但是既然都可以如此白嫖机场了，还是知足吧。如果你有什么好想法，不妨在评论区交流。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文目标读者：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;拥有自建 V2Ray 代理&lt;/li&gt;
&lt;li&gt;有机场使用经验&lt;/li&gt;
&lt;li&gt;没钱买高价机场 / 乐于使(bái)用(piáo)公益机场&lt;/li&gt;
&lt;li&gt;使用机场服务，但忌惮流量安全&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;目前市面上已经有很多机场（提供 SS/SSR 服务的网站），且不乏众多公益机场，这些机场因为拥有一些好线路的服务器，所以在使用的时候可以获得较好的突破网络封锁的体验。比起自己购买一个垃圾服务器，使用时的龟速；以及购买一个优质线路服务器，承受每月高额费用；更不用说还要担心自己服务器被 GFW 认证的风险——使用机场真是省钱省心。但是隐私问题也不容小觑，支付时的隐私泄露按下不表，本文的初衷是规避使用机场时流量隐私泄露的问题——如何使用机场服务的同时不暴露自己的流量隐私。&lt;/p&gt;
&lt;p&gt;V2Ray 除了支持自有协议 VMess 之外，还支持 Socks、Shadowsocks 等协议，配合自带的流量中转功能，可以在保护流量隐私的同时，借助机场起飞，最大程度上提升代理使用体验。&lt;/p&gt;
&lt;p&gt;前面说这么多，说人话就是——花最少的钱，用最好的线路，让偷窥流量 / 监控流量的机场见鬼去吧。&lt;/p&gt;
&lt;h1 id=&quot;基本原理&quot;&gt;&lt;a href=&quot;#基本原理&quot; class=&quot;headerlink&quot; title=&quot;基本原理&quot;&gt;&lt;/a&gt;基本原理&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/04/01/5ca1b95248225.png&quot; alt=&quot;无标题.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="https://acuario.xyz/categories/%E6%95%99%E7%A8%8B/"/>
    
      <category term="软件使用" scheme="https://acuario.xyz/categories/%E6%95%99%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="教程" scheme="https://acuario.xyz/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="VPS" scheme="https://acuario.xyz/tags/VPS/"/>
    
      <category term="ShadowsocksR" scheme="https://acuario.xyz/tags/ShadowsocksR/"/>
    
      <category term="v2ray" scheme="https://acuario.xyz/tags/v2ray/"/>
    
      <category term="Shadowsocks" scheme="https://acuario.xyz/tags/Shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>使用HyperApp搭建Tiny Tiny RSS</title>
    <link href="https://acuario.xyz/set-up-tiny-tiny-rss-with-hyperapp/"/>
    <id>https://acuario.xyz/set-up-tiny-tiny-rss-with-hyperapp/</id>
    <published>2019-02-26T07:22:31.000Z</published>
    <updated>2019-04-29T14:16:35.001Z</updated>
    
    <content type="html"><![CDATA[<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul><li>VPS 需要先安装好 <code>docker-ce</code></li><li><a href="https://itunes.apple.com/app/apple-store/id1179750280?pt=118260435&amp;ct=guide&amp;mt=8" target="_blank" rel="noopener">HyperApp</a></li><li>一个已经解析正确的域名（ping 验证）</li><li>耐心。仔细。认真</li></ul><h1 id="HyperApp-服务端配置"><a href="#HyperApp-服务端配置" class="headerlink" title="HyperApp 服务端配置"></a>HyperApp 服务端配置</h1><h2 id="安装-PostgreSQL"><a href="#安装-PostgreSQL" class="headerlink" title="安装 PostgreSQL"></a>安装 PostgreSQL</h2><p>虽然 HyperApp 提供了相应的 PostgreSQL 应用一键安装，但是由于安装 Tiny Tiny RSS 时无法与其衔接，所以一并使用 <code>Docker Image</code> 方法进行安装。</p><a id="more"></a><ol><li>转到商店页面。找到 <code>Docker Image</code> 然后选择服务器并且保存进入配置界面</li><li>请完全按照下图配置进行填写！</li></ol><table><thead><tr><th>应用设置名称</th><th>内容</th></tr></thead><tbody><tr><td>Image</td><td>sameersbn/postgresql:latest</td></tr><tr><td>Options</td><td><code>--restart=always -v /srv/docker/postgres/data/:/var/lib/postgresql/ -e PG_PASSWORD=mydbpass -e DB_EXTENSION=pg_trgm -p 5432:5432</code></td></tr><tr><td>Command</td><td></td></tr><tr><td>Args</td><td></td></tr><tr><td>其他</td><td>所有其他设置均为空</td></tr></tbody></table><h2 id="安装-Tiny-Tiny-RSS"><a href="#安装-Tiny-Tiny-RSS" class="headerlink" title="安装 Tiny Tiny RSS"></a>安装 Tiny Tiny RSS</h2><ol><li>转到商店页面。找到 <code>Docker Image</code> 然后选择服务器并且保存进入配置界面</li><li>请完全按照下图配置进行填写！</li></ol><table><thead><tr><th>应用设置名称</th><th>内容</th></tr></thead><tbody><tr><td>Image</td><td>wangqiru/ttrss</td></tr><tr><td>Options</td><td><code>--restart=always -e SELF_URL_PATH=https://你要给镜像站点的域名 -e DB_HOST=postgres -e DB_PORT=5432 -e DB_NAME=myttrss -e DB_USER=postgres -e DB_PASS=mydbpass</code></td></tr><tr><td>Command</td><td></td></tr><tr><td>Args</td><td></td></tr><tr><td>Nginx 设置名称</td><td>内容</td></tr><tr><td>域名</td><td>你要给镜像站点的域名</td></tr><tr><td>应用端口</td><td></td></tr><tr><td>Https</td><td>不重定向 HTTP 请求</td></tr><tr><td>域名</td><td>你要给镜像站点的域名（自动填写）</td></tr><tr><td>邮箱</td><td>域名所对应的邮箱</td></tr></tbody></table><ul><li>保存并且进行安装。请确保这时候 <code>Nginx Proxy</code> 以及 <code>Nginx SSL Support</code> 正常默认安装并且启动了</li></ul><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><p>安装 PostgreSQL 和 Tiny Tiny RSS 后还不能正常使用，还需要将两者连接起来。进入 VPS 的 SSH 窗口执行命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker network create ttrss_network</span><br><span class="line">docker container ls | grep wangqiru/ttrss | awk &apos;&#123;print $1&#125;&apos; | xargs docker network connect ttrss_network</span><br><span class="line">docker container ls | grep sameersbn/postgresql | awk &apos;&#123;print $1&#125;&apos; | xargs docker network connect ttrss_network</span><br><span class="line">docker container ls | grep wangqiru/ttrss | awk &apos;&#123;print $1&#125;&apos; | xargs docker restart</span><br></pre></td></tr></table></figure><p>上述命令建立了一个名为 <code>ttrss_network</code> 的 docker 通讯网络，并将 <code>ttrss</code> 容器和 <code>postgres</code> 容器都连接到这个网络内部。最后重启 Tiny Tiny RSS 容器。</p><h2 id="防火墙设置"><a href="#防火墙设置" class="headerlink" title="防火墙设置"></a>防火墙设置</h2><ul><li><p>CentOS</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --add-port=80/tcp --permanent</span><br><span class="line">firewall-cmd --add-port=443/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure></li><li><p>Ubuntu</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ufw allow 80</span><br><span class="line">sudo ufw allow 443</span><br></pre></td></tr></table></figure></li></ul><h1 id="配置使用-Tiny-Tiny-RSS"><a href="#配置使用-Tiny-Tiny-RSS" class="headerlink" title="配置使用 Tiny Tiny RSS"></a>配置使用 Tiny Tiny RSS</h1><h2 id="登录使用"><a href="#登录使用" class="headerlink" title="登录使用"></a>登录使用</h2><p><img src="https://i.loli.net/2019/02/26/5c74e8c180d1d.png" alt="Tiny Tiny RSS"></p><p>安装完成后，访问你给镜像站点设置的域名即可进入 Tiny Tiny RSS 登陆页面。默认账号是 <code>admin</code>，密码是 <code>password</code>。登录后务必修改密码。Tiny Tiny RSS 的其他设置技巧，可以参阅少数派的<a href="https://sspai.com/post/41302" target="_blank" rel="noopener">这篇文章</a>。</p><h2 id="全文输出"><a href="#全文输出" class="headerlink" title="全文输出"></a>全文输出</h2><p>一些网站并未提供完整的全文 RSS 源，而只提供了文章的摘要内容，阅读起来十分不便。作为 RSS 的重度用户，跳转到网站进行阅读实在是浪费时间。遇到这样的 RSS 源，除了可以使用内置了 Mercury 全文输出功能的客户端（iOS 平台 Reeder、Unread 等主流 RSS 阅读器支持）以外，还可以为自己搭建的 Tiny Tiny RSS 安装插件以支持 Mercury 功能。<br>下面还是使用 HyperApp 来操作，一步到位。</p><h3 id="安装-Mercury"><a href="#安装-Mercury" class="headerlink" title="安装 Mercury"></a>安装 Mercury</h3><ol><li>转到商店页面。找到 <code>Docker Image</code> 然后选择服务器并且保存进入配置界面</li><li>请完全按照下图配置进行填写！</li></ol><table><thead><tr><th>应用设置名称</th><th>内容</th></tr></thead><tbody><tr><td>Image</td><td>wangqiru/mercury-parser-api</td></tr><tr><td>Options</td><td><code>-p 3000:3000</code></td></tr><tr><td>Command</td><td></td></tr><tr><td>Args</td><td></td></tr><tr><td>其他</td><td>所有其他设置均为空</td></tr></tbody></table><h3 id="防火墙设置-1"><a href="#防火墙设置-1" class="headerlink" title="防火墙设置"></a>防火墙设置</h3><ul><li><p>CentOS</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --add-port=3000/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure></li><li><p>Ubuntu</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ufw allow 3000</span><br></pre></td></tr></table></figure></li></ul><h3 id="配置-Mercury-插件"><a href="#配置-Mercury-插件" class="headerlink" title="配置 Mercury 插件"></a>配置 Mercury 插件</h3><ol><li>登陆 Tiny Tiny RSS，进入偏好设置（Preferences） - 插件（Plugins），启用 mercury_fulltext 的插件</li><li>登陆 Tiny Tiny RSS，进入偏好设置（Preferences） - 信息源（Feeds） -  Mercury_fulltext settings (mercury_fulltext) 选项卡。填入 <code>http://你要给镜像站点的域名或IP地址:3000</code> ，保存配置</li></ol><h3 id="开始使用-Mercury"><a href="#开始使用-Mercury" class="headerlink" title="开始使用 Mercury"></a>开始使用 Mercury</h3><ol><li>首先正常订阅一个 RSS 源</li><li>在首页左侧导航或订阅源管理中找到需要获取全文的订阅源，点击编辑订阅源（Edit Feed）</li><li>进入编辑订阅源（Edit Feed）窗口中的插件（Plugins）选项卡，勾选 <code>Get fulltext via Mercury Parser</code></li></ol><p>设置完成后，Tiny Tiny RSS 将根据你的自定义设定，对特殊 RSS 源使用 Mercury 拉取全文内容后再生成 RSS 内容。这样可以摆脱客户端的限制，在任何客户端上都能直接浏览全文 RSS 的文章。</p><h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><ol><li><p>为何连接数据库的命令这么长？<br>之所以命令这么长是因为在使用 HyperApp 安装 <code>ttrss</code> 容器和 <code>postgres</code> 容器时没有为其指定容器的 name，所以必须通过查找其容器 ID 后再进行绑定。</p></li><li><p>为什么安装时不指定容器的 name？<br>指定容器的 name 可以方便连接数据库，但由于 HyperApp 是通过一定规则生成容器 name 从而对已安装的应用进行管理的，如果自定义了容器的 name，HyperApp 将无法正常识别到容器，安装应用后也会显示尚未安装。</p></li></ol><hr><p>参考链接：<br><a href="https://github.com/HenryQW/docker-ttrss-plugins" target="_blank" rel="noopener">Tiny Tiny RSS 容器镜像</a><br><a href="https://henry.wang/2018/04/25/ttrss-docker-plugins-guide.html" target="_blank" rel="noopener">A ttrss setup guide - Start your own RSS aggregator today</a><br><a href="https://sspai.com/post/41302" target="_blank" rel="noopener">如何搭建属于自己的 RSS 服务，高效精准获取信息</a><br><a href="https://www.hyperapp.fun/zh/advanced/docker-image-introduction.html" target="_blank" rel="noopener">Docker-image 介绍</a><br><a href="https://www.hyperapp.fun/zh/mirror.html" target="_blank" rel="noopener">超简单搭建常见 404 站点镜像</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;VPS 需要先安装好 &lt;code&gt;docker-ce&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://itunes.apple.com/app/apple-store/id1179750280?pt=118260435&amp;amp;ct=guide&amp;amp;mt=8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HyperApp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;一个已经解析正确的域名（ping 验证）&lt;/li&gt;
&lt;li&gt;耐心。仔细。认真&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;HyperApp-服务端配置&quot;&gt;&lt;a href=&quot;#HyperApp-服务端配置&quot; class=&quot;headerlink&quot; title=&quot;HyperApp 服务端配置&quot;&gt;&lt;/a&gt;HyperApp 服务端配置&lt;/h1&gt;&lt;h2 id=&quot;安装-PostgreSQL&quot;&gt;&lt;a href=&quot;#安装-PostgreSQL&quot; class=&quot;headerlink&quot; title=&quot;安装 PostgreSQL&quot;&gt;&lt;/a&gt;安装 PostgreSQL&lt;/h2&gt;&lt;p&gt;虽然 HyperApp 提供了相应的 PostgreSQL 应用一键安装，但是由于安装 Tiny Tiny RSS 时无法与其衔接，所以一并使用 &lt;code&gt;Docker Image&lt;/code&gt; 方法进行安装。&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="https://acuario.xyz/categories/%E6%95%99%E7%A8%8B/"/>
    
      <category term="软件使用" scheme="https://acuario.xyz/categories/%E6%95%99%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="教程" scheme="https://acuario.xyz/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Linux" scheme="https://acuario.xyz/tags/Linux/"/>
    
      <category term="docker" scheme="https://acuario.xyz/tags/docker/"/>
    
      <category term="HyperApp" scheme="https://acuario.xyz/tags/HyperApp/"/>
    
      <category term="Tiny Tiny RSS" scheme="https://acuario.xyz/tags/Tiny-Tiny-RSS/"/>
    
  </entry>
  
  <entry>
    <title>非常简单的Python3 HTTP服务</title>
    <link href="https://acuario.xyz/create-simple-http-server-with-python3/"/>
    <id>https://acuario.xyz/create-simple-http-server-with-python3/</id>
    <published>2019-02-26T06:35:09.000Z</published>
    <updated>2019-02-26T06:41:15.749Z</updated>
    
    <content type="html"><![CDATA[<p>多年前在<a href="http://weibo.com/haoel?s=6cm7D0" title="左耳朵耗子" target="_blank" rel="noopener">左耳朵耗子</a>的博客上看到<a href="https://coolshell.cn/articles/1480.html" target="_blank" rel="noopener">《非常简单的 PYTHON HTTP 服务》</a>一文，在急需建立 HTTP Server 的场合十分有用，比如临时分享文件之类。在 HTTP Server 访问的根目录下只需执行一行命令就能搞定：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python -m SimpleHTTPServer</span><br></pre></td></tr></table></figure></p><p>但是随着 Python 2 逐渐被 Python 3 取代，上述命令无法继续使用。在 Python3 中没有 <code>SimpleHTTPServer</code>，而是直接使用<code>http.server</code> 即可。所以对应的 Python 3 命令是：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 -m http.server</span><br></pre></td></tr></table></figure></p><p>默认开启的 HTTP Server 服务监听的是 8000 端口，使用时注意系统防火墙是否放行。如需使用其他端口，只需在命令末尾加上端口号即可，如使用端口 1234：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 -m http.server 1234</span><br></pre></td></tr></table></figure></p><h1 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h1><p>上述 Python 运行的 HTTP 服务器必须前台运行命令，并实时输出 log，断开终端后自动停止服务。这时可以借助 <code>nohup</code> 命令使其后台运行：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nohup python3 -m http.server &gt;&gt;/dev/null &amp;</span><br></pre></td></tr></table></figure></p><p>当然你也可以使用其他方法如 <code>screen</code> 等工具实现后台运行，再此就不赘述了。不过既然有更复杂的需要，那还是老老实实用 Nginx 吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;多年前在&lt;a href=&quot;http://weibo.com/haoel?s=6cm7D0&quot; title=&quot;左耳朵耗子&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;左耳朵耗子&lt;/a&gt;的博客上看到&lt;a href=&quot;https://coolshell.cn/a
      
    
    </summary>
    
      <category term="教程" scheme="https://acuario.xyz/categories/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Linux" scheme="https://acuario.xyz/categories/%E6%95%99%E7%A8%8B/Linux/"/>
    
    
      <category term="教程" scheme="https://acuario.xyz/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Linux" scheme="https://acuario.xyz/tags/Linux/"/>
    
      <category term="Python3" scheme="https://acuario.xyz/tags/Python3/"/>
    
      <category term="Python" scheme="https://acuario.xyz/tags/Python/"/>
    
      <category term="HTTP" scheme="https://acuario.xyz/tags/HTTP/"/>
    
      <category term="HTTP Server" scheme="https://acuario.xyz/tags/HTTP-Server/"/>
    
      <category term="Web服务器" scheme="https://acuario.xyz/tags/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="运维" scheme="https://acuario.xyz/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Linux各种包管理换国内源</title>
    <link href="https://acuario.xyz/replace-package-source-to-china-mirror/"/>
    <id>https://acuario.xyz/replace-package-source-to-china-mirror/</id>
    <published>2019-01-18T13:48:40.000Z</published>
    <updated>2019-01-18T14:11:07.734Z</updated>
    
    <content type="html"><![CDATA[<p>在国外的机器上开发倒是没什么麻烦事，也不用操心这么多。但是由于众所周知的原因，在天朝可就麻烦多了，不想点法子的话下载依赖就够摸鱼一下午了。这么多包管理，不碰不要紧，一碰要狗命（单押x1 XD<br>干脆把手头用的这几个记一下，免得以后查来查去麻烦。</p><h1 id="一键换源脚本"><a href="#一键换源脚本" class="headerlink" title="一键换源脚本"></a>一键换源脚本</h1><p>写完 yum 和 apt 的部分才想起来，这种常见的东西应该是有脚本可以搞定的吧。找了下果然有<a href="https://www.oldking.net/697.html" target="_blank" rel="noopener">大佬</a>写好了的。<br>如果只是 Linux 软件包的话就用一个脚本搞定：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget -qO- git.io/superupdate.sh | bash</span><br></pre></td></tr></table></figure></p><p>其他包管理的换源反正也不复杂，就手动弄一下。</p><a id="more"></a><hr><h1 id="YUM"><a href="#YUM" class="headerlink" title="YUM"></a>YUM</h1><p>使用 <a href="https://opsx.alibaba.com/mirror" target="_blank" rel="noopener">阿里镜像</a> 作镜像源</p><ol><li>备份原配置文件 <code>$ mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</code></li><li><p>换源（注意 OS Version）</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CentOS 6</span></span><br><span class="line"><span class="comment"># wget 方式获取</span></span><br><span class="line">$ wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo</span><br><span class="line"><span class="comment"># curl 方式获取</span></span><br><span class="line">$ curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo    </span><br><span class="line"></span><br><span class="line"><span class="comment"># CentOS 7</span></span><br><span class="line"><span class="comment"># wget 方式获取</span></span><br><span class="line">$ wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line"><span class="comment"># curl 方式获取</span></span><br><span class="line">$ curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br></pre></td></tr></table></figure></li><li><p>刷新 cache 生效 <code>$ yum makecache</code></p></li></ol><h1 id="APT"><a href="#APT" class="headerlink" title="APT"></a>APT</h1><p>使用 <a href="https://opsx.alibaba.com/mirror" target="_blank" rel="noopener">阿里镜像</a> 作镜像源</p><ol><li>备份原配置文件 <code>$ cp /etc/apt/sources.list /etc/apt/sources.list_backup</code></li><li>清空配置 <code>$ echo &quot;&quot; &gt; /etc/apt/sources.list</code></li><li>换源（注意按 OS Version 进行添加） <code>$ vim /etc/apt/sources.list</code> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu 14.04.5 LTS</span></span><br><span class="line">deb https://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse</span><br><span class="line">deb https://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse</span><br><span class="line">deb https://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"><span class="comment"># Ubuntu 16.04</span></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial main</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial main</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial universe</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security main</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security universe</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security universe</span><br><span class="line"></span><br><span class="line"><span class="comment"># Ubuntu 18.04(bionic)</span></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"><span class="comment"># Debian 7.x (wheezy)</span></span><br><span class="line">deb http://mirrors.aliyun.com/debian/ wheezy main non-free contrib</span><br><span class="line">deb http://mirrors.aliyun.com/debian/ wheezy-proposed-updates main non-free contrib</span><br><span class="line">deb-src http://mirrors.aliyun.com/debian/ wheezy main non-free contrib</span><br><span class="line">deb-src http://mirrors.aliyun.com/debian/ wheezy-proposed-updates main non-free contrib</span><br><span class="line"></span><br><span class="line"><span class="comment"># Debian 8.x (jessie)</span></span><br><span class="line">deb http://mirrors.aliyun.com/debian/ jessie main non-free contrib</span><br><span class="line">deb http://mirrors.aliyun.com/debian/ jessie-proposed-updates main non-free contrib</span><br><span class="line">deb-src http://mirrors.aliyun.com/debian/ jessie main non-free contrib</span><br><span class="line">deb-src http://mirrors.aliyun.com/debian/ jessie-proposed-updates main non-free contrib</span><br><span class="line"></span><br><span class="line"><span class="comment"># Debian 9.x (stretch)</span></span><br><span class="line">deb http://mirrors.aliyun.com/debian/ stretch main non-free contrib</span><br><span class="line">deb-src http://mirrors.aliyun.com/debian/ stretch main non-free contrib</span><br><span class="line">deb http://mirrors.aliyun.com/debian-security stretch/updates main</span><br><span class="line">deb-src http://mirrors.aliyun.com/debian-security stretch/updates main</span><br><span class="line">deb http://mirrors.aliyun.com/debian/ stretch-updates main non-free contrib</span><br><span class="line">deb-src http://mirrors.aliyun.com/debian/ stretch-updates main non-free contrib</span><br><span class="line">deb http://mirrors.aliyun.com/debian/ stretch-backports main non-free contrib</span><br><span class="line">deb-src http://mirrors.aliyun.com/debian/ stretch-backports main non-free contrib</span><br></pre></td></tr></table></figure></li></ol><h1 id="pip-pip3"><a href="#pip-pip3" class="headerlink" title="pip/pip3"></a>pip/pip3</h1><h2 id="永久换源"><a href="#永久换源" class="headerlink" title="永久换源"></a>永久换源</h2><p>使用 <a href="https://opsx.alibaba.com/mirror" target="_blank" rel="noopener">阿里镜像</a> 作镜像源<br>在配置文件中添加配置项 <code>vim ~/.pip/pip.conf</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://mirrors.aliyun.com/pypi/simple/</span><br><span class="line"></span><br><span class="line">[install]</span><br><span class="line">trusted-host=mirrors.aliyun.com</span><br></pre></td></tr></table></figure></p><h2 id="临时换源"><a href="#临时换源" class="headerlink" title="临时换源"></a>临时换源</h2><p>在使用 pip/pip3 命令安装软件时，在命令中添加参数 <code>-i https://mirrors.aliyun.com/pypi/simple/</code><br>例如升级 pip 的命令为：<code>pip install -U pip -i https://mirrors.aliyun.com/pypi/simple/</code></p><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p>使用 <a href="http://www.docker-cn.com/registry-mirror" target="_blank" rel="noopener">Docker 中国</a> 作镜像源<br>一般情况下修改配置文件<code>$ vim /etc/docker/daemon.json</code></p><p>添加下面配置项：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com/&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后重启 docker deamon 即可<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl daemon-reload</span><br><span class="line">$ systemctl restart docker</span><br></pre></td></tr></table></figure></p><p>如果是通过 snappy（Ubuntu 16.04+）安装的 docker 的话，配置文件路径和重启命令都不同，配置内容一样：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vim /var/snap/docker/current/config/daemon.json</span><br><span class="line">$ snap restart docker</span><br></pre></td></tr></table></figure></p><p>运行命令<code>$ docker info</code>，查看其中的配置项是否正确：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Registry Mirrors:</span><br><span class="line"> https://registry.docker-cn.com/</span><br></pre></td></tr></table></figure></p><p><a href="https://lug.ustc.edu.cn/wiki/mirrors/help/docker" target="_blank" rel="noopener">Docker 镜像使用帮助 [LUG@USTC]</a></p><h1 id="Composer"><a href="#Composer" class="headerlink" title="Composer"></a>Composer</h1><p>使用 <a href="https://pkg.phpcomposer.com/" target="_blank" rel="noopener">Packagist</a> 作镜像源</p><h2 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h2><p>任意目录下执行下例命令即可：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ composer config -g repo.packagist composer https://packagist.phpcomposer.com</span><br></pre></td></tr></table></figure></p><h2 id="单个项目配置"><a href="#单个项目配置" class="headerlink" title="单个项目配置"></a>单个项目配置</h2><p>进入项目目录 <code>dir</code> 执行命令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ composer config repo.packagist composer https://packagist.phpcomposer.com</span><br></pre></td></tr></table></figure></p><h1 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h1><p>使用 <a href="https://npm.taobao.org/" target="_blank" rel="noopener">淘宝 NPM 镜像</a> 作镜像源<br>使用淘宝 NPM 定制的 <a href="https://github.com/cnpm/cnpm" target="_blank" rel="noopener">cnpm</a> (gzip 压缩支持) 命令行工具代替默认的 <code>npm</code>:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>或者通过添加 <code>npm</code> 参数 <code>alias</code> 一个新命令:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">alias</span> cnpm=<span class="string">"npm --registry=https://registry.npm.taobao.org \</span></span><br><span class="line"><span class="string">--cache=<span class="variable">$HOME</span>/.npm/.cache/cnpm \</span></span><br><span class="line"><span class="string">--disturl=https://npm.taobao.org/dist \</span></span><br><span class="line"><span class="string">--userconfig=<span class="variable">$HOME</span>/.cnpmrc"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Or alias it in .bashrc or .zshrc</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">'\n#alias for cnpm\nalias cnpm="npm --registry=https://registry.npm.taobao.org \</span></span><br><span class="line"><span class="string">  --cache=$HOME/.npm/.cache/cnpm \</span></span><br><span class="line"><span class="string">  --disturl=https://npm.taobao.org/dist \</span></span><br><span class="line"><span class="string">  --userconfig=$HOME/.cnpmrc"'</span> &gt;&gt; ~/.zshrc &amp;&amp; <span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在国外的机器上开发倒是没什么麻烦事，也不用操心这么多。但是由于众所周知的原因，在天朝可就麻烦多了，不想点法子的话下载依赖就够摸鱼一下午了。这么多包管理，不碰不要紧，一碰要狗命（单押x1 XD&lt;br&gt;干脆把手头用的这几个记一下，免得以后查来查去麻烦。&lt;/p&gt;
&lt;h1 id=&quot;一键换源脚本&quot;&gt;&lt;a href=&quot;#一键换源脚本&quot; class=&quot;headerlink&quot; title=&quot;一键换源脚本&quot;&gt;&lt;/a&gt;一键换源脚本&lt;/h1&gt;&lt;p&gt;写完 yum 和 apt 的部分才想起来，这种常见的东西应该是有脚本可以搞定的吧。找了下果然有&lt;a href=&quot;https://www.oldking.net/697.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;大佬&lt;/a&gt;写好了的。&lt;br&gt;如果只是 Linux 软件包的话就用一个脚本搞定：&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ wget -qO- git.io/superupdate.sh | bash&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其他包管理的换源反正也不复杂，就手动弄一下。&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="https://acuario.xyz/categories/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Linux" scheme="https://acuario.xyz/categories/%E6%95%99%E7%A8%8B/Linux/"/>
    
    
      <category term="教程" scheme="https://acuario.xyz/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Linux" scheme="https://acuario.xyz/tags/Linux/"/>
    
      <category term="docker" scheme="https://acuario.xyz/tags/docker/"/>
    
      <category term="包管理" scheme="https://acuario.xyz/tags/%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    
      <category term="换源" scheme="https://acuario.xyz/tags/%E6%8D%A2%E6%BA%90/"/>
    
      <category term="国内源" scheme="https://acuario.xyz/tags/%E5%9B%BD%E5%86%85%E6%BA%90/"/>
    
      <category term="镜像源" scheme="https://acuario.xyz/tags/%E9%95%9C%E5%83%8F%E6%BA%90/"/>
    
      <category term="npm" scheme="https://acuario.xyz/tags/npm/"/>
    
      <category term="composer" scheme="https://acuario.xyz/tags/composer/"/>
    
      <category term="yum" scheme="https://acuario.xyz/tags/yum/"/>
    
      <category term="apt-get" scheme="https://acuario.xyz/tags/apt-get/"/>
    
      <category term="pip" scheme="https://acuario.xyz/tags/pip/"/>
    
      <category term="pip3" scheme="https://acuario.xyz/tags/pip3/"/>
    
      <category term="一键换源" scheme="https://acuario.xyz/tags/%E4%B8%80%E9%94%AE%E6%8D%A2%E6%BA%90/"/>
    
      <category term="脚本" scheme="https://acuario.xyz/tags/%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>如何优雅地找资源</title>
    <link href="https://acuario.xyz/how-to-get-source/"/>
    <id>https://acuario.xyz/how-to-get-source/</id>
    <published>2018-11-09T17:16:52.000Z</published>
    <updated>2019-02-26T05:43:38.666Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/11/10/5be5c84f8f10e.jpg" alt></p><p>其实在网络上需要查找一些什么资源并不像我们想象的那样难。如果学会利用搜索引擎，再加上几个好用的、值得信赖的网站，基本上可以事半功倍。所以对于普通人来说，做一个「资源帝」其实只是需要一个手册和方法论的指导而已。<br>著名的资源帝<a href="http://shedingkong.lofter.com/tag/%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90" target="_blank" rel="noopener">设定控</a>提供的各类手册当然十分完美，但是我们实际用不到如此多的网站。除非你是松鼠症患者，有收集整理的心理刚需，否则资源手册的噪音大过实际效益。</p><p>这篇水分满满的文章也仅仅只是梳理一下笔者的资源搜索路径，按照几个主要的资源类型进行展开，顺便配上一些评（fei）论（hua），以供各位参考，基本上能搞定 80% 的书、影、音需求。</p><p>p.s. 关于文中的软件推荐，均以 Windows 为平台，暂未收录 macOS 相关软件。</p><a id="more"></a><h1 id="电子书"><a href="#电子书" class="headerlink" title="电子书"></a>电子书</h1><h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><ul><li><p><a href="http://www.mlook.mobi/" target="_blank" rel="noopener">mLook</a><br>mLook 可以应付绝大多数的电子书需求，但是<strong>已经关闭开放注册</strong>。</p></li><li><p><a href="https://sk.kindleshare.cn/" target="_blank" rel="noopener">KindleShare</a><br>电子书搜索引擎 KindleShare 也还是不错的。</p></li><li><p><a href="http://readfree.me" target="_blank" rel="noopener">readfree</a><br>readfree 是我在众多书签中发掘到的质量上乘的付费下载网站，充值 10￥可以下载 1k 次，或者靠自己上传书籍的下载量来获取下载次数。我搜了几本书都有资源，当作备用网站不妨一试。</p></li><li><p><a href="https://www.easysearch.com.tw/" target="_blank" rel="noopener">EasySearch</a><br>EasySearch 是<a href="https://www.ymdie.com/archives/32219" target="_blank" rel="noopener">港台电子书</a>的搜索引擎，支持搜索博客來、<a href="https://www.kobo.com/tw/zh" target="_blank" rel="noopener">乐天 Kobo</a>、<a href="https://readmoo.com/" target="_blank" rel="noopener">读墨 Readmoo</a>、Taaze、Google Play 的电子书商品信息，你可以在上述网站购买电子书，使用各平台的客户端进行阅读。如果你想在 Kindle 上阅读 Kobo 商城购买的电子书，你可以按照<a href="https://twitter.com/yhyy135/status/1028389615730917376" target="_blank" rel="noopener">这个教程</a>进行操作。</p></li><li><p>Telegram 频道<br>如果你使用 <a href="https://telegram.org/" target="_blank" rel="noopener">Telegram</a> 的话（已被封锁），这里提供几个分享电子书的 Telegram 频道：<br><a href="https://t.me/zebookpush" target="_blank" rel="noopener">kindle电子书读书会</a>：频道每天据群友请求推书。只推原版无损高质 kindle 电子书。需要书时，直接前往<a href="https://t.me/zebook" target="_blank" rel="noopener">Telegram 群组</a>求书即可。<br><a href="https://t.me/booksforeverybody" target="_blank" rel="noopener">书籍分享</a><br><a href="https://t.me/free_programming_books" target="_blank" rel="noopener">电子书支援计划_技术分享</a>：分享技术类书籍为主</p></li></ul><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><ul><li><p><a href="https://calibre-ebook.com/" target="_blank" rel="noopener">Calibre</a><br>Calibre 是使用 Kindle 的人必备的软件，可以把 mobi、epub、awz3、txt、pdf 等各种格式的电子书进行转换。</p></li><li><p><a href="https://www.sumatrapdfreader.org/free-pdf-reader.html" target="_blank" rel="noopener">SumatraPDF</a><br>SumatraPDF 是我在 Windows 上主要使用的电子阅读器，软件体积很小，而且可以打开 mobi、epub、azw3，满足了我日常所需。使用时，建议将<code>菜单 - 设置 - 高级选项</code>内的 <code>EbookUI - UseFixedPageUI</code> 值设为 <code>true</code>，否则无法在阅读时选中文本。</p></li></ul><h1 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h1><p>好像已经毫无疑问地迈入流媒体时代了，很久没有再下载过 mp3 文件，然后耐心维护本地曲库了。除非实在喜欢的音乐不妨下载一份在本地备用。</p><h2 id="网站-1"><a href="#网站-1" class="headerlink" title="网站"></a>网站</h2><ul><li><p><a href="https://zaihua.io/music/" target="_blank" rel="noopener">在花音乐搜索神器</a><br>该音乐搜索引擎支持网易、QQ、酷狗、酷我、虾米、百度、一听、咪咕、荔枝、蜻蜓、喜马拉雅、全民 K 歌、5sing。搜索后可试听、下载。音乐品质未知。</p></li><li><p><a href="https://lai.yuweining.cn/music" target="_blank" rel="noopener">音乐搜索神器</a><br>看样式应该和上面那个网站差不多。该音乐搜索引擎支持网易、QQ、酷狗、虾米、百度、咪咕。搜索后可试听、下载。音乐品质未知。</p></li><li><p><a href="https://pan.baidu.com/" target="_blank" rel="noopener">百度云</a><br>百度云依旧是文件分享的聚集地，利用<a href="http://www.xilinjie.com/" target="_blank" rel="noopener">西林街</a>和<a href="http://www.panc.cc/" target="_blank" rel="noopener">胖次</a>进行资源搜索以后，多半可以找到自己需要的资源。当然这两个网盘搜索引擎<strong>不仅限于查找音乐资源</strong>。</p></li><li><p><a href="http://www.mlook.mobi/" target="_blank" rel="noopener">OppsU!</a><br>站内有大量网友分享的正版专辑文件，多以 iTunes 的专辑文件为主。当然也由于版权和一些众所周知的原因，该网站注册门槛非常高，只有每年特定时间才会开放注册。</p></li></ul><h2 id="软件-1"><a href="#软件-1" class="headerlink" title="软件"></a>软件</h2><ul><li><p><a href="https://music.163.com/" target="_blank" rel="noopener">网易云音乐</a><br>在民谣、电音、翻唱方面，网易云的资源还是比较丰富的，免费流播，付费下载，可备不时之需。想要下载网易云的音乐拷贝到其他设备上听，但是现在网易云的音乐有自己的 NCM 格式怎么办？不妨试试<a href="https://github.com/yoki123/ncmdump" target="_blank" rel="noopener">这个项目</a>的工具来去除音乐文件的保护，还原成正常的 mp3。</p></li><li><p><a href="https://www.spotify.com/" target="_blank" rel="noopener">Spotify</a><br>这是笔者目前主力使用的流媒体音乐平台。需付费（按区域选择不同，<a href="http://mts.io/projects/spotify-pricing/" target="_blank" rel="noopener">价格不同</a>），跨平台，曲库以非华语音乐为主，当然主流的华语音乐也够应付大多数需求。</p></li></ul><h1 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h1><h2 id="网站-2"><a href="#网站-2" class="headerlink" title="网站"></a>网站</h2><h3 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h3><ul><li><p><a href="http://yyets.com/" target="_blank" rel="noopener">人人字幕组</a><br>人人字幕组毫无疑问是国内数一数二的字幕组。字幕样式和翻译功底都算上乘。官网提供了各平台客户端的下载链接，以及相关网站的链接。</p></li><li><p><a href="http://www.zimuzu.io/" target="_blank" rel="noopener">人人影视资源下载站</a><br>下载站的网址非常好记：<code>zimuzu.io</code>。免费注册会员，每日签到进行升级，除特殊影片可能会有等级限制查看，其他正常资源一律免费提供下载链接，登录后即可查看下载链接。</p></li><li><p><a href="http://cili001.com/" target="_blank" rel="noopener">磁力站</a><br>由于众所周知的原因，一部分资源不能在人人影视资源下载站提供下载，甚至不能提供下载链接，所以磁力站作为第三方搜索引擎，其数据基本涵盖了所有人人影视新旧资源的下载链接。你可以在这里找到几乎所有在人人影视字幕组发布过的资源链接。</p></li><li><p><a href="http://www.dysfz.cc/" target="_blank" rel="noopener">电影首发站</a><br>该站提供大量电影下载链接，无需注册，完全免费，使用迅雷等下载工具即可正常下载。笔者主要用来下载国产电影，该站也提供其他影视资源。</p></li></ul><h3 id="美剧"><a href="#美剧" class="headerlink" title="美剧"></a>美剧</h3><ul><li><a href="http://www.zimuzu.io/" target="_blank" rel="noopener">人人影视资源下载站</a><br>人人字幕组除了提供含有中文字幕的电影下载之外，还有丰富的美剧资源。</li></ul><h3 id="纪录片"><a href="#纪录片" class="headerlink" title="纪录片"></a>纪录片</h3><p><a href="https://space.bilibili.com/22121599/#/" target="_blank" rel="noopener">哔哩哔哩-纪录片之家</a><br>哔哩哔哩站内有很多纪录片，而且很多视频的弹幕已经有野生翻译君助力。你可以在纪录片之家的 B 站首页进行查找，然后在线观看。</p><ul><li><p><a href="http://www.daolan.net/index.php" target="_blank" rel="noopener">道兰同好会</a><br>该站是一个纪录片译制论坛，主要译制 NHK 纪录片。</p></li><li><p><a href="https://kamonka.blogspot.com/" target="_blank" rel="noopener">NHK纪录片精选</a><br>NHK（日本放送协会）制作和播放的纪录片，由国内爱好者翻译制作，可直接下载，无需注册。P.S. 该网站已被审查封锁</p></li></ul><h3 id="动漫"><a href="#动漫" class="headerlink" title="动漫"></a>动漫</h3><ul><li><a href="http://share.dmhy.org/" target="_blank" rel="noopener">动漫花园</a><br>一个朋友介绍给我的追番站点。不过如果你是 ACG 人士，应该也不需要我过多介绍。</li></ul><h2 id="软件-2"><a href="#软件-2" class="headerlink" title="软件"></a>软件</h2><ul><li><p><a href="https://potplayer.daum.net/" target="_blank" rel="noopener">PotPlayer</a><br>万能播放器。没有它打不开的视频文件，如果有，那多半是文件坏了。笔者有且只用它作为视频播放工具。</p></li><li><p>百度云文件下载软件<br>众所周知百度云非 VIP 会员有下载限速。这里提供三款不限速的下载软件。为了避免怀孕，建议以自己的小号登录使用。笔者使用的是 PanDownload，非常好用，下载速度非常快，首推。<br><a href="http://pandownload.com/" target="_blank" rel="noopener">PanDownload</a><br><a href="http://www.speedpan.com/" target="_blank" rel="noopener">速盘</a><br><a href="https://github.com/proxyee-down-org/proxyee-down" target="_blank" rel="noopener">Proxyee Down</a></p></li></ul><p>暂时写这么多，如果你有什么好的推荐不妨在评论区留言交流。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/10/5be5c84f8f10e.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;其实在网络上需要查找一些什么资源并不像我们想象的那样难。如果学会利用搜索引擎，再加上几个好用的、值得信赖的网站，基本上可以事半功倍。所以对于普通人来说，做一个「资源帝」其实只是需要一个手册和方法论的指导而已。&lt;br&gt;著名的资源帝&lt;a href=&quot;http://shedingkong.lofter.com/tag/%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;设定控&lt;/a&gt;提供的各类手册当然十分完美，但是我们实际用不到如此多的网站。除非你是松鼠症患者，有收集整理的心理刚需，否则资源手册的噪音大过实际效益。&lt;/p&gt;
&lt;p&gt;这篇水分满满的文章也仅仅只是梳理一下笔者的资源搜索路径，按照几个主要的资源类型进行展开，顺便配上一些评（fei）论（hua），以供各位参考，基本上能搞定 80% 的书、影、音需求。&lt;/p&gt;
&lt;p&gt;p.s. 关于文中的软件推荐，均以 Windows 为平台，暂未收录 macOS 相关软件。&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="https://acuario.xyz/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="https://acuario.xyz/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="mp3" scheme="https://acuario.xyz/tags/mp3/"/>
    
      <category term="资源" scheme="https://acuario.xyz/tags/%E8%B5%84%E6%BA%90/"/>
    
      <category term="美剧" scheme="https://acuario.xyz/tags/%E7%BE%8E%E5%89%A7/"/>
    
      <category term="电影" scheme="https://acuario.xyz/tags/%E7%94%B5%E5%BD%B1/"/>
    
      <category term="资源帝" scheme="https://acuario.xyz/tags/%E8%B5%84%E6%BA%90%E5%B8%9D/"/>
    
      <category term="找资源" scheme="https://acuario.xyz/tags/%E6%89%BE%E8%B5%84%E6%BA%90/"/>
    
      <category term="电子书" scheme="https://acuario.xyz/tags/%E7%94%B5%E5%AD%90%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>回忆就像衣柜里的春夏秋冬</title>
    <link href="https://acuario.xyz/memory-of-Aug/"/>
    <id>https://acuario.xyz/memory-of-Aug/</id>
    <published>2018-09-06T14:33:56.000Z</published>
    <updated>2018-09-06T20:24:48.081Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/09/07/5b9159755c82a.png" alt="Electric July"></p><p>特别喜欢这张<a href="https://movie.douban.com/subject/26312156/" target="_blank" rel="noopener">电影</a>画面，或许是因为正好自己的经历和电影如此的相映成趣，好像自己就站在那个田野里，静静地看着远方。因为自己心里的那个人或许已经再没有办法陪伴在自己的身边，而自己也无力去攀上通向远方的断桥。</p><a id="more"></a><p>当阳光洒在脸颊和手臂上的时候，当雨水淋湿衣袖的时候，增添的有可能是温暖和冰冷的回忆，也有可能只是在博客文章里寥寥的几笔。温度的差异，提醒自己的不是谁喜欢着谁，而是那个当下，你真真切切地和谁在一起。因为有了不一样的经历，所以它才能够像是收在柜子里的衣服那样，任着自己的性子取出那些让自己喜欢的和不喜欢的，然后花点心思慢慢更衣。最后在别人眼里，看到的其实是自己想要让人看到的衣冠，而那些丑陋的行迹，终究只能自己一个人去思考与犹豫。</p><p>回忆就像衣柜里的春夏秋冬，那些久久没有临幸的外衣，渐渐生出了令人厌恶的霉点。因为家乡四季如春，没有令人难受的湿气，所以面对发了霉的东西慌了阵脚、不知所措，索性把它们一件一件摊开来，检视它们的每一个细节，然后一声叹息。挑三拣四后的思绪一团乱麻，索性全都扔进洗衣机，好好洗涤一番。</p><p>亦或是长了教训，把它们一件一件展开来，找个衣架挨个挂起来晾晒一番。却在这时候才发现那些经不住时间考验的回忆，已经开始泛黄，任凭我怎么漂白，依旧褪不去历史的影子。最怕的应该是心爱的那件回忆上，不知什么时候破了洞，已经再也没有办法补齐，只能任由它这样下去，或者再一声叹息，就这样将其丢弃。</p><p>朋友戏谑我说：</p><blockquote><p>你已经可以写“八月，又溜走了”</p></blockquote><p>我什么也没有说，多半不是因为我没法正面回应自己的拖延，而是因为自己心里的八月还没有结束。</p><blockquote><p>这个八月，我到底在做什么？</p></blockquote><p>我一遍遍这样问自己，发现其实心里的答案早就如此明晰，只是我不愿承认与接受而已。如果要认真解释的话，那多半是因为夏日初秋时分，我拥有了和电影里如出一辙的悸动与情愫。在这段感情里，我试着在探寻「自我」的意识与定义，就像听到的那期<a href="http://cxks.in/16?t=720" target="_blank" rel="noopener">播客</a>里说，<code>理解某一刻的情绪，或许不像解题目一样可以获得确定的答案；对某一个情绪的理解，最后可能是对情绪状态中对自我的关注，是一整幅拼图中的一个碎片。当我们关注到越来越多的碎片，我们就会越来越感受到自我</code>。我好像越发明白在感情中成长所指的意义——我们总是感谢一些人一些事，教会我们了什么道理，实际上在人与人的互动关系中，更多的是自我的体察与反思，最终得出或利己或利他的选择。当自己真真切切地失去的时候，才会比得到的时候更加透彻地领悟某些老生常谈的道理。于是说到底，<strong>有些道理，毕竟还是需要自己经历过的才会明白。在自己亲历之前，别人说再多次也不以为意。</strong></p><p>一个人的夜晚，身体已经十分疲惫，却还是不愿睡去。不同于以往的无聊与烦躁，现时最不愿面对的，是睡眠带来的安稳——平日渴求的安逸，没什么值得被记忆和记录的；而现在的我却如此害怕闭上双眼进入梦乡的时候，回忆的气泡慢慢破碎，等我醒来的时候一个也不剩。在我拼命想要去写下些什么东西的时候，思来想去的结果，除了矫情，好像也难以道出什么心情。在旁人看来无所谓的事情，终究只有自己才知道它放在心里的什么位置。经常想起马伊俐在<a href="https://v.youku.com/v_show/id_XMjkxODg4MDM1Ng==.html" target="_blank" rel="noopener">《圆桌派》</a>里对「作」的举例，于是在自己身上发现了印证——<em>永不安分，永不知足，永远折腾，永远没完</em>。也许是自己还没长大吧，不过又有谁心甘情愿地承认自己是巨婴罢？</p><p>九月已经过去了几个白昼，可对于我来说，八月才刚刚结束。</p><p>八月，与其说是溜走了，不如说，是我还没来得及告别，就只能眼睁睁看着他的背影渐渐远去。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/09/07/5b9159755c82a.png&quot; alt=&quot;Electric July&quot;&gt;&lt;/p&gt;
&lt;p&gt;特别喜欢这张&lt;a href=&quot;https://movie.douban.com/subject/26312156/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;电影&lt;/a&gt;画面，或许是因为正好自己的经历和电影如此的相映成趣，好像自己就站在那个田野里，静静地看着远方。因为自己心里的那个人或许已经再没有办法陪伴在自己的身边，而自己也无力去攀上通向远方的断桥。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://acuario.xyz/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://acuario.xyz/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>V2ray配置Telegram的MTProto协议</title>
    <link href="https://acuario.xyz/set-mtproto-for-telegram-via-v2ray/"/>
    <id>https://acuario.xyz/set-mtproto-for-telegram-via-v2ray/</id>
    <published>2018-08-15T22:58:28.000Z</published>
    <updated>2019-01-18T13:32:34.072Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>V2ray 是继 ShadowSocks 后又一个蓬勃发展、欣欣向荣的代理利器，目前支持多种传输协议。现在可以使用它设置 MTProto 协议，搭建 Telegram 的内部代理服务器，实现无需打开其他突破网络封锁的客户端即可正常通讯的目的。</p><h1 id="V2ray-的代理原理"><a href="#V2ray-的代理原理" class="headerlink" title="V2ray 的代理原理"></a>V2ray 的代理原理</h1><p>v2ray 的代理原理和配置项的关系如下图：<br><img src="https://i.loli.net/2018/08/15/5b73c180d5ef0.png" alt="v2ray原理图及配置关系"></p><p>p.s.上图为 v2ray v4.0 之前的代理原理图。v2ray v4.1+ 合并了输入输出配置项：</p><ul><li><code>inbounds = inbound + inboundDetour</code></li><li><code>outbounds = outbound + outboundDetour</code></li><li>为便于理解，你可以将上图 <code>inbound</code>、<code>inboundDetour</code> 视为各种不同的代理方式，全部定义在新版配置文件的 <code>inbounds</code> 配置项中，<code>outbounds</code> 亦同理。</li></ul><a id="more"></a><p>v2ray 的的配置格式都是相同的，理论上不区分客户端和服务端，<code>客户端和服务器通用一种形式，只是实际的配置不一样。</code>v2ray 配置文件的配置项有以下几个部分：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;log&quot;: &#123;&#125;,</span><br><span class="line">  &quot;api&quot;: &#123;&#125;,</span><br><span class="line">  &quot;dns&quot;: &#123;&#125;,</span><br><span class="line">  &quot;stats&quot;: &#123;&#125;,</span><br><span class="line">  &quot;routing&quot;: &#123;&#125;,</span><br><span class="line">  &quot;policy&quot;: &#123;&#125;,</span><br><span class="line">  &quot;reverse&quot;: &#123;&#125;,</span><br><span class="line">  &quot;inbounds&quot;: [],</span><br><span class="line">  &quot;outbounds&quot;: [],</span><br><span class="line">  &quot;transport&quot;: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们重点关注其中传入、传出和路由配置，即：<code>inbounds</code>、<code>outbounds</code>、<code>routing</code>。</p><ul><li><code>inbounds</code> 和 <code>outbounds</code> 定义多种不同的传入、传出方式。</li><li>自定义不同的传入和传出方式，然后用路由（<code>routing</code>）进行绑定，就可以实现定制化代理。</li></ul><p>下面举几个栗子：</p><ol><li>仅用来突破网络封锁：客户端 <code>outbounds</code> 设置一个 VMess 协议传出、服务端 <code>inbounds</code> 设置一个 VMess 协议传入，服务端 <code>outbounds</code> 设置一个 freedom 方式传出。这样，客户端与服务端将使用 VMess 协议加密流量突破网络封锁，而服务端访问被封锁网站没有特殊加密，使用正常网络传输协议。</li><li>服务端配置其他的传入、传出协议实现不同于的传输需求。比如服务端添加一组 MTProto 协议对应的传入、传出方式，即可以使用 Telegram 内部代理。或者使用 shadowsocks 协议传入，再用 vmess 协议传出给下一个服务端，实现多级代理等等。</li><li>多种传入、传出方式可以共存，打上标签（<code>tag</code>）以后，用路由（<code>routing</code>）实现自由绑定，所以仅使用 v2ray 就可实现多种方式的传输需求，比如同时支持 VMess、Shadowsocks、MTProto、Socks 协议进行通讯。v2ray 支持<a href="https://www.v2ray.com/chapter_02/02_protocols.html" target="_blank" rel="noopener">多种协议</a>，发挥你的创造性去使用吧。</li></ol><h1 id="MTProto-的配置"><a href="#MTProto-的配置" class="headerlink" title="MTProto 的配置"></a>MTProto 的配置</h1><p>v2ray 的<a href="https://www.v2ray.com/chapter_02/protocols/mtproto.html" target="_blank" rel="noopener">官方手册</a>提供了不完整的样例配置</p><h2 id="传入代理"><a href="#传入代理" class="headerlink" title="传入代理"></a>传入代理</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"inbounds": [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"tag"</span>: <span class="string">"tg-in"</span>,</span><br><span class="line">    <span class="attr">"port"</span>: <span class="number">443</span>,</span><br><span class="line">    <span class="attr">"protocol"</span>: <span class="string">"mtproto"</span>,</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;</span><br><span class="line">      <span class="attr">"users"</span>: [&#123;<span class="attr">"secret"</span>: <span class="string">"b0cbcef5a486d9636472ac27f8e11a9d"</span>&#125;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>传出代理：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"outbounds": [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"tag"</span>: <span class="string">"tg-out"</span>,</span><br><span class="line">    <span class="attr">"protocol"</span>: <span class="string">"mtproto"</span>,</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>路由：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"routing": &#123;</span><br><span class="line">  "rules": [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"field"</span>,</span><br><span class="line">      <span class="attr">"inboundTag"</span>: [</span><br><span class="line">        <span class="string">"tg-in"</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"outboundTag"</span>: <span class="string">"tg-out"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="配置文件示例"><a href="#配置文件示例" class="headerlink" title="配置文件示例"></a>配置文件示例</h1><p>这里提供一个主要使用 VMess 协议突破网络封锁，额外支持 MTProto 协议实现 Telegram 内部代理的配置文件，其中：</p><ul><li>服务端设置的端口务必加入服务器防火墙例外，否则可能无法正常连接</li><li>UUID 可以在 <a href="https://www.uuidgenerator.net/" target="_blank" rel="noopener">Online UUID Generator</a> 网站生成</li><li>用户密钥可以使用命令 <code>openssl rand -hex 16</code> 生成</li></ul><h2 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"inbounds"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"port"</span>: 填写 VMess 协议监听端口,</span><br><span class="line">      ,</span><br><span class="line">      "protocol": "vmess",</span><br><span class="line">      "settings": &#123;</span><br><span class="line">        "clients": [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"id"</span>: <span class="string">"填写UUID，不要去掉引号"</span>,</span><br><span class="line">            <span class="attr">"level"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"alterId"</span>: <span class="number">64</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"tag"</span>: <span class="string">"tg-in"</span>,</span><br><span class="line">      <span class="attr">"listen"</span>: <span class="string">"0.0.0.0"</span>,</span><br><span class="line">      <span class="attr">"port"</span>: 填写 MTProto 协议监听端口,</span><br><span class="line">      <span class="attr">"protocol"</span>: <span class="string">"mtproto"</span>,</span><br><span class="line">      <span class="attr">"settings"</span>: &#123;</span><br><span class="line">        <span class="attr">"users"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"secret"</span>: <span class="string">"填写用户密钥，不要去掉引号"</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  "outbounds": [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"protocol"</span>: <span class="string">"freedom"</span>,</span><br><span class="line">      <span class="attr">"settings"</span>: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"protocol"</span>: <span class="string">"blackhole"</span>,</span><br><span class="line">      <span class="attr">"settings"</span>: &#123;&#125;,</span><br><span class="line">      <span class="attr">"tag"</span>: <span class="string">"blocked"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"tag"</span>: <span class="string">"tg-out"</span>,</span><br><span class="line">      <span class="attr">"protocol"</span>: <span class="string">"mtproto"</span>,</span><br><span class="line">      <span class="attr">"settings"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  "routing": &#123;</span><br><span class="line">    "rules": [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"field"</span>,</span><br><span class="line">        <span class="attr">"ip"</span>: [</span><br><span class="line">          <span class="string">"geoip:private"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"outboundTag"</span>: <span class="string">"blocked"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"field"</span>,</span><br><span class="line">        <span class="attr">"inboundTag"</span>: [</span><br><span class="line">          <span class="string">"tg-in"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"outboundTag"</span>: <span class="string">"tg-out"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Telegram-内部代理设置"><a href="#Telegram-内部代理设置" class="headerlink" title="Telegram 内部代理设置"></a>Telegram 内部代理设置</h2><p>将服务器的 IP 地址、配置的 MTProto 协议监听端口、用户密钥填入 Telegram 的代理设置中即可使用。或者使用构造链接在 Telegram 内部打开进行自动设置：</p><p><code>https://t.me/proxy?server=服务器IP地址&amp;port=服务器MTProto协议监听端口&amp;secret=用户密钥</code></p><h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"inbounds"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"port"</span>: <span class="number">1082</span>,</span><br><span class="line">      <span class="attr">"listen"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">      <span class="attr">"protocol"</span>: <span class="string">"socks"</span>,</span><br><span class="line">      <span class="attr">"settings"</span>: &#123;</span><br><span class="line">        <span class="attr">"auth"</span>: <span class="string">"noauth"</span>,</span><br><span class="line">        <span class="attr">"udp"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"ip"</span>: <span class="string">"127.0.0.1"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"outbounds"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"protocol"</span>: <span class="string">"vmess"</span>,</span><br><span class="line">      <span class="attr">"settings"</span>: &#123;</span><br><span class="line">        <span class="attr">"vnext"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"users"</span>: [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">"alterId"</span>: <span class="number">64</span>,</span><br><span class="line">                <span class="attr">"security"</span>: <span class="string">"auto"</span>,</span><br><span class="line">                <span class="attr">"id"</span>: <span class="string">"填写 UUID 与服务端一致，不要去掉引号"</span></span><br><span class="line">              &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"port"</span>: 服务端 VMess 协议监听端口,</span><br><span class="line">            <span class="attr">"address"</span>: <span class="string">"服务端 IP 地址，可以去掉引号"</span>,</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"protocol"</span>: <span class="string">"freedom"</span>,</span><br><span class="line">      <span class="attr">"settings"</span>: &#123;&#125;,</span><br><span class="line">      <span class="attr">"tag"</span>: <span class="string">"direct"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"protocol"</span>: <span class="string">"blackhole"</span>,</span><br><span class="line">      <span class="attr">"settings"</span>: &#123;&#125;,</span><br><span class="line">      <span class="attr">"tag"</span>: <span class="string">"blocked"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"routing"</span>: &#123;</span><br><span class="line">    <span class="attr">"rules"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"field"</span>,</span><br><span class="line">        <span class="attr">"ip"</span>: [</span><br><span class="line">          <span class="string">"geoip:private"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"outboundTag"</span>: <span class="string">"direct"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"field"</span>,</span><br><span class="line">        <span class="attr">"domain"</span>: [</span><br><span class="line">          <span class="string">"geosite:cn"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"outboundTag"</span>: <span class="string">"direct"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"log"</span>: &#123;</span><br><span class="line">    <span class="attr">"loglevel"</span>: <span class="string">"warning"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考链接：<br><a href="https://www.v2ray.com/chapter_02/01_overview.html" target="_blank" rel="noopener">v2ray 配置文件格式</a><br><a href="https://ntgeralt.blogspot.com/2018/08/telegramv2raymtproxy.html" target="_blank" rel="noopener">让 Telegram 连接 V2ray 服务端 mtproxy 协议</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;V2ray 是继 ShadowSocks 后又一个蓬勃发展、欣欣向荣的代理利器，目前支持多种传输协议。现在可以使用它设置 MTProto 协议，搭建 Telegram 的内部代理服务器，实现无需打开其他突破网络封锁的客户端即可正常通讯的目的。&lt;/p&gt;
&lt;h1 id=&quot;V2ray-的代理原理&quot;&gt;&lt;a href=&quot;#V2ray-的代理原理&quot; class=&quot;headerlink&quot; title=&quot;V2ray 的代理原理&quot;&gt;&lt;/a&gt;V2ray 的代理原理&lt;/h1&gt;&lt;p&gt;v2ray 的代理原理和配置项的关系如下图：&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2018/08/15/5b73c180d5ef0.png&quot; alt=&quot;v2ray原理图及配置关系&quot;&gt;&lt;/p&gt;
&lt;p&gt;p.s.上图为 v2ray v4.0 之前的代理原理图。v2ray v4.1+ 合并了输入输出配置项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;inbounds = inbound + inboundDetour&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;outbounds = outbound + outboundDetour&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;为便于理解，你可以将上图 &lt;code&gt;inbound&lt;/code&gt;、&lt;code&gt;inboundDetour&lt;/code&gt; 视为各种不同的代理方式，全部定义在新版配置文件的 &lt;code&gt;inbounds&lt;/code&gt; 配置项中，&lt;code&gt;outbounds&lt;/code&gt; 亦同理。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="教程" scheme="https://acuario.xyz/categories/%E6%95%99%E7%A8%8B/"/>
    
      <category term="软件使用" scheme="https://acuario.xyz/categories/%E6%95%99%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="教程" scheme="https://acuario.xyz/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="VPS" scheme="https://acuario.xyz/tags/VPS/"/>
    
      <category term="v2ray" scheme="https://acuario.xyz/tags/v2ray/"/>
    
  </entry>
  
  <entry>
    <title>七月，已经溜走了</title>
    <link href="https://acuario.xyz/july-is-gone/"/>
    <id>https://acuario.xyz/july-is-gone/</id>
    <published>2018-07-31T15:51:12.000Z</published>
    <updated>2018-07-31T16:01:20.716Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/07/31/5b608698e9572.jpg" alt="joined-screenshot4.jpg"><br>(IMG Source: <a href="https://en.wikiquote.org/wiki/Fight_Club_%28film%29" target="_blank" rel="noopener">Fight Club</a>)</p><p>我好像已经忘了这个月是怎么开始的了。我试着从屏幕右下角的几个数字向前回溯，然后试图写下点什么无病呻吟的东西，用来给「时间」这把尺子多加一个叫做七月的刻度。</p><a id="more"></a><p>一直不愿意在自己的博客上写一些日记随笔类的东西，心想着这些胡思乱想被人看到那会是一件多么羞耻的事情。就像微信里的朋友圈，满足的不过是 Peeping Tom 们内心的窥私欲——在通讯录里上下滑动，看到某个叫做 A 的家伙，想起他对于自己的身份，想起自己是在何时何地因为什么机缘巧合与其相识，然后点开他的朋友圈。如果他没有使用那个叫做「仅显示最近三日的状态」的奇技淫巧的话，他一点一滴想被我窥视的东西，便毫不掩饰地冲入我的视野——哎哟喂，这兔崽子活得也还不错哦。哦哟，这龟孙子也不过如此嘛……<br>可能会感慨一下谁谁谁的人模狗样，或者某某某的人生轨迹。但这不过是给自己一个「这世界不过如此」的充分条件罢了，看似充满信息的摄入，不过只能留下转身便忘了的回忆罢了。</p><p>把过去一个月的经历写出来，然后琢磨着能有什么联系和想法，慢慢想到了几个关于「改变」的印记：</p><ul><li>人生第二次搬家——明显的空间尺度上的「改变」</li><li>看了一场城市历史摄影展——明显的时间尺度上的「改变」</li><li>闲逛了一场动漫展——不同次元间的「改变」</li><li>一本<a href="https://books.google.com.hk/books?id=QGw7DwAAQBAJ&amp;dq=%E5%87%BA%E8%B3%A3%E4%B8%AD%E5%9C%8B&amp;hl=zh-CN" target="_blank" rel="noopener">政治类书籍</a>，但是写读书笔记时又在考虑要不要做自我审查——在言论身份上的「改变」</li><li>一本<a href="https://book.douban.com/subject/30217599/" target="_blank" rel="noopener">推理小说</a>——虚构与现实间的「改变」</li></ul><p>在此之前，从没有用这样的视角去观察过周遭的事情，也就想到了关于「时间」的概念。一次和 <a href="https://twitter.com/ibingfei" target="_blank" rel="noopener">Andy</a> 聊天提及<a href="https://zh.wikipedia.org/zh/%E7%8F%BE%E4%BB%A3%E6%80%A7" target="_blank" rel="noopener">现代性</a>中时间概念对人类社会和自我的影响，自然地顺着这条思维路径去反思自身行为方式和目的。<br>也就是最近一段时间的事情，突然想买一个卡片相机拍 vlog，至少「拥有一个 DV 去记录动态的生活和经历」是几年前代购清单上的一笔，只是取代 DV 位置的已不再是新款的 DV，而是一个又一个样貌趋同的被称之为 smart phone 的 stupid phone。<br>「你到底是为了什么想去拍？是为你自己，还是为了分享？」<br>「你留恋的，是那时那人那地的瞬间，还是春夏交替间的变换？」<br>若不是因为「时间」这人类社会定义的概念，若不是我们每个人拥有的时间观念，我们又怎会产生种种臆想？<br>我很难坚定地去说做的事情完完全全为了自己，因为如此廉价的分享渠道和人类自身的社会性，在冥冥中促使我们更想把自己的所思所想所记录传达出去，让自己的文字和思想通过如此低效的方式转移到另外的地方去。</p><p>尼采在《查拉图斯特拉如是说》里这样写道：</p><blockquote><p><strong><strong>我教你们超人</strong></strong>。人是应该被超越的东西。你们做了什么来超越他呢？<br>一切生物至今都创造了超越自己的东西：你们要做这大潮中的落潮，宁可回到动物那里去，也不愿意超越人类？<br>对人类来说，猿猴是什么？一个笑柄或是一个痛苦的耻辱。对超人来说，人也一样：一个笑柄或是一个痛苦的耻辱。<br>你们完成了由虫到人的过程，你们身上许多东西仍然是虫。你们曾经是猿猴，现在人比任何一只猿猴更是猿猴。<br>但是你们当中的最聪明者，也不过是植物与幽灵的矛盾体与共同体。但是我吩咐你们变成幽灵还是植物？<br>瞧，我教你们超人！</p></blockquote><p>如果说，hack myself 也算是一种趋近「超人」的行径的话，那么我相信<a href="https://zh.wikipedia.org/wiki/%E5%BE%B7%E7%88%BE%E6%96%90%E7%AE%B4%E8%A8%80" target="_blank" rel="noopener">德尔斐箴言</a>里那句 <code>Be Yourself or Know Yourself. （认识你自己。）</code> 也许会是我一辈子值得探索和作答的考题。</p><p>我还没落笔，七月，已经溜走了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/07/31/5b608698e9572.jpg&quot; alt=&quot;joined-screenshot4.jpg&quot;&gt;&lt;br&gt;(IMG Source: &lt;a href=&quot;https://en.wikiquote.org/wiki/Fight_Club_%28film%29&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Fight Club&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;我好像已经忘了这个月是怎么开始的了。我试着从屏幕右下角的几个数字向前回溯，然后试图写下点什么无病呻吟的东西，用来给「时间」这把尺子多加一个叫做七月的刻度。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://acuario.xyz/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://acuario.xyz/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
