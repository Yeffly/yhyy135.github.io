<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Acuario</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://acuario.xyz/"/>
  <updated>2020-01-21T15:38:59.848Z</updated>
  <id>https://acuario.xyz/</id>
  
  <author>
    <name>Acuario</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《写真得思考》读书笔记</title>
    <link href="https://acuario.xyz/interpretation-on-hotographic-art-clip/"/>
    <id>https://acuario.xyz/interpretation-on-hotographic-art-clip/</id>
    <published>2020-01-21T15:36:00.000Z</published>
    <updated>2020-01-21T15:38:59.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="读后感"><a href="#读后感" class="headerlink" title="读后感"></a>读后感</h1><p>对摄影评论并不是热衷，不过在这本饭泽耕太郎《写真的思考：摄影的存在意义》里，作者传达了一个容易被忽视的审美角度——有的摄影作品是“以偶然的方式处理偶然，并将其必然化”。这里所说的偶然，毫无疑问指的是摄影行为本身的偶然，而所谓的必然，其实是摄影行为在凝结为摄影作品后，呈现给观众的必然。将「偶然」作为摄影行为的动机，是刻意扰乱意识性的控制、主动地选取错乱的过程。这在摄影创作中并不少见，但我们往往习以为常，而忽略了它作为摄影动机的深刻内涵。</p><p>现代主义和现代性的模糊定义，看似并没有给摄影艺术的解构来带多大困难，虽然难以从时间维度描摹摄影现代主义的全貌，但并不难从各种作品的共性中找到蛛丝马迹。作者在这部分提到了「断裂」与「再现」的概念。具体来讲，将客体从远观到近观的局部摄影，将客体从语言层面的所指转向能指的超现实主义摄影，都是一种以「断裂」为形式的创作，而摄影冲印技术的发展，又无不是「再现」的同义反复。现代主义在这样的过程中慢慢褪色，用作者的话来说，「尽管“后现代”这件衣服迅速穿上之后又被脱下，“现代”仍渗透在我们的骨头中、侵蚀着人类的思考与感受」。</p><p>从书名出发，「写真」一词的内涵远远超出了我们通常给它的定义——特指人物肖像的摄影类型。恰恰相反，写真的定义是具体而又宽泛的。在摄影技术刚刚进入日本时，人们对这样全新的成像技术抱有极大的好奇，什么是真实？如何描摹真实？这两个问题在很长的时间尺度上陪伴着人类的绘画艺术，而摄影技术的出现，从根本上实现了写实主义，说到底，这恰恰就是一种对真实的写照，也是就作者想要表达的「写真」之意。摄影技术刚刚兴起的时期，也正是祛魅与复魅发展的时期，例如一些摄影师寻找非职业的摆拍者在棚内进行场景再现，利用摄影的写实主义特点进行的创作，不仅满足了受众对「写真」的心理需要，也让写真一词的定义更加深刻，这正是技术祛魅的实证。随着摄影印刷的普及，明信片的大量生产使耗费手工且价格昂贵的写真艺术快速衰退，新的技术浮上水面，为人类社会重新复魅。</p><p>摄影作为记录，或者作为创作的特性自然无需多言，更多的或许只是摄影艺术本身如何从这二者中进行选择的问题。不过，「死者的照片」却远远突破了这个论点，表现出具有普遍性的哲学内涵——死者不愿被遗忘，或者说生者不愿遗忘死者的羁绊。在现代社会以前，能够通过绘画艺术将自己的样貌「不朽」的，毕竟只是权贵等少数人。摄影术的出现，大大降低了这个原本只有少数人拥有的「不被遗忘权」。生者与死者通过影像的记录，获得了精神上的接触和联结，而死者真正的死亡，也被长久地延续到了被所有后人遗忘的时间点。遗照的拍摄角度、遗照的保留方式，在不同文化背景下的巨大差异，那又是另外的话题了。死亡作为人类无法回避的哲学命题，也就这样自然而然地通过摄影技术的大众化，传递到了普罗大众的生活中。</p><a id="more"></a><h1 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h1><p>第 21 页<br>即使是美丽花朵、可爱小猫、美味料理等照片，如果以婴儿般未开化的眼光来重新审视的话，应该仍可窥见各种各样神话性的现象，如漩涡一般翻转着。持续端详之下，照片中的含意将会分支，多层化、流动性地变换和组织，最终产生出意想不到的结合。换句话说，初看普通的照片在深入审视后也有可能完全变为夸张而怪诞的异物。此外，还可能引发出逆转现象，将理所当然的东西转变为特异且独一无二之物，或者将特别的事物变成具有普遍性的东西。</p><hr><p>第 32 页<br>十九世纪中叶，摄影技术在世界各地扩展时，曾经被视为一种具有魔力的装置:“被拍照时，灵魂会被抽取而出”。不仅在日本类似这样的流言全世界都在流传，换句话说，也就是会被引领去往死亡的世界。而十九世纪最被人喜爱的摄影领域之一，便是拍摄眼睛所不能见到的灵魂存在的灵异照片，这种喜好的理由多少也包含了摄影会抽取出灵魂的想法。</p><p>从十九世纪进入二十世纪后，这样的魔幻性质却随着时代进步而急速消逝。因为器材与底片的进步，大众化的摄影转变为社会沟通的手段，成为仅是正确再现、传达图像的工具。而二十世纪末正式展开的数码摄影，更让我们确认了此一演变方向。时至今日，相机已经成为一种可以控制、容易上手、便于使用的工具。</p><hr><p>第 42 页<br>拍摄这件事情既是“射击=杀死”，也是被“击中=复活”。</p><hr><p>第 57 页<br>“全体”的解体</p><p>让我们暂且先以“断裂”这个名词来表达现代主义摄影的基本原理之一。就如斯蒂格里茨的《乔治亚·欧姬芙》所展现的，即正是这种断裂的典型。贯穿现代摄影的，便是从预先依照秩序安排好的“全体”中取出“断裂”的部分［或从中分离出某些片断］，给观看者类似强迫症般的提示，这样的提示可将部分全体化。与眺望构图宽广的画面相反，这样一来反而会带给人一种奇妙的、切实的执著感。</p><p>以“特写”来说，这种在现代摄影中频繁出现的技法，是最容易让大家理解的例子。整个现代主义时期大量出现从脸、人体、建筑物、机械类、植物等全体中撷取一部分放大拍摄的题材，亦即全体的部分化，同时也是部分的全体化。这些特征超越了摄影师出身的国籍、经历、个性等，让我们体验到同时代性的感受。</p><p>这些摄影师使用特写技法所要追求的，就是将被摄体从日常视觉感受的全体性切割出来，并将其还原到单纯“物”的层面。</p><hr><p>第 60 页<br>费尔迪南·索绪尔［Ferdinand de Saussure］，将语言当作能指［significant，符号的表征］与所指［signifie，符号的内容］的结合来处理，再各自对应到语言的“概念”与“意义”。根据他的说法，能指与所指的结合是随意的，不需要任何内在的动机或根据，亦即将能指与所指切割开来，让另一个语词“意味的内容”整个更换过去也完全可行。而类似这样能指与所指的再构成，于影像符号上执行比在语言符号上更加彻底，这是因为影像本身并不像语言一般有着严密的符码对应关系，相对来说能指与所指的连接也比较松散。</p><p>超现实主义者便利用摄影这种表现媒体，将原本影像上的意义作用因“间隔化”更加扩大。曼·雷或勃法所拍摄“一点都不奇怪”的帽子、汤匙、洋伞、街角景致等，不仅是剥夺了它们现实性的能指，还外加“情色性象征的书写”与其他所指结合。</p><hr><p>第 66 页<br>再现与复制，使得影像生产力大增。借由摄影师之手，影像由日常脉络中被切割开来、赋予特别的意义，然后在极短的时间内再度被日常化、陈腐化。位于时代“尖端”的影像在短时间内不断地被消费，进而变得司空见惯且理所当然。为了对抗这种影像消费的空转，现代主义者们只能被迫不断穿上新衣，又不得不迅速地脱掉舍弃。</p><p>在历史上，没有其他时期像现代主义时代一般，不停开发各式各样新技法，反复进行技术性实验。而这个时期的摄影师们也必须自发性地频繁改变作品风格，此现象在其他时期也是很罕见的。也因为如此，从现代主义出现以来，“新奇度”便成为评价的绝对基准。</p><hr><p>第 88 页<br>对艺术活动而言，让当时摄影师觉得感动且互享的那种欢愉，应该是对被描绘的、被拍摄出来的、与原物品完全一致的那种纯粹与惊奇。但将其推到极端来说，影像究竟是什么，对他们而言并不构成任何问题。与原物品几乎一致但却非原物品，这种类似制作出某种拟造物，有如机械机关一般的复制机制，才是他们深感魅力的所在。这让他们愿意沉迷其中，也是让他们努力于摄影与西洋画的原动力。</p><p>那是一种在没有任何干涉与关联下产生出的空虚，也是一种缺乏对象物的“写实”。正是这种状态，才让摄影师的作品展现出奇妙的真实感。</p><p>在这样的论点上，他们从事的并非是“艺术家”的工作，而是一种视觉上的娱乐，更接近新奇事物的展示。</p><hr><p>第 96 页<br>一百六十多年前，摄影传入日本之际，适逢维系近三百年的江户幕府崩坏，新社会、新文化的框架重新形塑的时期。或许这种动荡不安、持续有重大变化的社会状况，也正好唤醒人们对“真实”的追求意识。此外，这个时期也正是摄影原有的魔幻性、神话性的思考，仍在摄影师与画家们间共通、共有，并以各种形式满地开花的时期。如前所述，明治中后期以后，当日本逐渐转型为现代国家的时期，摄影与绘画一体化的魅力表现，便急速地瓦解。</p><hr><p>第 103 页<br>在达盖尔与塔尔博特发明摄影的时代，背后推动与支持他们的文化背景，其实正是该年代对“静物”的欲望与需求。</p><p>这个概念可以追溯到十八世纪至十九世纪前半期，支配欧洲人“观看”意识的“如画风格”美学，前文所描述的静物摄影也可以说是反映这种美学的一种产物。如画风格的美学意识后来也影响到十九世纪末形成的“画意摄影”，这部分已经于前文提及在摄影师们努力把照片“艺术化”作为目标的时代，如画风格的绘画便是他们的规范。也是这种根深蒂固的符咒催生了摄影术，并成为摄影以惊人速度发展的契机之一。</p><p>简单地说，“如画风格”是将眼前宽广的世界以“边框”围起，当作一幅图画来观赏的意识。如果将这种意识彻底化，就会产生比起现实世界，图画反而让人更感到真实的倒错感。例如高山宏在《目中的剧场》中，描述了流行于十八世纪，一种称为“克劳德镜”［Claude Glass］的奇妙光学器具。这种“直径约四英寸的凸透镜”，可以选择观看者喜好的色调箔片，而透过这个工具观看风景时，可以变换、映照出对现实的凝视，就如同当时深受大众喜好的克劳德·洛兰［Claud Lorrain］的风景画一般。携带着克劳德镜的旅行者，只要将风景框进透镜，便能够随心所欲地享受“如画风格”的美景。以这种方式观赏风景的时代，也代表着观看者的行为“在结构上是和自然相对”的。</p><p>在某种意义上，如画风格也是将世界所有可能的影像都缩小，封存入“眼中”的一种意识。诚如多数评论者指出，在摄影术快速发展的十八世纪到十九世纪之间，它将视觉从听觉或触觉等其他感官中独立出来并放大。“观看”与“拥有”被直接联系在一起，以“观看者”为中心，将世界再组织的欲望便从此昂扬前进。</p><hr><p>第 109 页<br>然而，在第一次世界大战后的1920年代，不知为何，无生命的拍摄对象又再度复苏，成为摄影的被摄体。</p><p>……</p><p>这些静物摄影，与上一个世纪受如画风格美学影响而创作的作品有着微妙的差异。举例来说，如画风格美学意识中最重要的，便是以观看者为中心，“如人们想看的一般去看，如想切取一般的去切取”出画面并封存于取景框之中，以及审慎细致地去进行画面配置。但是1920至1930年代以物件为主题的摄影作品，占据主角位置的不再是人类，而是对象本身。对象脱离人的控制而主张自我的存在，可在画面中任意、任性地繁殖，仿佛彼此秘密交谈一般。这种奇妙的氛围是我们观看这些作品时所能察觉到的，所以在这些创作中占据世界中心位置的与其说是人类，不如说是对象。</p><p>像这样的逆转，起因应该是将全欧洲逼迫至极限状态的第一次世界大战所带来的对过往以人类为中心的价值观进行反思所产生的危机感。人们过去认为自己与世界的关系是确实而明确的，但在世界大战中，这种想法无可抑制地崩坏。因为异物化的巨大战争机器，让人们的生命无论在何处都暴露在致命的危险之下。这些应该受支配的物品，从人类的桎梏中逃脱并任意地到处漫游，让人觉得它们仿佛正在各处自我增殖。对象不再是能被操作的道具或工具，反之是活生生显露出敌意的异物。</p><p>不仅如此，1920至1930年代也是人们眼前陆陆续续、不断出现过往未曾看过之异物的年代。汽车、飞机、地下铁等新的交通工具，钢筋、水泥与玻璃所建造的充满设计感的建筑，泛着黑色光泽与钢铁肌理的机械在撕裂大地的同时又将空间多层次地连接起来，这些机械时代的产物，伴随着对几何学结构美的礼赞，但人们也意识到这些异物已经超越人类的控制范围，成为无法控制<br>的存在。而摄影师们面对这些不熟悉的物品，内心的憧憬与嫌恶、恍惚与不安、留恋与抵抗等思绪必然产生激烈冲撞。</p><hr><p>第 120 页<br>就结果来说，摄影师们憧憬着超越人类思考与感觉尺度的物件本身它们所含有不可思议的力量，以及抱持着能够将其自由操作转化为任何变异影像的欲望，将这些冲动与摄影这个包含了各种矛盾的媒体结合，便形成了上述的静物摄影历程，并让摄影出现在既不是物件也不是影像［反之也可以说既是物件也是影像］的中间性区域。因此，摄影所拍摄下来的物件，一方面保存了物件的真实性，另一方面也保持着物件作为影像可被操弄的矛盾。</p><p>静物摄影，在某种意义上可以说截取了摄影神话性、魔幻性思考中最直接的形式。物件与影像的双重性，既互相分裂也相互需要，对于此矛盾性的存在，只要人们还想去追求、厘清这种狂野的谜团，沉迷于静物的摄影师们的历史就会延续下去，不会断绝。</p><hr><p>第 134 页<br>三浦雅士在他那充满启发与刺激性的摄影集《幻影般的另一人 现代艺术笔记》［冬树社出版，1982年］中提及，摄影师们虽然身处某处，却同时不具有身处该地的存在意识，也就是将自己定位在“幻影般的另一人”。他们的存在，就像是在不知不觉中混入玩耍的小孩里，计算人数时不管怎么数都会多出一个人来的妖怪——座敷童子。摄影师们“不管在什么状况下都不能够成为相关的当事者。他们经常是从情境中多出来、如幻影般的另外一个人，而除此之外他们什么都不是”。正因为如此，与摄影师们同处于封闭空间中的裸体女性，才能够平心静气地展现身体。而在战场或事故现场中，摄影师们也会自情境中抽脱，如此才能够以自在的，有时候甚至是旁若无人的方式，来进行拍摄。</p><p>这种专属于摄影师们的特权地位，便是由纯粹的“观看者”而来。当手中握有魔法般的装置，他们也同时可以将所有人事物转换成“被观看者”。在某种程度上，我们甚至可以说摄影师的凝视已经转化成能扫视一切，绝对的神之视线，能在制高点上看穿所有人们、风景，以及处于其间的复杂脉络。但即便是具备如此全能视线的摄影师，也有一处是他们所观看不到的，那便是这些摄影师自身。</p><hr><p>第 190 页<br>直到创造性的快照出现为止，摄影师与被摄体的关系，大致上不是保持远距，就是拉近距离。“家庭快照摄影”的拍摄者与被拍摄者间的关系，不用多加说明也知道是极端亲近的，而这种物理性、情感性的亲密度，便会唤起观看者无法压抑的怀念感受，或者是对逝去过往的唏嘘。反之，人类学者去未开化的部落拍摄，或者纪录悲惨的事故之时，就会与被摄体保持距离，因为他们需要一定的客观性，如果不这么做而投入自己的感情，恐怕就会漏失掉重要的画面。</p><p>所以，要如何判断作品是否为优秀快照的秘诀，便在于是否能够尽力保持不远也不近，以不断调整、接近及拉开与被摄体之间的关系。这件事情看起来简单却意外的相当困难。如果与被摄体产生亲近与习惯的感觉，就容易染上主观的色彩，进而卷入说明式的脉络中，最后容易变成刻板印象式的量产作品。反之，如果与被摄体保持相当的距离而致力于调整整体构图，并过度专注于按下快门的时机的话，被摄体又会变成不过是画面构成的素材而已。</p><hr><p>第 244 页<br>“主题演讲”中，东松对自己的摄影方法做出如下表述：</p><blockquote><p>摄影可说是科技中的媒体先驱，而摄影的特征，或者是百分之一秒，或者是十分之一秒，总而言之便是一种瞬间的静止。如果换种说法，也可以说摄影具备了杀死时间的机能。当然将无时无刻不在前进的时间止于一瞬的说法，其实也不过是停住了时间的影子而已。所以，似乎可以说摄影是虚构的，也确实是如此。它切割出一片生命的瞬间，将其置换到被称为照片的平面上，进行永久性保存。如果这世上的所有事情几乎都是以实体存在的，那么，对拍摄黑白照片的人来说，他们就是使用黑白色调将彩色的世界抽象化，然后再进行永久保存。</p></blockquote><p>这里他所说的将现实世界的时间切割之后再重新组合，其实是非常优秀的“现代主义”摄影观。把流逝的时间以几分之一秒为单位进行切割，并“将其置换到被称为照片的平面上”然后加以保存。这个切割与保存的程序，东松用“杀死时间”这样卓越的比喻来表达。也可以说，时间应该是处于假死状态，并由观看者的“手”加以“解冻”，让“被杀死的时间经由观看者再度苏醒”。</p><hr><p>第 263 页<br>葬礼在某种意义上可以说是记忆的祭典。这是一个唤醒来参加典礼的凭吊者们的记忆，让他们每个人都想起往生者在世的模样，而且是每个人都积极参与的魔法仪式。在这个白热化的心灵能量交换场所，摄影的“重生记忆”的力量也被最大限度地激活，即便对像我这种与父亲有点疏离的人来说［话说回来也并没有特意要疏远］，看着他生前的姿态慢慢被播放出来，也无法遏抑强烈的哀痛与思念。所以，如果是容易被影响的性格，而且与逝者有着更加深刻联系的人，那就更加容易陷入狂乱的情绪里，这也是可以充分理解的。</p><p>在葬礼这种稍微脱出常轨而带有使人情绪激动的空间中，摄影与死者被刻意混合。某种意义上葬礼的主角，反而不是躺在覆盖着花朵的棺木中那位真正的死者［虽然这是有点奇怪的说法］，而是祭坛上摆放的遗照。吊唁者凝视着往生者的照片，对着它双手合十祈求冥福，有时对着它呼喊，有时对着它流泪，看着它无法遏制自己情感的人更不在少数。不过这魔法的持续性并不长，当葬礼结束之后，这幅放大的遗照就会被收藏妥当，谁也不会再回头去看它。或许会被暂时放在厅堂挂着，但最终照片还是会被收到某处，或者被秘密处理掉。</p><p>人们有时也会将亡者的小照片与牌位一起供奉在佛坛上，但即便如此也会逐渐蒙尘，变成一年一次或两次的仪式性膜拜而已。记忆逐渐稀薄，认识逝者的人，也如梳子的梳齿逐渐脱落一般，一个随着一个消逝，遗照的魔幻性力量也会随之涣散，最后完全还原到只是一幅普通的照片而已。当对持有逝者记忆的人一个也不存在，所有人都将之遗忘掉时，也就是逝者初次成为完全的亡者的时刻。如果不是在艺术或文学上留下作品，也非在政界或商界活跃而留下昭彰恶名者，普通默默无闻的死者，大多都会走上如此的命运。</p><hr><p>第 272 页<br>沿着这些照片回溯，我们可以看到从十九世纪到二十世纪初期，对一般的美国人而言，这些“死者的纪念照片”所具有的特别意义。即使他们是以今日我们无法理解的热情去持有死者的肖像，但我们还是可以感受到由于伴随着这样的持有，使他们也对生命更加坚持。伯恩斯针对当时的情况，在摄影集的序文中写道：</p><blockquote><p>绘画是富裕的名人为了记忆而使用的媒体，该功能从十九世纪以来一直没有改变，而摄影不仅能创造出视觉图像，同时也是能提供给所有人观看的媒介。因此，过往只有富裕阶层才能拥有的不死性，在摄影出现后便为千万人敞开大门。死者的纪念照片，不仅只是单纯唤醒记忆，例如年纪幼小还没拍过照片即过世的人们，纪念照片也可以替他们保持形貌。</p></blockquote><hr><p>第 272 页<br>让伯恩斯特别关心的，是美国与欧洲“死者的纪念照片”在本质上的不同。观看《睡美人Ⅱ》中刊载的拿破仑三世［E.阿贝尔特拍摄］、维克多·雨果［Victor-Marie Hugo］［纳达尔拍摄］、疯王路德维希［LudwingⅡde BAVIERE］［F.华纳拍摄］等人在床上过世的照片，即可以理解这些作品都遵从传统图像学，在拍摄时都强调堂堂正正的父性元素。在欧洲，不限于这些君主或者名人，在一般的死者的纪念照片中，对“王权、贵族制度、财力等特权于公开场合表明”的突出表现也很多。</p><p>与此相对，在美国就以“个性的丧失感与私人性的表现”为中心。大多数的场合，并不会作夸饰社会地位的演出。此外，美国的死者的纪念照片比较多都是收入盒中或以个人可以带着走的形式放置，而欧洲则会装上画框挂于墙上。美国的死者的纪念照片，较欧洲的酝酿出更多的亲密氛围，可以说是作为“日常生活中极其自然的一部分”来发挥其功能。</p><p>这样的差异，当然是由美国与欧洲传统文化的差异所衍生出来的。欧洲的家族比较容易保有国家、民族文化以及历史的羁绊，与这种状况相对，身为移民国家的居民，美国人对自身身份的认同，不得不以家族为单位，所以他们对死者也是家族成员之一的意识，希望能够继续这样保持下去的愿望，比欧洲家族来得更加强烈。而这样的愿望，均会加强想要持有死者的纪念照片的欲望。</p><p>他们“为了表明希望借由摄影的魔法来延长与死者的关系，而［在拍摄照片时］与时间立下契约”。</p><hr><p>以上摘自：</p><p><img src="https://i.loli.net/2020/01/21/cRlXZAfeFKOgN3z.jpg" alt="《写真得思考》"><br><a href="https://book.douban.com/subject/26292968/" target="_blank" rel="noopener">《写真得思考》</a><br>副标题: 摄影的存在意义<br>作者: [日]饭泽耕太郎<br>译者: 黄耀进<br>出版社: 广西师范大学出版社<br>ISBN: 9787549562756</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;读后感&quot;&gt;&lt;a href=&quot;#读后感&quot; class=&quot;headerlink&quot; title=&quot;读后感&quot;&gt;&lt;/a&gt;读后感&lt;/h1&gt;&lt;p&gt;对摄影评论并不是热衷，不过在这本饭泽耕太郎《写真的思考：摄影的存在意义》里，作者传达了一个容易被忽视的审美角度——有的摄影作品是“以偶然的方式处理偶然，并将其必然化”。这里所说的偶然，毫无疑问指的是摄影行为本身的偶然，而所谓的必然，其实是摄影行为在凝结为摄影作品后，呈现给观众的必然。将「偶然」作为摄影行为的动机，是刻意扰乱意识性的控制、主动地选取错乱的过程。这在摄影创作中并不少见，但我们往往习以为常，而忽略了它作为摄影动机的深刻内涵。&lt;/p&gt;
&lt;p&gt;现代主义和现代性的模糊定义，看似并没有给摄影艺术的解构来带多大困难，虽然难以从时间维度描摹摄影现代主义的全貌，但并不难从各种作品的共性中找到蛛丝马迹。作者在这部分提到了「断裂」与「再现」的概念。具体来讲，将客体从远观到近观的局部摄影，将客体从语言层面的所指转向能指的超现实主义摄影，都是一种以「断裂」为形式的创作，而摄影冲印技术的发展，又无不是「再现」的同义反复。现代主义在这样的过程中慢慢褪色，用作者的话来说，「尽管“后现代”这件衣服迅速穿上之后又被脱下，“现代”仍渗透在我们的骨头中、侵蚀着人类的思考与感受」。&lt;/p&gt;
&lt;p&gt;从书名出发，「写真」一词的内涵远远超出了我们通常给它的定义——特指人物肖像的摄影类型。恰恰相反，写真的定义是具体而又宽泛的。在摄影技术刚刚进入日本时，人们对这样全新的成像技术抱有极大的好奇，什么是真实？如何描摹真实？这两个问题在很长的时间尺度上陪伴着人类的绘画艺术，而摄影技术的出现，从根本上实现了写实主义，说到底，这恰恰就是一种对真实的写照，也是就作者想要表达的「写真」之意。摄影技术刚刚兴起的时期，也正是祛魅与复魅发展的时期，例如一些摄影师寻找非职业的摆拍者在棚内进行场景再现，利用摄影的写实主义特点进行的创作，不仅满足了受众对「写真」的心理需要，也让写真一词的定义更加深刻，这正是技术祛魅的实证。随着摄影印刷的普及，明信片的大量生产使耗费手工且价格昂贵的写真艺术快速衰退，新的技术浮上水面，为人类社会重新复魅。&lt;/p&gt;
&lt;p&gt;摄影作为记录，或者作为创作的特性自然无需多言，更多的或许只是摄影艺术本身如何从这二者中进行选择的问题。不过，「死者的照片」却远远突破了这个论点，表现出具有普遍性的哲学内涵——死者不愿被遗忘，或者说生者不愿遗忘死者的羁绊。在现代社会以前，能够通过绘画艺术将自己的样貌「不朽」的，毕竟只是权贵等少数人。摄影术的出现，大大降低了这个原本只有少数人拥有的「不被遗忘权」。生者与死者通过影像的记录，获得了精神上的接触和联结，而死者真正的死亡，也被长久地延续到了被所有后人遗忘的时间点。遗照的拍摄角度、遗照的保留方式，在不同文化背景下的巨大差异，那又是另外的话题了。死亡作为人类无法回避的哲学命题，也就这样自然而然地通过摄影技术的大众化，传递到了普罗大众的生活中。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://acuario.xyz/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://acuario.xyz/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《功利主义》译者序读书笔记</title>
    <link href="https://acuario.xyz/utilitarianism-translation-clip/"/>
    <id>https://acuario.xyz/utilitarianism-translation-clip/</id>
    <published>2019-12-29T11:01:47.000Z</published>
    <updated>2019-12-29T11:08:18.314Z</updated>
    
    <content type="html"><![CDATA[<p>功利主义作为重要的哲学理论，对近、现代社会、文化以及政治发展产生了不可忽视的影响，了解功利主义的基本意涵和发展脉络，是理解社会文化和大众心理的重要途径。本文系笔者阅读徐大建为约翰·穆勒的《功利主义》一书所作的译者序后，进行文摘和要点整理而作。由于原文较长，纵向分析了功利主义及其他哲学理论源流，也横向对比和列举了其他理论作者提出的对功利主义的批判和质疑，遂整理此文便于复读和思考。本文内容大部分源于对译者徐大建所作序文的摘录，部分排版和要点略有修改。</p><hr><h1 id="西方社会思潮及功利主义理论纵览"><a href="#西方社会思潮及功利主义理论纵览" class="headerlink" title="西方社会思潮及功利主义理论纵览"></a>西方社会思潮及功利主义理论纵览</h1><ul><li>现代西方社会思潮的主流是自由主义内部分为三大派别：<ul><li>自由平等主义</li><li>自由至上主义</li><li>功利主义</li></ul></li><li>从方法论的角度说，最有影响的西方社会思想流派：<ul><li>契约论学派：发源于古代自然法学派</li><li>功利主义学派</li></ul></li></ul><a id="more"></a><ul><li>当代自由主义契约论学派的基本观点：合乎道德的行为或制度应当符合正义的原则。所谓正义，简要地说就是尊重或者不侵犯个人的基本人权。因为人的理性都是相同的，所以我们可以诉诸每个人的同意，而诉诸人们的一致同意差不多也就相当于诉诸人的理性。</li><li>在古代西方的自然法学派的论证：人类行为规则的根据来自上帝颁布的自然法，由天启理性得到；尽管现有的许多行为规则属于人类法，是人制定的，但它们的最终依据是自然法，是自然法根据具体现实情况的某种应用这样的论证不免使得被自然法认可的一切都带有某种神秘性乃至神圣性。</li><li>近现代功利主义认识论的基础：一切知识的取舍最后都要诉诸人的日常经验而不是诉诸人的理性或上帝，伦理道德的论证也不例外。</li><li>休谟（David Hume，1711－1776）的怀疑论对自然法学派进行批判，人为自然法学派的“理性”包含着三种不同的含义：<ul><li>对观念之间必然联系的认知，它与经验无关，所以具有绝对真的性质，但这种性质仅存在于逻辑和数学这样的同义反复的命题之中；</li><li>对事物的经验性因果关系的认识，但这种因果关系并不存在必然性而仅仅是心理习惯而已；</li><li>对正确的人类行为规则——特别是诸如权利、正义或自由之类的理性原则的把握，但这些所谓的理性原则其实不过反映了人们的趣味或情感而并非理性的东西所以，自然法学派所宣称的出于理性的自然法原则，其实不过是由经验根据其是否有利于社会稳定和公众利益的结果判断为正当的行为标准，实质上是人类情感、心理习惯和社会习俗的混合物，而非出自自然的永恒真理。</li></ul></li><li>亚当·斯密（Adam Smith，1723-1790）从政治经济学的角度发扬了功利主义的精神。斯密的基本理论可以归纳为三个要点：<ul><li>人的全部行为基础是一种双重性的天赋人性人人都同时具有自利心和同情心；</li><li>经济行为的目的应当是个人的自由自主的幸福生活及其必要条件国民财富的增长或社会财富最大化；</li><li>第三，在这样的人性基础上，为了达到社会财富最大化的目的，基本的途径应当是基于市场经济的自由放任的经济政策以及严格保护财产权利和契约义务的政治制度。</li></ul></li><li>亚当·斯密的功利主义精神表现在：<ul><li>他用经济学的语言“国民财富最大化”解释了“最大多数人的最大幸福”这一功利主义的终极目的；</li><li>他说明了如何在自利的人性基础上达到功利主义目的的根本途径，即通过公平竞争来获得效率的市场经济体制，从而为经济学奠定了功利主义的伦理框架。</li></ul></li><li>边沁（Jeremy Bentham，17481832）首次对近现代功利主义作了一个比较全面的阐述。边沁认为，感觉经验是包括道德知识在内的一切知识的最根本而又真实的基础，因此，伦理道德也不能不建立在为人类经验所认可的人的趋乐避苦的本性和自我利益的追求之基础上：“当我们对任何一种行为予以赞成或不赞成的时候，我们是看该行为是增多还是减少当事者的幸福。”当每个人都真正得到了自己的最大利益时，社会也就达到了“最大多数人的最大幸福”，为“最大幸福原理”依赖于每个人的最大幸福之加总。于是，功利主义道德基本上就在于苦乐的计算。</li><li>在边沁的理论中，开明利已主义与功利主义是一致的。</li></ul><h1 id="穆勒《功利主义》概览"><a href="#穆勒《功利主义》概览" class="headerlink" title="穆勒《功利主义》概览"></a>穆勒《功利主义》概览</h1><h2 id="功利主义的含义"><a href="#功利主义的含义" class="headerlink" title="功利主义的含义"></a>功利主义的含义</h2><blockquote><p>把“功利”或“最大幸福原理”当作道德基础的信条主张，行为的对错，与它们增进幸福或造成不幸的倾向成正比。所谓幸福，是指快乐和免除痛苦；所谓不幸，是指痛苦和丧失快乐。……唯有快乐和免除痛苦是值得欲求的目的，所有值得欲求的东西（它们在功利主义理论中与在其他任何理论中样为数众多）之所以值得欲求，或者是因为内在于它们之中的快乐，或者是因为它们是增进快乐避免痛苦的手段。</p></blockquote><ul><li>前半部分是对道德规范问题的回答：判定行为对错的唯一最终道德标准是看行为是否能够增进人的幸福或快乐。</li><li>后半部分则是对人生意义问题的回答：增进快乐和避免痛苦是人生的唯一终极价值或“善”，其他任何值得欲求的东西或“善”都是为了增进快乐和避免痛苦。</li><li>后者是对前者的目的的说明，是前者的基础。</li><li>穆勒认为，伦理学的全部问题都可以归结为穆尔所说的：<ul><li>所论的对象具有本然价值吗？</li><li>所论的行为是达致最好可能结果的手段吗？</li></ul></li></ul><h2 id="“幸福”或“快乐”的定义"><a href="#“幸福”或“快乐”的定义" class="headerlink" title="“幸福”或“快乐”的定义"></a>“幸福”或“快乐”的定义</h2><ul><li>边沁的功利主义有两个特点：<ul><li>幸福或快乐是同质的因此可以在人际间进行比较和加总</li><li>功利主义的基础是人的趋乐避苦的本性和利己主义理论</li></ul></li><li>穆勒认为，功利主义所谓的“幸福”或“快乐”不是指动物的幸福或快乐，而是指人的幸福或快乐。承认某些种类的快乐比其他种类的快乐更值得欲求更有价值，在评估事物时，不论客体为何物，都考量其质量与数量。</li><li>穆勒认为，功利主义并不反对自我牺牲，但反对把自我牺牲本身看作善事：“一种牺牲如果没有增进或不会增进幸福的总量，那么就是浪费。它唯一赞成的自我牺牲，是为了他人的幸福或有利于他人幸福的某些手段而做出的牺牲。”</li><li>穆勒认为，功利主义与传统道德之间的关系是：</li></ul><blockquote><p>功利主义要求，行为者在他自己的幸福与他人的幸福之间，应当像一个公正无私的仁慈的旁观者那样，做到严格的不偏不倚。</p></blockquote><h2 id="功利主义道德标准"><a href="#功利主义道德标准" class="headerlink" title="功利主义道德标准"></a>功利主义道德标准</h2><ul><li>功利主义道德标准的外在约束力：“希望从自己的同胞和宇宙的主宰那里得到恩宠，不愿在自己的同胞和宇宙的主宰那里找不痛快，以及我们对同胞的同情挚爱和对宇宙主宰的敬畏等等”</li><li>功利主义道德标准的内在约束力：被我们称之为“良心”的道德感情，这种道德感情是在与同胞和谐一致的愿望这种天赋社会感情的基础上通过教育培养起来的。功利主义道德完全是符合人性的，是不难为人遵循的。</li><li>穆勒认为，功利主义道德标准的证明过程有一下几个要点：<ul><li>证明过程要么根据原理的推理，要么是诉诸事实的。但功利主义原理只能诉诸事实。</li><li>据此，需要证明事实上人生应当追求的最终目的是“最大多数人的最大幸福”。</li><li>据此，需要证明每一个人或至少是大多数人事实上追求“最大多数人的最大幸福”。</li></ul></li><li>穆勒认为，“每个人都在相信幸福能够获得的范围内欲求自己的幸福”是一个事实，所以“我们就不仅有了合适的证据，而且有了可能需要的一切证据来证明，幸福是一种善：即每个人的幸福对他本人来说都是一种善，因而公众幸福就是对所有的人的集体而言的善。”。此处「从每个人都追求自己的幸福直接推出每个人都追求最大多数人的最大幸福」缺乏论证。</li></ul><h2 id="功利主义理论与正义的关系问题"><a href="#功利主义理论与正义的关系问题" class="headerlink" title="功利主义理论与正义的关系问题"></a>功利主义理论与正义的关系问题</h2><h3 id="正义是什么"><a href="#正义是什么" class="headerlink" title="正义是什么"></a>正义是什么</h3><ul><li>穆勒认为，正义这个观念含有两种要素：<ul><li>行为规则</li><li>赞同行为规则的情感，即正义感</li></ul></li><li>正义的行为规则有五种公认的正义规范：<ul><li>尊重或不侵犯个人的法定的权利</li><li>尊重或不侵犯个人的道德的权利</li><li>尊重或不侵犯个人的应得的权利</li><li>尊重或不侵犯个人的约定的权利</li><li>尊重或不侵犯个人的天赋的权利</li></ul></li><li>正义规范包含着人的权利：“任何情况，只要存在着权利问题，便属于正义的问题，而不属于仁慈之类的美德的问题”换言之，一般人所谓的正义规范，就是尊重或不侵犯他人的正当权利。</li><li>穆勒认为，正义感含有两个本质要素：<ul><li>相信存在着某个或某些确定的权利受到侵犯的受害者</li><li>想要惩罚侵害者——此要素催生自卫冲动和同情</li></ul></li><li>正义观念归结为两个要素：<ul><li>对权利的侵犯</li><li>对侵害的惩罚，或对权利的保护</li></ul></li></ul><h3 id="正义与功利的关系"><a href="#正义与功利的关系" class="headerlink" title="正义与功利的关系"></a>正义与功利的关系</h3><ul><li>正义是建立在权利或利益的基础上的，是对正当权利或利益的维护。</li><li>正义是对权利的尊重，那就意味着社会对权利的保护。我们需要正义和对权利的保护，是因为这涉及到我们的最为至关重要的利益，即安全利益：</li></ul><blockquote><p>对人类的福利来说，禁止人类相互伤害的道德规则最为至关重要……因为一个人很可能并不需要别人的恩惠，但却始终需要别人不伤害自己。所以唯有那些保护每个人免受他人伤害——不论是他人的直接伤害，还是由于追求自己幸福的自由受到阻碍而遭到的伤害一的道德，才会立即成为每个人本人最为关心的东西，成为每个人最有兴趣用自己的言行努力宣传和贯彻的东西。</p></blockquote><ul><li>不同的人 / 同一个人在不同的场合对公平正义有不同的看法。解决争论的依据只有功利主义原则。</li><li>综上，穆勒认为，正义不是一种底线道德，而是保证人与人互不侵害的必须原则。但由于没有统一的正义标准，故在不同的正义标准发生冲突时，取舍的标准唯有社会功利。因此，正义建基于功利之上。</li></ul><h1 id="穆勒的功利主义理论缺陷"><a href="#穆勒的功利主义理论缺陷" class="headerlink" title="穆勒的功利主义理论缺陷"></a>穆勒的功利主义理论缺陷</h1><ul><li>西季威克（Henry Sidgwick，1838-1900）认为，穆勒虽然强调的是“最大多数人的最大幸福”而不是任何一个个人的幸福，但他却是从每一个人事实上追求自己的幸福出发来推出每一个人应当追求“最大多数人的最大幸福”的，此推理至少需要克服两个环节：<ul><li>从实际被欲求的东西推不出值得欲求的东西</li><li>从个人实际上追求自己的幸福推不出个人实际上追求公众幸福</li></ul></li><li>西季威克认为，要从个人实际上追求自己的幸福推不出个人实际上追求公众幸福，必须加上“合理仁爱”而不能仅仅靠“自利”。这也便将功利主义与利己主义彻底区分开来（在边沁的理论中，开明利已主义与功利主义是一致的）。</li><li>穆尔（G. E. Moore，1873-1958）对穆勒的功利主义证明进行了猛烈的抨击：穆勒混淆了“值得欲求的”与“实际上被欲求的”，用“实际上被欲求的”来定义“善”，试图用一种自然属性来给一种不可分析不可定义的属性进行定义，犯了一种自然主义谬误。</li><li>当代自由主义契约论学派主要代表人物罗尔斯的著作《正义论》旨在构造一个能与功利主义抗衡的作为政治哲学和法哲学的基础的伦理体系。他对功利主义进行批判大致集中在功利主义不能说明正义这一点上：<ul><li>功利主义是把合理利主义运用到社会的结果，因此强调“不偏不倚的旁观者（ spectator）的地位和同情”，“并不在人与人之间作出严格的区分”。</li><li>功利主义属于目的论，用“善”来定义“正当”，正义作为增加“善”的手段而不关心“满足的总量怎样在个人之间进行分配”，而根据功利主义原则，则无法说明分配公平的问题。</li></ul></li><li>功利主义不承认个人具有神圣不可侵犯的自然权利，功利主义原则会导致为了多数人的利益侵害少数人的合法权益，一方面要求超出自然义务的“自我牺牲的”善行，另一方面给已经更幸运的人更大幸福而牺牲一部分人的福利和自由。</li><li>阿马蒂亚·森认为传统福利经济学的目的是追求功利主义的社会福利最大化：<ul><li>后果主义</li><li>福利主义，即用效用或快乐来解释福利</li><li>把社会福利解释为个人福利的加总</li></ul></li><li>阿马蒂亚·森认为传统功利主义有重视结果、重视福利的优点，但其以效用的总和作为社会成就的判断准则会导致：<ul><li>忽视基本权利等非效用因素</li><li>以主观的心理感受来解释效用，忽视了与效用同样重要的主观能动方面（agency aspect）</li><li>忽视了分配公平</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;功利主义作为重要的哲学理论，对近、现代社会、文化以及政治发展产生了不可忽视的影响，了解功利主义的基本意涵和发展脉络，是理解社会文化和大众心理的重要途径。本文系笔者阅读徐大建为约翰·穆勒的《功利主义》一书所作的译者序后，进行文摘和要点整理而作。由于原文较长，纵向分析了功利主义及其他哲学理论源流，也横向对比和列举了其他理论作者提出的对功利主义的批判和质疑，遂整理此文便于复读和思考。本文内容大部分源于对译者徐大建所作序文的摘录，部分排版和要点略有修改。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;西方社会思潮及功利主义理论纵览&quot;&gt;&lt;a href=&quot;#西方社会思潮及功利主义理论纵览&quot; class=&quot;headerlink&quot; title=&quot;西方社会思潮及功利主义理论纵览&quot;&gt;&lt;/a&gt;西方社会思潮及功利主义理论纵览&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;现代西方社会思潮的主流是自由主义内部分为三大派别：&lt;ul&gt;
&lt;li&gt;自由平等主义&lt;/li&gt;
&lt;li&gt;自由至上主义&lt;/li&gt;
&lt;li&gt;功利主义&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;从方法论的角度说，最有影响的西方社会思想流派：&lt;ul&gt;
&lt;li&gt;契约论学派：发源于古代自然法学派&lt;/li&gt;
&lt;li&gt;功利主义学派&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://acuario.xyz/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://acuario.xyz/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="功利主义" scheme="https://acuario.xyz/tags/%E5%8A%9F%E5%88%A9%E4%B8%BB%E4%B9%89/"/>
    
      <category term="哲学" scheme="https://acuario.xyz/tags/%E5%93%B2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>《永久檔案》读书笔记</title>
    <link href="https://acuario.xyz/permanent-record-clip/"/>
    <id>https://acuario.xyz/permanent-record-clip/</id>
    <published>2019-11-27T15:07:52.000Z</published>
    <updated>2019-11-27T15:14:14.726Z</updated>
    
    <content type="html"><![CDATA[<p>深入鳳梨田底下的一條坑道——珍珠港時代的一座舊地下飛機廠——我坐在終端機前，可以幾近無限地取得世界上幾乎所有男女老幼的通訊，只要人們曾經撥打過一通電話或碰觸過一部電腦。這些人當中，包括三億二千萬美國同胞，他們日常生活的一舉一動都遭到監視，不僅嚴重違反美國憲法，更是違背自由社會的基本價值。</p><hr><p>人生是什麼？不只是我們說了些什麼，甚至不只是做了些什麼。人生亦在於我們所喜愛的、所相信的。以我而言，我最喜愛和相信的，是連結，人際的連結，以及促成這些的科技。當然，這些科技也包括書籍。但在我這個世代，連結，主要意味著網際網路。</p><p>在你產生反感、明白網際網路瘋狂毒害我們這個時代之前，請諒解，對我來說，當我認識網際網路之時，那是很不一樣的東西。網路既是朋友，也是父母，是一個無邊界、無限制的社群，既是單一、也是無數的聲音，一個已經有人墾殖但尚未遭到剝削的共同邊境，各式各樣的部落和睦相處，每個成員都能自由選擇自己的姓名、歷史和風俗習慣。每個人都戴著面具，然而這種多數匿名造就的文化所產生的事實多於造假，因為重點在於創造與合作，而不是商業與競爭。當然這之間也會有衝突，但善意與善念會勝過衝突——而這正是真正的先驅精神。</p><hr><p>往線上發展電子商務的早期浪潮很快便成為泡沫，接著在本世紀之初終於破滅。在那之後，企業界明白，人們在線上的興趣不在於消費，更在於分享，而且網路促成的人際連結是可以賣錢的。如果人們在線上想做的事主要是跟家人、朋友和陌生人報告自己的近況，從而得知家人、朋友和陌生人的近況，那麼企業只需要設法將自己擠進這些社交互動之中，再從中獲利即可。</p><p>這便是監視資本主義（surveillance capitalism）的開端，也是我原先所認知的網路的終點。</p><hr><p>美國政府在全然漠視開國憲章之下，屈服於這種誘惑，而且一旦嚐過這棵毒樹的果實，便陷入狂熱無法自拔。在暗地裡，政府掌握全民監視的權力，這種權威就定義上而言，對無辜者的傷害遠大於對犯罪者的傷害。</p><a id="more"></a><hr><p>隨著千禧到來，網路世界變得越來越中心化、集中化，政府與商業力量加速介入這個原本應是對等式的網路（P2P）。但幸好網路有段時期是由人民所擁有、管理並為其服務的，而這段短暫而美好的日子恰巧與我的青少年歲月重疊。網路的目的應該是啟發人心，而不是追求賺錢。它的規則應由大家約定俗成且隨時更動，而非採取全球一致、剝削性十足的服務性協議。一直到今日，我都認為一九九〇年代網路是我經歷過最愉悅、最成功的無政府狀態。</p><hr><p>在一九九〇年代，政府與企業的髒手還未伸進網路裡。這兩大力量後來竭盡所能連結使用者的網路身分與真實姓名。孩童過去能在網路大放厥詞、不必擔心後果。這或許不是成長的最佳環境，但網路卻提供你得以長大的唯一前提。我的意思是：網路早期的匿名性鼓勵了我這一代人改變成見，而非故步自封、頑固不化。擁有這種反省的能力，能讓我們傾聽自己內心而不必選邊站，也不須擔心名譽受損而盲從他人意見。錯誤迅速遭懲處然後盡快修正，讓社會與「犯錯者」都能繼續往前走。對我而言（以及許多人），這就是自由。</p><p>想像一下，若你想要的話，每天起床都能換張新面孔、選擇新身分，或是轉換新聲音、替換新詞彙。只要點擊「上網按鈕」，你的人生便能重啟。但在千禧年過後，網路科技變得非常不同：所有記憶必須忠實、身分維持一致，意識形態也得正確。但在那時（至少維持一陣子）網路容許我們越界、犯錯的空間。</p><hr><p>駭客並非僅限於電腦領域，只要規則存在的地方就會有駭客。想駭入一個系統，你必須比系統創造者或經營者更了解規則，並利用這群人預設系統運作與實際運作間的差異。駭客懂得善用這些無心瑕疵，與其說他們打破規則，不如說他們協助暴露系統缺點。</p><hr><p>我媽早已重返單身戰場，父親則盡力填補內心空虛，但他偶爾還是會因冗長、昂貴的離婚程序而大發雷霆。當這樣的情況發生時，我和父親的角色便會對調，我必須堅定果決地和他講道理。</p><p>寫下這段文字令人感到痛苦，原因並不在於重溫過去傷痛，而是這無法顯示我父母本質上的良善。出於對孩子的愛，他們兩人最終化解歧異、和解收場，各自過著幸福的日子。</p><p>這樣的改變是恆常、普遍且充滿人性的。但自傳是靜態的，無法記錄下一個人的全部變化。因此，最棒的自傳不是發表一段聲明，而是許下一個承諾，期許自己堅守原則、變成更棒的自己。</p><hr><p>一般來說，安全許可由低至高分三個層級，依序為信任（Confidential）、機密（Secret） 及最高機密（Top Secret，TS），最高機密等級還可進一步延伸，看符不符合敏感隔離資訊（Sensitive Compartmented Information，SCI）資格。任職中央情報局、國家安全局之類的頂級情治機構，就需要取得TS / SCI這等令人夢寐以求的權限。取得TS / SCI權限的難度最高，但開放的管道也最多，所以我重返母校安妮阿倫德爾社區學院進修，同時在找有利我申請單一範疇背景調查（Single Scope Background Investigation，SSBI）的工作，身家調查涵蓋SSBI這一項。TS / SCI核准程序會耗時一年以上……</p><hr><p>種種背景檢查的目的，不僅僅是要挖掘我過去幹過什麼勾當，還要查明我會被威逼利誘到什麼程度。對美國情報體系來說最要緊的，不在確認你是否百分之百清清白白，若真在意這點，一個人都僱不到。重點在於你是否誠實無欺，對自己見不得人的祕密坦承不諱，以免被敵方勢力利用來打擊你個人與組織機構。</p><hr><p>讓我的貼文從地球表面消失不犯法，而且萬一有心人想去挖，我也不用冒著身家調查不合格的風險。不過刪除貼文的可能後果讓我心煩意亂，那麼做只會徒然強化網路生活一些最腐蝕人心的訓誡：沒人有犯錯空間、凡是犯錯者得一輩子為自己的錯誤負責。我在意的倒不是文字記錄是否完美無缺，而是靈魂的完整性。我不想活在一個人人必須假裝完美的世界，那樣的世界沒有我和朋友的容身之處。抹掉在網上的評論，等於抹煞我是誰、我從哪裡來、我走了多遠。否定年少時候的我，等於否定現在的我的合法性。</p><hr><p>透過電腦螢幕就能脫口而出的事，一旦面對面卻最難說出口。距離反讓彼此更親密，人只有在一個空間獨處，或是與素未謀面的人在各自的空間對話，最能暢所欲言。然而一旦兩人見面，你會覺得綁手綁腳，說話變得保守乏味，徒然只是站在中立立場的尋常對話。</p><hr><p>與大多數年輕人一樣，我堅信我拒絕認同的信條，本來就不是我的，是從別人那兒承襲來的，而且充滿矛盾。我成長過程中被灌輸的價值，我在網路世界邂逅的理想，全都搗碎在一起成了我現在的思想。我直到即將邁入三十歲之際才終於明白，我所信仰的，我以為自己深信不疑的，大多是年輕時候的印記。我們學說話，是從模仿身邊大人的言談做起，在學習過程中我們也仿照他們的觀念，然後哄騙自己相信，我們的用字遣詞是出於自身。</p><hr><p>網路文化重大的創始檔案，幾乎都是用會聯想到美國歷史的術語來架構，這裡是有待開發的廣闊新天地，夠大膽的人都能在此安身立命，不過很快會被政府與利益團體殖民，他們為了權與錢會伸出控制魔掌。大企業為他們提供的硬體、軟體、長途電話服務索取高額費用，你想上網就需要它們。連知識這種人類共同遺產，大企業都不放過，照理說知識人人有權取得。英國以宗主國之姿對北美十三殖民地抽重稅，點燃美國獨立火苗，那些獅子大開口的大企業，宛如殖民時期英國的現代化身。</p><hr><p>我得不好意思的承認，當我經過這群沮喪的員工旁邊時，我是感到多麼驕傲。我比這些服務櫃台的工作人員年輕數十歲，並且握有進入他們以前未曾、未來也不會接觸的保險庫權利。那時候我並不知道這項特權，意味著該過程可能已經出現了問題，政府只是放棄有意義的管理制度，也不再從內部拔擢人才，新的包商文化崛起，反應出他們不重視的心態。在我職業生涯中，我最深刻的回憶在於，經過服務櫃台的這條通道，顯然已成為情報體系在世代與文化改變的表徵。這些舊世代菁英，艱苦的想要趕上他們懶得了解的科技時代，因此歡迎新世代的年輕駭客進入這項組織化的體系，並讓他們對這個由國家控制的空前科技系統進行開發、全面存取、並發揮完全的權力。</p><hr><p>在中情局上網，必須在同意監看協議的對話方框中打勾，基本上是指你做的每件事都會被紀錄，而且同意不會有任何隱私。由於常勾選該方框，到最後它已成為第二天性。這些協議在工作時多被視若無睹，因為它們經常在螢幕上跳出，你只想把它們消除，重新回到工作上。這是為何多數美國情報體系員工無法感受民眾在網路上被追蹤的不安，並非他們對協助保護美國的數位監督有任何內幕消息，而是在美國情報體系，被老闆追蹤是工作的一部分。</p><p>無論如何，這不是說在公眾網路找到的東西比中情局內部的更有趣。沒有多少人知道中情局有自己的網路與資訊網，有自己版本的臉書，讓情治人員可進行社交，也有自己的維基百科，提供團隊、計畫與任務的相關資訊，以及自己的谷歌，實際上由谷歌所提供，讓情治人員可搜尋機密網路。每個中情局部門都在這個網路上有專屬網址，討論他們的工作與貼上會議記錄和簡報。我每晚都要研讀連續好幾個小時，這成為我的教材。</p><p>根據法蘭克的說法，每個人在中情局內部網路尋找的第一件事就是外星人與九一一，他說，你永遠無法找到有意義的結果，不過我還是搜尋了。中情局版的谷歌並沒有出現任何有趣的東西，但也許真相在另一個網路上。就我所知的紀錄，外星人從未接觸地球，或至少它們沒與美國情報體系聯絡。不過蓋達組織仍與我們的盟國沙烏地阿拉伯有著密切關係，這是當我們與其他兩國交戰時，布希政府企圖隱藏的事實。</p><hr><p>我是基礎通訊訓練課程BTTP6-06班的一員。徽章刻意選棕黃色，其實是要偽裝現今所存最機密與罕見的課程之一。該課程的目標在於訓練TISO（技術資訊安全人員），是中情局菁英通訊員的核心，如果用較不正式的話來說，就是「通訊員」。他們被訓練成無所不能，足可取代過去的密碼員、無線電人員、電力人員、技師、物理與數位安全顧問，還有電腦技術師的角色。這個臥底人員的主要任務，是管理中情局營運的技術基礎設施，在海外多數工作站隱藏在美國外交駐所、領事館與大使館等，是美國國務院的附屬機構。會有這樣的構想是因為，如果在美國大使館，不僅遠離祖國，還被令人無法信任的外國人包圍，無論是敵人或盟友，他們對中情局而言仍是無法信賴的外人，那就需要自己人來負責所有技術需求。如果為了便宜行事，找當地的修理工人來維修祕密間諜基地，他們當然會接下這份工作，不過也可能應外國政府要求，在機器內裝設難以追蹤的竊取裝置。</p><p>因此技術資訊安全人員是負責修理在建築物內的每台機器，從個人電腦、電腦網路至CCTV與HVAC系統、太陽面板、空調系統、緊急發電機、衛星連接、軍事加密設備、警報器、鎖與其他東西等等。它的規定是如果有插頭或插座，它就是技術資訊安全人員的問題。</p><p>這些人也必須知道如何建立系統本身，就像他們必須知道如何摧毀它們。當大使館受到襲擊，所有外交人員與中情局人員都已撤離，技術資訊安全人員通常是最後離開的人。他們破壞、燒毀、清除中情局所留下的痕跡，不論是保險箱的文件或放有暗號文件的桌子，他們要確保剩下的東西對敵人沒有利用價值，之後再傳送最後的「離開」信號給總部。</p><hr><p>那晚天黑後我待在基地，之後開著我的車到山丘高處，把它停在目前已成為穀倉的地方，我們曾在此學習避免敵人監督我們活動的電子相關概念。當時我們學到的方法跟巫毒很像，都是可以將顯示在電腦螢幕上的內容再次重現的能力，只透過內部元件的震盪電流所產生的微弱電磁發射，利用特別的天線接受這些訊號，這種方法稱為范．埃克（Van Eck）竊聽。如果這聽起來難以理解，我必需承認我們也有一樣的感受。指導員聲稱他從未完全了解技術的細節，也無法為我們展示，不過他知道威脅是真的。中情局對其他人進行這項竊聽技術，意味著後者也將如法炮製。</p><hr><p>在網路時代來臨前，如果要存取目標電腦，中情局必須招攬擁有觸及目標的實體途徑的線民。這顯然是危險的建議。因為線民可能在下載情報，或是植入將情報傳送給操作者的軟硬體時遭到逮捕。數位科技在全球的擴散已經大幅簡化該過程。這是「數位網路情報」或「電腦網路操作」的新世界，意味著實體管道已不再需要，降低人類的風險程度，並使人員情報與通訊情報能長久獲得平衡。情報員目前只要傳送訊息，例如將附有惡意程式的電郵傳給目標，中情局不僅可監督目標電腦，還包括整個網路。在如此創新下，人員情報將專注於鎖定對象，通訊情報則負責其它工作。如果賄賂失敗，專案人員不用再透過現金、誘騙或勒索來攏絡線民，只要幾次機靈的駭入電腦，也可得到類似結果。更甚者，目標仍然不知不覺。</p><hr><p>正常而言，當你上網，對任何網站的搜尋，多少會直接連到擁有最終目標的伺服器。還好有被稱為來源與目標標頭的識別碼，每一次搜尋，都會昭告網路過去與未來的足跡。可以把這些標頭想像成明信片的地址。因為它們，讓網站管理員與海外情報體系更容易辨識使用者的網路瀏覽。</p><hr><p>坐在椅上討論如何駭入沒有面孔的聯合國建築物，在心理上容易得多。情報的技術方面不會有這麼多令人心力交瘁的直接接觸，更遑論電腦運算。螢幕距離造就了去個人化的經驗。從窗戶偷窺別人的生活，可以讓我們對自己的行動不那麼在意，減少結果帶來的重大衝突。</p><hr><p>住在日內瓦就像住在平行、或甚至是相反的世界。當世界其他地區愈來愈窮時，日內瓦卻更為繁盛。瑞士銀行雖然並無涉及會導致崩毀的高風險交易，但他們卻很樂意藏匿從別人痛苦中獲利的金錢，而且不用為此負責。二〇〇八年金融海嘯，為十年後席捲至歐洲與美國的民粹危機埋下禍根，也讓我了解到，對大眾造成損害的事通常有利於菁英。美國政府在之後幾年，一再讓我更加確認這個教訓。</p><hr><p>刪除重複數據加上儲存技術優化，使得國安局能儲存情資的時間不斷增加。在我任職期間，國安局設定儲存時間的目標，從收集情資後的數天、數週、數月，一直拉長至五年甚至更久。在這本書出版時，該局能儲存情資的時間或許已達數十年。國安局的邏輯是，收集來的情資一定得儲存起來，日後才能方便運用。但沒人能預測這些情資何時能派上用場。這樣的觀念助長國安局的終極目標，那就是將收集、製造的情資永遠儲存下來，創造出一個完美的記憶庫、一份永久的紀錄檔案。</p><hr><p>所有人都知道（或自以為知道），中國政府管制網路無所不用其極。而有些人知道（或自以為知道），美國監控能力無比巨大，這是我二〇一三年交給記者的文件披露的內容。但請注意，我們可以用科幻小說反烏托邦的口吻說，政府理論上是可以監聽、監看全民的。但政府想實施這樣的制度卻是另一回事。科幻作家筆下的監控世界，在現實中需要動用數千名技術人員與數百萬美元設備才能辦到。當我讀到中國實施監控的技術細節時，文件鉅細靡遺地描述到：政府動用無數設備與機制監控超過十億人民，每日收集、儲存與分析他們數十億通電話與網路通訊，這實在令我大開眼界。我對於這個監控系統的能力與企圖印象深刻，差點忘記這代表的是極權控制的可怕。</p><p>畢竟，中國是個反對民主、一黨獨大的國家。比起美國多數民眾，國安局探員更相信中國是獨裁政體。中國人民的自由並非我的職責，我也無能為力。我唯一可以確定的是，我為好人工作，而這代表我也是好人。</p><p>但我讀到的部分資料令我感到不安。我想起科技進展的基本道理：若可以做到某事，那代表未來可以做到，而之前也可能早就做了。美國能夠掌握如此多中國亂搞的證據，代表美國可能也在做同樣的事。我有種奇怪的直覺，當我讀著關於中國的機密資料時，我看到的是美國的倒影。換句話說，中國光明正大對人民做的監控行徑，美國可能背地裡也對其他國家這麼做。</p><p>雖然說出這件事你可能會恨我，但我必須承認，我當時壓抑內心不安，甚至賣力忽視此事。我告訴自己，中國與美國的差別是很大的，中國防火長城針對國民進行審查與壓制，隔絕人民接觸到海外資訊，而美國監控系統完全是防禦取向，一般民眾根本察覺不到。就我當時對於美國監控狀況的了解，全世界的人都能透過美國網路基礎建設上網，隨意取得他們想要的資訊，中間未經過濾、沒有限制（就算有的話，也是被他們自己國家與美國企業所隔絕，但這並非美國政府管轄範圍）。只有那些有意參與聖戰士攻擊與購買惡意軟體的人，才會遭到追蹤與監控。</p><p>用這個角度來理解，我便能欣然接受美國實施監控。事實上，美國本來就該如此做。我完全支持防禦性、針對特定目標的監控行為，這就像是設立一道有條件的隔絕「防火牆」。這樣的想法讓我的罪惡感一掃而空。</p><p>但我後來輾轉失眠，糾纏在心中的問題縈繞不去。在上台簡報過了好一陣子後，我忍不住開始追查更多資料。</p><hr><p>事實上，偏差定義在整份報告隨處可見，但最離譜的地方莫過於政府更改詞彙意涵。自從PSP於二〇〇一年推動後，恆星風便開始收集通訊記錄，但司法部二〇〇四年抗拒配合，當時小布希政府便更改「取得」（acquire）與「獲得」（obtain）的詞彙定義，試圖讓此計畫過去行徑就地合法。據報告顯示，政府立場是國安局能夠收集他們想要的任何通訊紀錄而不必事先取得搜查令，因為從法律角度來看，只有在國安局從資料庫「搜尋並取得」記錄時，才算是真正的「取得」或「獲得」。</p><p>政府大玩文字遊戲，令我十分火大。因為我非常清楚，國安局希望盡可能收集更多資料並將資料留存時間拉長，最好是保存永久。若這些通訊紀錄僅有使用時才算是「取得」，而永久留存在資料庫算是「未取得」，那這些記錄未來便有被操控的空間。美國政府重新詮釋「取得」與「獲得」的定義，從原本描述情資進入資料庫的過程，扭曲成某人（或某個演算法）未來某時刻查詢並取得資料的行為，如此一來大幅擴充執法機關的權力。政府可以隨時查詢某人過去通訊記錄，尋找構陷他入罪的理由（所有人的通訊必定含有某些事的證據）。而任何新政府（未來國安局的混帳老闆）永遠可以輕鬆按幾下鍵盤，就能立刻追蹤所有人的電話或電腦，知道他們的身分、位置、現在在做什麼、旁邊有誰，以及他們過去的一切記錄。</p><hr><p>國安局將這類資訊稱為「後設資料」（metadata）。這個詞彙的字首「meta」通常指的是「以上」或「超越」，在此則是「有關」之意。而meta-data就是關於數據（data）的資料。更精確來說，它其實是「數據製造出的數據」（透過標籤、標記讓數據變得有用）。但最直覺理解的方式，是將它想成「活動數據」：你在裝置上從事活動與手機自行運作的記錄。舉例來說，手機後設數據可能包括：來電日期與時間、通話長短、來電與本機號碼以及通話位置。而電郵後設數據可能包括：發信者使用的電腦類型、位置與時間，電腦擁有者、寄件人與收信人是誰，何時何地收發信，以及其他能讀取此信的人時地等。透過後設數據的幫助，監視者能得知你昨晚入睡與今早起床的時間、每天逛了哪些地方、在哪裡待了多久，以及你接觸過的對象有誰、誰又與你聯繫過。</p><p>政府聲稱後設數據並未直接觸及通訊實質內涵，但上一段事實駁斥了這種說法。全球數位通訊數量龐大，想監聽所有電話、監看所有電郵是不可能的。即使有可能辦到，這些資訊也沒太大用處，而後設數據有辦法避開這樣的麻煩。我們最好不要認為後設數據只有好的用途，而該認定它是內容的精華部分，畢竟政府監控你的首要目標便是取得後設數據。</p><p>此外，還有一件事值得我們注意。你通常清楚知道自己製造出什麼樣的內容，像是在電話裡說了些什麼，或是在電郵裡寫了什麼。但你對於自己製造出的後設數據幾乎沒有任何掌控權，因為它是自動產生的。後設數據是由機器收集、儲存、分析與製造出來的，不需經過你的參與以及核准。你的裝置無時無刻都在為你溝通，不論你喜歡與否。人類依照自我意志進行溝通，但你的裝置不一樣，它們不會隱藏私人資訊，也不會為了保密使用密碼。它們只知道將手機訊號連上最近的基地台。</p><p>我們的法律通常落後科技至少一個世代，但如今對於通訊內容的保障卻高於後設數據，這真是極大的諷刺。事實上，情報單位對於取得後設數據有著更高興趣，因為這些活動記錄能讓他們見樹又見林，一方面賦予他們分析大量數據的能力、得以拼湊出事物全貌，另一方面又給予他們窺探個人私生活的機會、得以推斷這些人的行為模式。簡言之，監視者透過後設數據能得知你的所有一切，除了你的大腦在想什麼之外。</p><hr><p>我真正了解到這些新科技可能造成的危害。若我們這個世代不介入的話，那未來的情況只會更嚴重。我並不希望看到，當我們終於決定挺身而出時，一切抵抗卻是徒勞無功，若真是如此的話，那將是一大悲劇。未來的一代可能得面對充滿監控的環境，政府違法監控行為並非偶一為之、針對特定危險目標，而是持續性、無差別地擴及全國民眾。這就像是：你說的話逃不過政府耳朵，你做的事逃不過政府法眼，而你的紀錄檔案永遠留存在政府手裡。</p><p>一旦政府擁有四處收集情報的能力，加上情資得以永久儲存的系統，那他們便能隨便找個人或團體陷害，反正資料庫一定搜尋得到證據（如同我尋找機密檔案一樣），絕對能替他們安上合適罪名。</p><hr><p>如果我的親友、鄰居與廣大的民眾如此歡迎企業進到家中，讓他們在家的一舉一動都像上網一樣遭到嚴密監控，那我又何必對政府監控如此不滿。「智慧家庭」的變革可能還有五年才會到來，屆時亞馬遜Echo與Google Home等「虛擬助理」可望正大光明入住臥房，這些放在床頭櫃的裝置將近距離記錄並傳送你的一切活動，牢記你所有習慣與偏好（包含怪癖），之後再透過廣告運算法變現。我們日常生活產生的數據（或說容許生活被監控而產生的數據）能讓企業賺到大筆收入，卻讓我們的隱私蕩然無存。若說政府運用國家力量實施監控，將人民變成調查目標，那企業監控就是讓消費者變成商品，讓他們得以轉賣給其他企業、數據仲介商或廣告業者。</p><hr><p>雲端儲存服務協議的條文逐年增加，現在隨便一個版本都六千字起跳，大約是本書章節平均字數的兩倍。當我們選擇在線上儲存資料時，我們其實是放棄了資料的所有權。這些雲端公司可以決定為我們保留什麼樣的資料，同時任意刪除他們覺得不妥的內容。除非我們在自己的裝置或硬碟留下副本，否則他們刪除的資料就會永遠消失不見。如果資料引起爭議或違反協議的話，這些公司可以單方面刪除我們的帳號，讓我們無法取用自己的資料，但他們手中卻擁有副本，這意味著：他們能在我們未知情同意的情況下，將資料交給執法機關。總歸一句話，只有我們擁有自己的資料，才能保護它不受侵犯。沒有什麼資料是不受保護的，但沒有什麼資料是屬於私人的。</p><hr><p>美國基本法的存在，令執法單位更難執行工作。這並不是瑕疵，而是民主的真諦。按照美國法律規定，執法單位理應保護所有國民。當執法單位濫權時，法院應約束並糾正他們的行為，畢竟他們是社會上唯一能夠羈押、逮捕民眾並使用武力（包括致命武器）的人。而其中最重要的約束是，執法單位不得監控國民在家活動，也不能在未取得搜查令的情況下收集個資。但法律對於公眾場所的監控行為寬鬆許多，其中當然也包含多數人在街頭與人行道的活動。</p><hr><p>這樣一個由機器自動執法的世界，任誰都無法忍受。絕對的正義變成不公不義：一點小錯都會遭到嚴懲、法律全面貫徹到底。幾乎所有社會都存在許多不成文與成文的法律，其中有些條文早已過時，有些甚至連聽都沒聽過。舉例來說，馬里蘭州刑法第10-501條規定，通姦屬於輕罪行為、須支付十美元罰款。而根據北卡羅來納法律第14-309.8條規定，玩賓果遊戲超過五小時便算犯法。這些法律制訂於保守年代，卻不知為何從未遭到廢除。儘管我們自己沒有察覺到，但多數人生活絕不是黑白分明的，我們會任意穿越馬路、未確實做好資源分類、在人行道騎自行車，甚至連上陌生人的網路非法下載盜版等。換句話說，一旦法律貫徹到底，所有人都會變成罪犯。</p><hr><p>在獨裁的國家，國家擁有權利授與給人民。而在自由國家，人民擁有權利授與給國家。在前者，由於政府的允許，身為國民（subject）的人民才能擁有財產、受教、工作、宗教以及言論的權利。而在後者，人民擁有公民（citizen）身分，同意在一定時間內接受統治，但能定期透過選舉等制度更換政府。我認為，獨裁統治與自由民主間的差異，才是我們這個時代最主要的意識形態衝突來源，而不是東方與西方間的分歧（這是人為捏造並且充滿偏見），或是基督教對決伊斯蘭的宗教衝突。</p><p>獨裁國家通常都不是法治政府，而是以統治者意見為主。統治者要求國民服從政府，同時對異議分子極具敵意。相反的，自由民主國家不會或很少做出這樣的要求，反而是仰賴每位公民自願擔負起保護周遭所有人自由的責任，這是不分種族、膚色、信仰、能力、性傾向或性別的。任何集體保障並非取決於血統而是共識，最終導向平等主義的結果。雖然現實的民主經常無法達到理想狀態，但我仍堅信，這是最能「讓不同背景的人共同生活、在法律之前人人平等」的統治形式之一。</p><p>這種平等不僅由權利組成，更包含自由在內。事實上，民主國家的公民所珍惜的許多權利，在法律上都是以限制的方式來保障。透過限制政府權力創造出來的自由空間，使得這些權利得以存在。舉例來說，美國民眾之所以擁有言論「自由」，這是因為禁止政府不得制定限制該自由的法律；而新聞「自由」則是禁止政府不得制定法律限縮該自由。同樣的，宗教「自由」是禁止政府不得制定確立國教的法律；而和平集會與抗議的「自由」，是禁止政府不得制定任何法律來否定此自由。</p><p>在現代生活，我們擁有一致共識，那就是「隱私權」沒有模糊空間、不容政府侵犯。政府不得將髒手伸進此領域，法律唯一允許的辦法是透過搜索令。但這種搜索令無法「擴及所有人」（像是美國政府進行全民監控所聲稱取得的那種），而僅能基於合理理由針對特定人士或用途發出。</p><p>「隱私」這個詞彙有點虛無縹緲，因為難以定義，或說每個人的定義都不一樣，所有人對於隱私都有不同的詮釋。「隱私」的重要性不言可喻，大家想必都能體會。</p><p>正因為隱私缺乏一致性定義，導致多元先進民主國家的公民認為，他們必須交代渴求隱私的理由並將其定位為權利。但他們不必如此做，反而是政府必須說明何以侵害隱私的原因。拒絕主張自己的隱私權等同放棄此權利，將隱私讓渡給違憲政府或是「私人」企業。</p><p>我們根本無法忽視隱私的重要性，因為這與公民自由是相互依存的，你放棄自己的隱私，也會犧牲掉別人的隱私。你可能因為怕麻煩而選擇放棄此權利，或者你和多數人想法一樣，認為只有做不光明的事才需要隱私保護。但是，聲稱自己不需要或不想要隱私，因為沒有什麼事好隱瞞的這種說法，是假定所有人都不該或不能隱瞞任何事情，像是他們的移民身分、失業歷程、財務狀況與健康紀錄等。你假定，所有人（包括你在內）都樂於與他人分享宗教信念、政黨傾向與性生活，就如同有些人隨意透露自己的電影、音樂品味與閱讀偏好一樣。</p><p>說到底，你聲稱自己不在乎隱私，因為沒有事情好隱瞞，這就像是在說，你不在乎言論自由，因為你沒有意見。或是，你不在乎新聞自由，因為你不愛閱讀。你不在乎宗教自由，因為你不相信神。或是，你不在乎和平集會自由，因為反社會的你天性懶散、害怕人群。以上種種自由，今日對你來說也許不重要，但這不代表明日對你不重要，或對你的鄰居不重要，或是對於世界另一端的異議分子不重要。我用手機追蹤這群抗議群眾的動態，他們希望爭取到一點點的自由，而我的國家卻對於這些自由必欲除之而後快。</p><hr><p>我要說的是，我對於簡報內容不是那麼關心，例如，在我揭露的檔案中最為著名的是一份二〇一一年簡報檔中的一堆投影片，用六個面向來描述國安局新的監視立場：「無所不嗅，無所不知，無所不收集，無所不處理，無所不利用，無所不合夥」。這不過是公關講法，行銷術語。它的目的是要讓美國盟國留下印象：澳洲、加拿大、紐西蘭和英國，美國分享情報的主要國家（加上美國，即為五眼聯盟，Five Eyes）。「無所不嗅」表示找尋資料來源；「無所不知」表示查出有些什麼資料；「無所不收集」表示獲取那些資料；「無所不處理」表示分析資料以找出可用的情報；「無所不利用」表示利用那些情報以推動國安局的目的；「無所不合夥」表示與盟國分享新的資料來源。這六個面向容易記住、容易推銷，並且準確表達出國安局的野心規模以及跟外國政府共謀的程度，卻無法讓我了解究竟這項野心是如何在技術層面落實的。</p><p>讓我了解更多的是我從FISA（外國情報監控法）法院找到的一份命令，要求一家民間企業將客戶的私人資訊交給聯邦政府。這類命令通常是根據公共立法授權而在全國發出，可是，命令內文、甚至發出命令，都被列為最高機密。根據「愛國者法案」（Patriot Act）二一五條款，亦即「企業紀錄」條款，政府有權向外國情報監控法院取得命令，強制第三方提供與外國情報或反恐調查「相關的任何實體東西」。可是我所找到的這份法院命令明白表示，國安局祕密地將這項授權詮釋為一份許可，可收集所有「企業紀錄」、後設資料、經由威瑞森（Verizon）、AT&amp;T等美國電信公司的電話通訊，「在經常性的日常基礎上」。當然，這包括美國公民之間的電話通訊紀錄，而此舉是違憲的。</p><p>此外，「外國情報監視法修正案」七〇二條款准許情報體系鎖定任何美國境外可能傳播「外國情資」的外國人，這個廣泛項目的可能對象包括新聞記者、公司員工、學術界、救援人員和無數其他沒有做錯事的無辜者。國安局把這項法案拿來做為其兩項最著名網路監視計畫的依據：稜鏡計畫（PRISM）和上游收集（Upstream Collection）。</p><p>稜鏡計畫讓國安局可以定期由微軟、雅虎、谷歌、臉書、Paltalk、YouTube、Skype、AOL及蘋果收集資料，包括電郵、照片、影音聊天、網路瀏覽內容、搜尋引擎搜尋，以及所有儲存在他們雲端的其他數據，將這些公司變成知情的共犯。不過，上游收集更具侵入性。它可以固定從私部門網路基礎設施，像是全球網路流量的轉換器與路由器，經由太空衛星和高容量海底光纖電纜，直接抓取資料。這項收集是由國安局特別資源行動小組負責，他們打造祕密監聽設備，植入全球網路服務供應商的企業設施內部。加總起來，稜鏡計畫（由網路服務供應商的伺服器強制收集）和上游收集（由網路基礎設施直接收集），確保全球資訊都可受到監視，包括儲存的與傳輸的資訊。</p><p>我的調查的下個階段是要查出這種收集是如何實際辦到的，也就是說，檢視解釋哪些工具支援這項計畫的文件，以及他們如何由拖網式收集的大量通訊中挑選值得進一步檢查的資訊。困難之處在於任何簡報都沒有提到這種資訊，不論機密程度為何，都只能有工程圖解和示意圖。這些是我想找到的最重要資料。不同於五眼推銷簡報，它們將可確切證明我所看到的監視能力不只是一個咖啡因攝取過量的計畫經理人的幻想而已。身為一個不斷被要求加快速度與提高產能的系統工程師，我十分清楚這些機構有時會在實際研發出技術之前就搶先公布，有時是因為一個懸崖型推銷人員承許過多的承諾，有時是出於純粹的野心。</p><p>可是，上游收集的技術確實存在。我後來明白，這些工具是國安局集體監視系統最具侵入性的環節，因為它們最貼近用戶，亦即最貼近被監控的對象。想像你坐在電腦前想去瀏覽一個網站，你開啟一個瀏覽器，鍵入一個網址，然後按入「Enter」。網址其實是一項請求，這項請求會去找它的目的地伺服器。在旅程的途中，在你的請求抵達伺服器之前，便會經過「亂流」（TURBULENCE），國安局最強大的武器之一。</p><p>明確來說，你的請求會經過好幾個堆疊起來的黑色伺服器，加起來大約是四層書櫃的體積。它們裝置在盟國、美國大使館和美國軍事基地大型私人電信建築物裡的特別房間，內建兩項重要工具。第一個是「混亂」（TURMOIL），負責被動式收集，亦即複製進來的數據。第二個是「渦輪」（TURBINE），負責主動式收集，亦即主動監控使用者。</p><p>你可以把「混亂」想成是站在網路流量必須通過的隱形防火牆前的警衛。看到你的請求後，它會檢查自己的後設資料，找尋被標示為值得「提高」注意的選擇器，或者「標準」。這些選擇器可能是國安局選擇或懷疑的任何對象：一個特定的電郵地址，信用卡或電話號碼；你的網路活動的來源地或目的地；或者只是一些關鍵字，例如「匿名網路代理」或「抗議」。</p><p>假如「混亂」覺得你的流量可疑，就會通知「渦輪」，後者便會將你的請求轉到國安局的伺服器。在那裡，演算法會決定要用該機構的哪個惡意程式來監控你。這個選擇係依據你瀏覽的網站種類和你的電腦軟體與網路連結。選定的惡意程式回傳到「渦輪」（經由QUANTUM套裝軟體的程式，如果你好奇的話），再由後者注入流量頻道，連同你請求的網站一同傳送給你。最終結果是：你得到你想要的內容，連同你不想要的監視，而這一切在不到六八六毫秒便發生。你完全不知情。</p><p>等惡意程式進入你的電腦，國安局不但可以存取你的後設資料，還有你自己的資料。你的整個數位人生現在都屬於他們了。</p><hr><p>只有在這種背景下才能完全理解美國政府和洩密的關係。如果有意料之外的好處，他們就會原諒「未經許可的」洩密，並且在「經過許可的」洩密造成傷害時選擇遺忘。然而同樣都是造成傷害、而且不是經過許可的洩密，它們本身就是不合法的，但市政府卻會做出不同的反應，是什麼因素造成有的揭露可以被允許？有的卻不行？</p><p>答案就是權力和控制。如果這次揭露不會威脅到一個機構的基礎權力，才有可能被接受。如果一個機構裡面的不同部門，從收發室到管理辦公室，都有相同的權力可以討論內部事務，那麼管理階層就是放棄了資訊管理的權力，然後整個組織的運作就會產生危機了。爭取發言的平等權，獨立於組織的管理或決策階級之外的，就是「吹哨」這個名詞的適當意義——這種行為尤其對美國情報體系產生威脅，它是在法律允許的神祕面紗下以嚴格區隔的方式來運作。</p><p>依照我的定義，「吹哨者」是一個人經歷了艱苦的經驗，認為他們在機構內的生活已經不符合外界廣大社會的原則，以及對這個社會的忠誠，而這個機構應該要對社會負責。這個人知道自己不能持續待在這個機構了，也知道這個機構不能或不會被廢除。然而，重組這個機構卻是有可能的，所以他吹響哨子，揭露資訊，讓機構負擔來自大眾的壓力。</p><p>針對我的情況，這是一個適當的敘述，還有一個很重要的附加條件：所有我刻意揭露的資訊都是最高機密。要揭發一個祕密計畫，就必須揭發更大的機密系統，揭發它，不是因為美國情報體系宣稱自己是國家的絕對權力，而是美國情報體系濫用這種有限的特權來顛覆民主監督。如果不揭發這整個機密系統，就不可能恢復公民和政府之間的權力均衡。這種希望能恢復的動機就是吹哨的基礎——揭露不是因為對政府有異議或是反對才做出的激進舉動，而是為了掉頭而做出的普通舉動——讓船掉頭回港，在這裡它會被拆解、整修、補起洩漏的地方，才能有重新出發的機會。</p><p>全面揭露關於全民監視的全部設備——不是由我來，而是由媒體來，媒體受到權利法案保護、是美國政府實際上的第四權，對於這種規模的犯罪，這是唯一合適的反應。畢竟光是揭露一個特定或一系列濫用職權的行為是不夠的，他們可以停止（或假裝停止）這些行為，但是原封不動地保留其他不為人知的設備。我打算揭發一個全面的事實——美國政府研發並運用了一套全球全民監視系統，但是卻沒有讓美國公民得知或同意。</p><hr><p>考慮到我所冒的風險，我需要找出我能信任、大眾也可以相信的人。我需要認真、謹慎、獨立而可信賴的記者。他們必須有絕佳能力，能在區別我的懷疑與證據證明的事項之間，對我進行挑戰，當政府不當指控他們的報導將危及他人性命時，對政府提出質疑。最重要的是，我必須確保我挑選的人，在面臨前所未有的壓力時，不會屈服在權力之下。</p><p>我並沒有將網撒得太廣，以免影響這個任務，但仍廣到足以避免一個錯誤點，那就是《紐約時報》的問題。一個記者、一份刊物或一個國家的刊物都不夠，因為美國政府已經顯現扼殺此類報導的決心。理想的情況是，我同時把檔案交給每位記者，自己不會留任何一份。這可以把審查焦點轉移到他們身上，以防一旦我被逮捕，真相仍有機會公諸於世。</p><p>當我縮減這份可能合夥人名單時，我發現這個方向是錯誤的，或者是浪費時間。與其自己挑選記者，我應該讓我企圖揭密的系統為我選人。我決定，最好的合夥人應該是國家安全機構已經鎖定的記者。</p><hr><p>事實上，我們以為的刪除技術從來不曾存在過。刪除不過是一種詭計、一種臆想、一種謊言，是一個電腦為了讓你安心而跟你說的不高明謊言。雖然刪除的檔案在你眼前不見了，卻沒有真正消失。就技術而言，刪除其實只是一個過渡的形式，一種寫入的形式。一般來說，當你按下刪除一個檔案，它的數據仍安然無恙，深埋在磁碟的某處。有效的現代作業系統，並不會單純為了刪除而設計用來在磁碟裡深入搜尋。相反的，只有電腦的檔案表，也就是記錄每個檔案儲存所在的地圖，被改寫為：「我不再使用這個檔案，且此檔案已經失去重要性。」意思是說，就像在一座廣大圖書館裡被忽略的一本書，原本應該消失的檔案，只要你努力的找，還是可以找到。如果你只是消除書目，書本本身是仍然存在的。</p><p>這實際上可以利用實驗來證明。下回你複製一份檔案時，不妨想想為什麼複製檔案要花那麼久的時間，但是刪除檔案只需要一下子。答案是，刪除僅僅是把一個檔案隱藏起來而已。電腦不是設計來矯正錯誤的，而是用來掩藏錯誤，而且是只對不知道去哪裡尋找的人士掩藏。</p><hr><p>刪除是監視者的美夢、被監視者的噩夢，加密則是、或者說應該是所有人的現實。這是對抗監視的唯一真正屏障。如果你的儲存磁碟一開始就加密，你的敵人就無法在裡頭翻尋你已刪除的檔案或是任何東西，除非他們有加密金鑰。如果你的收件匣所有電子郵件都有加密，谷歌便無法透過讀取來收集你的個資，除非他們有加密金鑰。如果你將經過澳洲、英國、美國、中國或俄羅斯的不友善網絡的相關通訊全部加密，間諜便無法讀取，除非他們有加密金鑰。這是加密的基礎原則：金鑰持有者掌握一切權力。</p><hr><p>在我日後交給新聞記者的文件裡，國安局形容XKEYSCORE是「最為全面性」的工具，用以搜尋「使用者在網路上所做的幾乎每一件事。」我研究的技術規格則更為詳盡地說明這是如何辦到的，藉由「封包」與「切分」，亦可以將使用者的線上對話切割成可以管理的封包以進行分析。雖然我已經可以說明，但我仍然最想看到它的實際運作。</p><p>簡單來說，這是我在科學事實中所見過最接近科幻小說的東西：你在這個介面可以輸入幾乎所有的地址、電話號碼或IP網址，然後搜尋近期的線上活動。在某些個案，你甚至可以重新播放他們線上對話的紀錄，你可以看到他們桌機螢幕畫面。你可以閱讀他們的電郵、瀏覽紀錄、搜尋紀錄、社群媒體貼文，所有的一切。你可以設定通知，每當你關注的人員或裝置上線時就會跳出通知。你可以搜尋網路數據封包，看到一個人的搜尋逐字跳出，因為許多網站在每個字母鍵入時便會傳輸出去。這就像看著一份「自動完成」（autocomplete），螢幕上閃過字母與單字。但是，輸入動作的不是電腦而是人類：這是「人工完成」（humancomplete）。</p><p>我在米德堡的那幾個星期，以及我在夏威夷博思艾倫的短暫任職，讓我親眼目睹以前只在內部文件上所讀過的濫權行為實際發生。看到這些，我才明白我在體系層級的地位跟構成立即傷害的原爆點差多遠。我只能想像我和國安局局長或美國總統之間地位的懸殊。</p><p>我並沒有在XKEYSCORE輸入國安局局長或美國總統的名字，但在足夠時間熟悉這個系統之後，我才知道我其實可以。所有人的通訊都在系統裡——所有人。剛開始我擔心我如果搜尋國家高層，我會被逮到並被革職，或者更糟。可是，要偽裝一項搜尋其實很簡單，即使是最知名人物，只要用一種電腦格式將我的搜尋條件編碼即可，那種格式在人類看起來像是塗鴉，但XKEYSCORE卻能完美理解。如果有哪位負責審查搜尋的督察人員費事去深入檢查，他們只會看到片段的亂碼，但我卻能夠搜尋最高法院法官或國會議員最私密的活動。</p><p>就我所知，我的新同事都不打算如此大規模地濫用他們的權力，雖然他們如果真的這麼做了，也沒有提起過。無論如何，當分析師想到濫用系統時，他們在意的不是專業上的目的，而是個人目的。這導致一種稱為LOVEINT（愛人情報）的行徑，這是對於HUMINT（人員情報）及SIGINT（訊號情報）的下流笑話，對情報的嘲弄。分析師會利用國安局的系統去監視他們現任及前任情人以及關心的對象，閱讀他們的電郵，竊聽他們的電話，在線上追蹤他們。國安局員工知道，只有最愚蠢的分析師才會被當場逮到，雖然法律明文指出為個人用途從事任何種類的監控將至少被關上十年，國安局歷史上沒有一個人曾因為這種罪名而被關上一天。分析師知道政府絕對不會公開起訴他們，因為在你不願承認有這種系統存在的前提之下，你無法讓一個人為了濫用全民監視的祕密系統而被定罪。當我和兩名高明的基礎設施分析師坐在國安局總部V22保險庫的牆壁前，我才明白這種政策的代價。他們的工作空間裝飾著一幀《星際大戰》電影知名角色丘巴卡（Chewbacca）的七英尺高照片。其中一人向我仔細說明他的目標的安全例行公事時，我才明白攔截的裸照是一種非正式的辦公室貨幣，因為他的同事不停坐在椅子上轉動，用一個笑容來打斷我們說：「瞧瞧她。」我的指導者千篇一律回答：「中獎了！」或「好極了！」彷彿有一條不成文的交易規定，假如你找到一張漂亮目標的裸照或影片，或是跟監控目標通訊的人的裸照或影片，至少在沒有女性在場的時候，你就必須秀給其他人看。這樣才能知道你可以信任彼此：你參與了其他人的犯罪。</p><p>使用XKEYSCORE之後，你很快便會知道，幾乎全世界每個上網的人都至少有兩個共同點：他們都曾經看過色情內容、他們都儲存了家人的照片和影片。不論性別、種族和年齡，幾乎每個人都一樣，包括最邪惡的恐怖分子和最善良的老年人，他們或許是最邪惡恐怖分子的祖父母、父母或表親。</p><hr><p>在我往返庫尼亞沿街掃描時——原本二十分鐘的車程可能變成兩小時的無線網路掃描——我都在搜尋不同國家，想要找尋跟記者碰面的地點。感覺上我是在挑選自己的監獄，甚至是墓園。五眼聯盟的國家顯然都不在考慮之列。事實上，所有歐洲國家也都剔除，因為你不能指望這些國家在面臨美國強大壓力之下，還能堅守拒絕引渡政治犯的國際法。非洲與拉丁美洲也去不得，美國在當地向來有犯罪也不會被處罰的紀錄。俄羅斯也被排除，因為那是俄羅斯，而中國是中國：這兩國完全無法無天。美國政府不必做什麼事，只要指著地圖，便可以抹黑我。中東的情況更糟糕。有時看起來，我人生最艱鉅的駭客任務不是搜索國安局，而是找尋一個獨立到足以抵抗美國、且自由到不會干涉我的行動的會面地點。</p><p>經過一番消去法，只剩下香港。就地緣政治而言，那裡是我所能找到最接近無人區（no-man’s-land）的地方（在雙方發生戰鬥之前，無人敢進入的地帶），但有著蓬勃的媒體和抗議文化，更別說網路大致上不設限。那裡是一個奇異的地方，一個開明的世界城市，表面上的匿名可以隔絕我與中國，至少限制北京在當下公然對我或記者採取行動的能力。雖然香港實際上屬於北京勢力範圍，但可以減少美國片面干預的可能性。但在無法保證安全的情況下，這已足夠讓我有緩衝時間。反正，我不會有什麼好下場：我所能期望的最佳情況是在我被逮捕前，把真相公諸於世。</p><hr><p>自從《衛報》網站六月九日釋出我的影片後，我便被鎖定了，就像我背後有個標靶。我深知，這些蒙受羞辱的機構絕不會善罷甘休，一直到我落入他們手中為止。過些時候，他們也可能轉移目標、騷擾我心愛的人，同時貶低我的人格，他們會四處打探我私人生活與工作情況，尋找任何可以抹黑我的資訊，或是把握每次造謠的機會。我對於這整個過程並不陌生，畢竟我待在情報單位時讀了不少機密資料，加上我也研究過吹哨者與洩密者的下場。我查過這些英雄的故事，包括過去的丹尼爾．艾斯柏格與安東尼．羅素，以及較近期的托馬斯．塔姆（Thomas Tamm）。塔姆曾在美國司法部情報政策與審查辦公室擔任律師，他爆料政府於二〇〇〇年中期非法竊聽民眾。另外還包括德雷克、賓尼、魏比與魯米斯。魯米斯就像是數位時代的佩里．弗爾沃克（Perry Fellwock），後者早在一九七一年時便揭露當時尚不為人知的國安局機構存在，此舉促使參議院丘奇委員會（情報特別委員會前身）要求國安局僅能收集外國情報，不得監控國內民眾。當然還有舉世聞名的美國陸軍一等兵雀兒喜．曼寧，她因洩露美國戰爭罪行而遭軍事法庭判刑三十五年。她服刑七年後便獲得特赦，原因是她在關禁閉時受到不公平對待，因此引發國際社會抗議。</p><p>不管這些人是否入獄，他們多少都得面對反彈力量，其中多數是非常殘忍的人格摧毀，而背後依據則是政府通過濫權獲得的情報。若這些人私下通訊時曾表現憤怒情緒，那他們會被說是「挾怨報復」。若他們看過心理或精神科醫生，或是在圖書館借過類似書籍，那他們會被認定成「精神錯亂」。若他們曾喝醉酒，那他們必定是酒鬼。若他們有過外遇，那就是生性淫亂。其中不少爆料者因此傾家蕩產。情報單位根本不必與這些異議人士交手，直接破壞他們的名聲還比較快，反正只要動手調出檔案，再放大不利情報或憑空捏造證據即可。</p><hr><p>六月十四日，美國政府以間諜法罪名起訴我，起訴書不對外公開。六月二十一日，他們正式要求引渡我回美國。我知道，這是我該離開的時候，而這天恰好也是我的生日。</p><p>正當美國國務院提出引渡要求之際，我的律師收到聯合國難民署的回應，他們表明無法協助我取得庇護。而香港政府（不論是否受到中國施壓）抗拒聯合國呼籲，不願在他們的領土上提供我國際保護，並宣稱他們必須顧及美方要求。換句話說，香港要我回到美國並在牢中向聯合國求助。我不只是孤單一人，且在各國都不受歡迎。如果我想自由地離開香港的話，我必須現在就走。我清空手中四部筆電資料並銷毀加密金鑰，這代表我再也無法取用機密文件，即便美國政府強迫我也無法做到。我將僅有的幾件衣服打包好便起身離開。「芳香的海港」根本沒有我容身之處。</p><hr><p>美國政府決定以間諜法起訴我，我被控犯下政治罪，意思是受害者是政府而非個人。按照國際人道法規定，遭控犯下此罪的人通常不會遭到引渡，因為起訴政治犯經常是獨裁國家打壓異議的手段。理論上，這代表吹哨者在全球各地都應獲得同等保障。但實際上卻不是這麼一回事，特別是當你的對手是自認正義的美國政府時。表面上聲稱扶植海外民主國家的美國政府，私底下卻成立由私人承包的祕密機隊，專門用於「非常規引渡」，也就是部分人口中說的「綁架」。</p><hr><p>我們在莫斯科機場受困長達四十天四十夜。在這段期間，我總共向二十七國申請政治庇護。沒有任何一個國家膽敢起身對抗美國，有些國家一口回絕，部分國家則表示，除非我抵達他們境內，否則無法考慮這項請求，而這根本是不可能的事。最後，唯一同情我的國家元首只有一個，那就是「漢堡王」，它從未否決我大啖華堡（內含番茄與洋蔥）的請求。</p><p>過了不久，我滯留機場的消息傳遍全球，俄國當局最後也覺得有些麻煩。七月一日，玻利維亞總統埃沃．莫拉萊斯（Evo Morales）結束天然氣輸出國論壇年度大會後，他搭乘專機從莫斯科伏努科沃機場離開。由於莫拉萊斯曾對我的處境表達同情，美方懷疑我藏匿在專機裡，於是施壓義大利、法國、西班牙與葡萄牙不准飛機進入他們國家領空，最終導致專機迫降於奧地利首都維也納。此專機遭到停飛、搜索，直到確認沒有我的蹤跡才放行。這嚴重侵害玻利維亞國家主權，聯合國也予以譴責。此事令俄國顏面無光，因為他們無法確保來訪的國家元首順利回家。而這也讓俄國政府與我都確信一點：任何美國懷疑我用來偷渡的飛機，恐怕都難逃迫降與停飛的命運。</p><p>俄國政府決定盡快擺平此事，並還給莫斯科機場一個清淨，別老是被大批媒體包圍。八月一日，俄國決定給予我暫時庇護。莎拉和我得以離開謝列梅捷沃機場，但莎拉能回到美國老家。我們一起共患難的時光，讓我和莎拉變成終生摯友。我永遠感激，她這幾個禮拜以來的陪伴，她是如此地正直坦率、堅韌勇敢。</p><hr><p>如果你在閱讀本書時有任何時刻因為一個名詞而停了下來，你想要釐清或進一步調查，於是在搜尋引擎鍵入該名詞，而且如果那個名詞碰巧有些可疑，像是XKEYSCORE，那麼我要恭喜你：你已落入系統了，淪為自己好奇心的受害者。</p><p>但是，即便你沒有在線上搜尋任何東西，心懷不軌的政府仍然不費力氣便可查出你有閱讀本書。最起碼，它不費什麼力氣便可查出你有這本書，不論你是否非法下載或者在線上購買精裝本，或者在實體商店用信用卡購買。</p><p>你只不過想要閱讀而已——參與這項最親密的人類行為，透過語言進行思想交流。但這已經太過足夠了。想要與世界聯繫的自然慾望，便足以讓你的生活跟這個世界連接起來，將你自己帶進一系列全球獨特的識別碼，例如你的電郵、電話和個人電腦IP網址。藉由創造一個遍及世界的系統，經由每一種可能的電子通訊管道來追蹤這些識別碼，美國情報體系讓自己掌握權力，得以記錄與永久儲存你人生的資料。</p><p>而這只是開始而已。因為一旦美國諜報機構發現他們可以被動收集你所有的通訊，他們便會開始主動惡搞。他們在發給你的訊息中植入攻擊程式碼，亦即「漏洞利用」（exploit），藉此取得你的文字以外的資訊。現在他們有能力全面控制你的整體裝置，包括照相鏡頭和麥克風。這意味著，如果你在手機、平板電腦，或是任何現代機器上閱讀一本書，不論讀到哪裡，他們都可以追蹤及讀取你。他們可以分辨你翻頁的速度是快是慢，你有沒有一章接一章看下去或者是跳著看。他們會樂意忍受看著你的鼻孔，看著你邊讀邊扭動嘴唇，只要他們可以獲得想要的資料，確定辨識你這個人就好了。</p><p>這是二十年來無節制發展科技的下場，政治與專業階級夢想著成為全民主宰的最終產物。無論何地、何時及何事，你的生活如今已成為一本翻開的書，能夠隨時被讀取。</p><hr><p>或許在完美的世界，也就是並不存在的烏托邦裡，單憑法律就可以讓這些工具失去作用。但在我們現在所在的世界，它們變得極有必要。修改法律絕對比修改技術標準來得更加難以達成，只要法律創新落後科技創新的一日，就一定會有機構試圖濫用這種科技和資訊的不對等來助長他們自己的利益。這時便需要依賴獨立、開放原始碼的硬體和軟體開發者來填補這種差距，提供法律無法或者不願意確保的重要公民自由保障。</p><hr><p>早在出生前，當科技偵測到我們在子宮裡，我們便開始創造這份資料，即使在我們死後，我們的資料仍不斷增加。當然，我們有意識地製造的記憶、選擇保存的紀錄，不過是我們人生被企業與政府的監控所擰出來的資訊的其中一個小碎片，而大多是無意識地，或是未經我們同意。我們是地球歷史上首度遭遇這種情況的人，是首度背負著永久檔案的人，也就是說我們被收集的紀錄將永久存在。正因為如此，我們才有特殊責任。我們必須確保自己過去的紀錄不會被用來對付我們，或者對付我們的子孫。</p><hr><p>演算法用以分析資料，找尋既定行為模式以推斷未來行為，這種數位預言只是比看手相的類比方法稍微準確一些而已。一旦你深入挖掘用以預測的實際技術機制，你便會了解這種科學實際上是反科學，而且名稱大錯特錯：預測其實是操弄。一個網站告訴你說，由於你喜歡這本書，所以你或許也喜歡國家情報總監克拉柏或前國家安全局局長海登的書，這並不是什麼有根據的猜測，而是一種「微妙的強制」機制。</p><p>我們不能放任自己受到這樣的利用，被利用來對抗未來。我們不能允許自己的資料被用來向我們推銷絕對不可以出賣的東西，例如新聞。如果袖手不管，所看到的新聞將只是我們想要的新聞，或是當權者希望全民看到的新聞，而不是必要的坦白共同對話。不能放任我們所受到的全面監控，以之來「計算」我們的公民分數，或是「預測」我們的犯罪行為；我們會受什麼教育，會找到什麼工作，或是能否受教育或找工作；依據金融、法律和醫療紀錄來歧視我們，更別說還有族群或種族，這些都是我們的資料的構成因素。至於個人最私密的資料，我們的基因資訊：如果坐視這種資訊被用來辨識我們，那麼它也會被用來加害我們，甚至修改我們，按照試圖控制全民的科技概念，重新塑造我們的人性本質。</p><p>當然，以上種種全部都已經發生了。</p><hr><p>以上摘自：</p><p><img src="https://i.loli.net/2019/11/27/uPxiWOLqvnKmRBd.jpg" alt="《永久檔案》"><br><a href="https://zh.wikipedia.org/wiki/%E6%B0%B8%E4%B9%85%E6%AA%94%E6%A1%88" target="_blank" rel="noopener">《永久檔案》</a><br>作者: 愛德華・斯諾登<br>出版社: 時報文化出版社<br>ISBN: 9781250237231</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;深入鳳梨田底下的一條坑道——珍珠港時代的一座舊地下飛機廠——我坐在終端機前，可以幾近無限地取得世界上幾乎所有男女老幼的通訊，只要人們曾經撥打過一通電話或碰觸過一部電腦。這些人當中，包括三億二千萬美國同胞，他們日常生活的一舉一動都遭到監視，不僅嚴重違反美國憲法，更是違背自由社會的基本價值。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;人生是什麼？不只是我們說了些什麼，甚至不只是做了些什麼。人生亦在於我們所喜愛的、所相信的。以我而言，我最喜愛和相信的，是連結，人際的連結，以及促成這些的科技。當然，這些科技也包括書籍。但在我這個世代，連結，主要意味著網際網路。&lt;/p&gt;
&lt;p&gt;在你產生反感、明白網際網路瘋狂毒害我們這個時代之前，請諒解，對我來說，當我認識網際網路之時，那是很不一樣的東西。網路既是朋友，也是父母，是一個無邊界、無限制的社群，既是單一、也是無數的聲音，一個已經有人墾殖但尚未遭到剝削的共同邊境，各式各樣的部落和睦相處，每個成員都能自由選擇自己的姓名、歷史和風俗習慣。每個人都戴著面具，然而這種多數匿名造就的文化所產生的事實多於造假，因為重點在於創造與合作，而不是商業與競爭。當然這之間也會有衝突，但善意與善念會勝過衝突——而這正是真正的先驅精神。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;往線上發展電子商務的早期浪潮很快便成為泡沫，接著在本世紀之初終於破滅。在那之後，企業界明白，人們在線上的興趣不在於消費，更在於分享，而且網路促成的人際連結是可以賣錢的。如果人們在線上想做的事主要是跟家人、朋友和陌生人報告自己的近況，從而得知家人、朋友和陌生人的近況，那麼企業只需要設法將自己擠進這些社交互動之中，再從中獲利即可。&lt;/p&gt;
&lt;p&gt;這便是監視資本主義（surveillance capitalism）的開端，也是我原先所認知的網路的終點。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;美國政府在全然漠視開國憲章之下，屈服於這種誘惑，而且一旦嚐過這棵毒樹的果實，便陷入狂熱無法自拔。在暗地裡，政府掌握全民監視的權力，這種權威就定義上而言，對無辜者的傷害遠大於對犯罪者的傷害。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://acuario.xyz/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://acuario.xyz/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>为Chrome for Windows设置临时Socks5代理</title>
    <link href="https://acuario.xyz/setting-socks5-with-chrome-for-windows/"/>
    <id>https://acuario.xyz/setting-socks5-with-chrome-for-windows/</id>
    <published>2019-11-25T13:53:06.000Z</published>
    <updated>2019-11-25T14:13:22.950Z</updated>
    
    <content type="html"><![CDATA[<p>如何为 Windows 的 Chrome 设置 Socks5 代理，网上千篇一律的文章都是教你使用 Chrome 扩展 <a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif?hl=zh-CN" target="_blank" rel="noopener">Proxy SwitchyOmega</a> 来实现。</p><p>但无法使用代理突破网络封锁，又怎么在 Chrome 扩展商店下载使用 Proxy SwitchyOmega 呢？（Chrome 67 以后不再支持安装本地 <code>.crx</code> 扩展）这就成了先有鸡还是先有蛋的问题。</p><p>如果局域网内已有可用的 Socks5 代理服务，<strong>在不安装任何程序的情况下</strong>（我就是不想装什么 Proxifier），其实简单几步即可实现：</p><ol><li>关闭所有 Chrome 窗口和进程</li><li><p>右键点击 Chrome 快捷方式，查看属性，获得 Chrome 程序的目标位置，如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Program Files (x86)\Google\Chrome\Application\chrome.exe</span><br></pre></td></tr></table></figure></li><li><p>打开运行（Ctrl+R），输入命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;chrome.exe&gt;   --show-app-list  --proxy-server=&quot;SOCKS5://&lt;address&gt;:&lt;port&gt;&quot;</span><br></pre></td></tr></table></figure></li></ol><p>例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Program Files (x86)\Google\Chrome\Application\chrome.exe   --show-app-list  --proxy-server=&quot;SOCKS5://192.168.1.10:1080</span><br></pre></td></tr></table></figure></p><ol start="4"><li>运行上述命令后打开的 Chrome 已经自动设置了 Socks5 临时代理，如果 Socks 服务正常的话，你可以畅快地访问 Chrome 扩展商店安装 Proxy SwitchyOmega 了。后面的骚操作就不多说了。</li></ol><p>写到这里突然想起来，其实 Socks5 服务<strong>有没有在局域网内都无所谓</strong>，只要正确设置地址和端口即可。</p><p>别忘了这是临时代理，除非运行上述命令启动 Chrome，否则重启 Chrome 代理设置失效。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如何为 Windows 的 Chrome 设置 Socks5 代理，网上千篇一律的文章都是教你使用 Chrome 扩展 &lt;a href=&quot;https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgc
      
    
    </summary>
    
      <category term="教程" scheme="https://acuario.xyz/categories/%E6%95%99%E7%A8%8B/"/>
    
      <category term="软件使用" scheme="https://acuario.xyz/categories/%E6%95%99%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="教程" scheme="https://acuario.xyz/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Windows" scheme="https://acuario.xyz/tags/Windows/"/>
    
      <category term="Chrome" scheme="https://acuario.xyz/tags/Chrome/"/>
    
      <category term="PC" scheme="https://acuario.xyz/tags/PC/"/>
    
      <category term="Proxy" scheme="https://acuario.xyz/tags/Proxy/"/>
    
      <category term="Socks5" scheme="https://acuario.xyz/tags/Socks5/"/>
    
  </entry>
  
  <entry>
    <title>实用浏览器小书签</title>
    <link href="https://acuario.xyz/shortcut-bookmarklet/"/>
    <id>https://acuario.xyz/shortcut-bookmarklet/</id>
    <published>2019-11-14T13:02:40.000Z</published>
    <updated>2019-11-14T14:40:55.808Z</updated>
    
    <content type="html"><![CDATA[<p>由于众所周知的原因，非会员下载百度网盘的速度慢的令人发指，所以目前最推荐的度盘下载工具是 <a href="https://pandownload.com/" target="_blank" rel="noopener">Pandownload</a>，但是软件本身需要登录百度账号，如果账号被限速也没辙。经笔者实测，发现 Pandownload 的<a href="https://www.baiduwp.com/" target="_blank" rel="noopener">网页版</a>配合 Aria2 可以无账号高速下载。不过这不是本文重点。</p><p>Pandownload 允许用户将度盘分享链接中的 <code>baidu</code> 修改为 <code>baiduwp</code> 后进行访问，可直接解析资源后下载。频繁点击 URL 修改实在麻烦。受<a href="/simplify-URL/">《用 JavaScript 为 URL 瘦身》</a>一文的启发，想到可以用 JS 制作小书签，即点即用。</p><p>不知道小书签为何物的话，可以参阅少数派的<a href="https://sspai.com/post/45662" target="_blank" rel="noopener">这篇文章</a></p><p>本文提供一些笔者自己收藏使用的小书签，拖动下方链接到浏览器收藏栏即可保存。</p><ul><li><p>下载百度网盘：<a href="javascript:(function(){ location.href = location.href.replace('baidu', 'baiduwp'); })();" target="_blank" rel="noopener">度盘下载</a></p></li><li><p>下载百度文库：<a href="javascript:(function(){ location.href = location.href.replace('baidu', 'baiduvvv'); })();" target="_blank" rel="noopener">文库下载</a></p></li><li><p>查看该网页在各大搜索引擎的网页快照：<a href="javascript:(function(){ location.href = location.href.replace(location.hostname, 'his.sh/'+location.hostname); })();" target="_blank" rel="noopener">Cache</a></p></li><li><p>繁体转换为简体：<a href="javascript:(function(){var s=document.getElementById('tongwenlet_cn');if(s!=null){document.body.removeChild(s);}var s=document.createElement('script');s.language='javascript';s.type='text/javascript';s.src='https://git.oschina.net/runningcheese/JiathisQR.js/raw/master/bookmarklet_cn.js';s.id='tongwenlet_cn';document.body.appendChild(s); })();" target="_blank" rel="noopener">繁转简</a></p></li><li><p>最好用的网页翻译——彩云小译：<a href="javascript: void((function () {  if (!document.body) {    return  }  var popup = document.querySelectorAll('.cyxy-target-popup');  if (popup && popup.length > 0) {    return  }  try {    var trs = document.createElement('script');    trs.type = 'text/javascript';    trs.charset = 'UTF-8';    trs.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'caiyunapp.com/dest/trs.js';    document.body.appendChild(trs);  } catch (e) {    alert(e);  }  document.addEventListener('securitypolicyviolation', function handler(e) {    console.error('securitypolicyviolation', e);    alert('由于当前网站的内容安全策略(Content Security Policy)，小译无法启动翻译程序，您可以在Chrome Web商店搜索彩云小译（LingoCloud）下载插件，或者将网页保存在本地（右键 -> 另存为）进行翻译，也欢迎您在手机应用商店下载彩云小译App ：)');    document.removeEventListener('securitypolicyviolation', handler);  });})());" target="_blank" rel="noopener">小译</a></p></li><li><p>转换 HTTP 为 HTTPS：<a href="javascript:(function(){ if (location.href.indexOf('https://') == -1) { location.href = location.href.replace('http://', 'https://'); } })();" target="_blank" rel="noopener">https</a></p></li><li><p>复制 URL 但不转换内部中文：<a href="javascript:(function(){   const el = document.createElement('textarea');  el.value = decodeURIComponent(location.href);  document.body.appendChild(el);  el.select();  document.execCommand('copy');  document.body.removeChild(el); })();" target="_blank" rel="noopener">复制URL</a></p></li><li><p>去除 URL 跟踪代码：<a href="javascript: (function() { function getQueryString(name) { var reg = new RegExp('(^|&)' + name + '=([^&]*)(&|$)', 'i'); var r = window.location.search.substr(1).match(reg); if (r != null) return r[2]; return null; } var site = window.location.href.match(/^http(s)?:\/\/[^?]*/); var id = getQueryString('id'); var q = getQueryString('q'); if (id != null) { var pureUrl = site[0] + '?id=' + id; } else if (q != null) { var pureUrl = site[0] + '?q=' + q; } else if (site[0].substr(site[0].length - 13) == 'view_shop.htm') { var pureUrl = window.location.protocol + '//' + window.location.host; } else { var pureUrl = site[0]; } /* Apple Store 将国家设置为中国 Start */ pureUrl = pureUrl.replace(/^http(s)?:\/\/itunes\.apple\.com\/(\w{2}\/)?([^\/]+)\/([^\/]+\/)?(id\d+).*/, 'https://itunes.apple.com/cn/$3/$5'); /* Apple Store 将国家设置为中国 End */ /* Chrome Store 地址精简优化 Start */ pureUrl = pureUrl.replace(/^http(s)?:\/\/chrome\.google\.com\/webstore\/detail\/[^\/]+\/([a-z]{32}).*/, 'https://chrome.google.com/webstore/detail/$2'); /* Chrome Store 地址精简优化 End */ if (pureUrl) { window.history.pushState({},0,pureUrl); } })();" target="_blank" rel="noopener">链接洗白白</a></p></li></ul><p>网络上有很多提供小书签的网站，比如<a href="https://www.runningcheese.com/bookmarklet" target="_blank" rel="noopener">这个</a>，如果你会 JavaScript 的话也可以自己制作。欢迎各位在评论区分享你的小书签。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于众所周知的原因，非会员下载百度网盘的速度慢的令人发指，所以目前最推荐的度盘下载工具是 &lt;a href=&quot;https://pandownload.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Pandownload&lt;/a&gt;，但是软件本身需要登录
      
    
    </summary>
    
      <category term="分享" scheme="https://acuario.xyz/categories/%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="小书签" scheme="https://acuario.xyz/tags/%E5%B0%8F%E4%B9%A6%E7%AD%BE/"/>
    
      <category term="浏览器" scheme="https://acuario.xyz/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Laravel实用技巧</title>
    <link href="https://acuario.xyz/some-skills-in-laravel/"/>
    <id>https://acuario.xyz/some-skills-in-laravel/</id>
    <published>2019-10-31T15:43:40.000Z</published>
    <updated>2019-10-31T15:50:41.612Z</updated>
    
    <content type="html"><![CDATA[<p>Laravel 作为大名鼎鼎的 PHP Web 框架，有着「过度设计」的美誉（滑稽）。也就免不了附带着一些需要学习和摸索才能掌握的奇技淫巧（好吧其实只需要看看文档就行）。笔者结合自身的开发经验，把值得一提的东西梳理成文，便于读者在使用 Laravel 进行开发时事半功倍。</p><h1 id="Composer"><a href="#Composer" class="headerlink" title="Composer"></a>Composer</h1><p>已经 9102 年了，Composer 作为 PHP 的包管理工具，相信已经不需要做介绍了。使用 Laravel 的过程中不可避免地会使用到各种各样的第三方包，Laravel 毫无疑问是使用 Composer 进行包管理的，对于国内开发者而言，第一件事显然是把 Composer 换为国内源，只需执行一下命令即可修改全局设置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ composer config -g repo.packagist composer https://packagist.phpcomposer.com</span><br></pre></td></tr></table></figure><h1 id="调试代码"><a href="#调试代码" class="headerlink" title="调试代码"></a>调试代码</h1><h2 id="打印变量"><a href="#打印变量" class="headerlink" title="打印变量"></a>打印变量</h2><p>一般使用框架自带的 <code>dd()</code> 方法而不是 PHP 原生方法 <code>print_r()</code> 或 <code>var_dump()</code> 来打印变量信息，因为 <code>dd()</code> 方法可以打印多个任何类型变量：<code>dd($object, 123, [123, 324]);</code></p><p>顺便一提，所谓 <em>dd</em> 的意思是 <strong>dump, die</strong>，而在最新的 Laravel 6 框架中，新增了 <code>ddd()</code> 方法，它是 <code>dd()</code> 方法的升级版，意思是 <strong>dump, die, debug</strong>，你可以在<a href="https://flareapp.io/blog/1-introducing-ddd-a-new-global-helper-for-laravel" target="_blank" rel="noopener">这篇文章</a>查看该方法的介绍。</p><h2 id="打印-SQL-语句"><a href="#打印-SQL-语句" class="headerlink" title="打印 SQL 语句"></a>打印 SQL 语句</h2><p>在使用框架的 ORM 查询构造器时，可以通过 <code>toSql()</code> 方法输出原生 SQL 语句。</p><p>SQL 语句中的参数值由于被 <code>?</code> 代替，可以使用 <code>getBindings()</code> 输出构造器中的查询条件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$builder = DB::table(&apos;user&apos;)-&gt;where(&apos;id&apos;, 1);</span><br><span class="line">$bindings = $builder-&gt;getBindings();</span><br><span class="line">$sql = str_replace(&apos;?&apos;, &apos;%s&apos;, $builder-&gt;toSql());</span><br><span class="line">$sql = sprintf($sql, ...$bindings);</span><br><span class="line"></span><br><span class="line">dd($sql);</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="数据库迁移"><a href="#数据库迁移" class="headerlink" title="数据库迁移"></a>数据库迁移</h2><p>参考文档：<a href="https://learnku.com/index.php/docs/laravel/6.x/migrations/5173" target="_blank" rel="noopener">数据库迁移</a></p><p>Laravel 提供了一整套的数据库迁移方案，便于开发使用代码直接创建、修改数据库的表结构，而无需繁琐地书写表结构的 SQL 语句。首先使用如下命令生成迁移文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ php artisan make:migration do_some_migration</span><br></pre></td></tr></table></figure><p>然后在 <code>/database/migrations/</code> 目录下找到对应的迁移文件 <code>2019_08_29_172043_do_some_migration.php</code>，根据业务需求设计表结构：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">use Illuminate\Support\Facades\Schema;</span><br><span class="line">use Illuminate\Database\Schema\Blueprint;</span><br><span class="line">use Illuminate\Database\Migrations\Migration;</span><br><span class="line"></span><br><span class="line">class DoSomeMigration extends Migration</span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">     * Run the migrations.</span><br><span class="line">     *</span><br><span class="line">     * @return void</span><br><span class="line">     */</span><br><span class="line">    public function up()</span><br><span class="line">    &#123;</span><br><span class="line">        // 创建user表</span><br><span class="line">        Schema::create(&apos;user&apos;, function (Blueprint $table) &#123;</span><br><span class="line">            $table-&gt;increments(&apos;id&apos;);</span><br><span class="line">            $table-&gt;timestamps();         // 创建生成时间和修改时间字段</span><br><span class="line">            $table-&gt;softDeletes();        // 创建软删除字段</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        // 修改post表</span><br><span class="line">        Schema::table(&apos;post&apos;, function (Blueprint $table) &#123;</span><br><span class="line">            $table-&gt;uuid(&apos;user_id&apos;)-&gt;after(&apos;id&apos;)-&gt;comment(&apos;外键关联模型&apos;);  // 新增字段</span><br><span class="line">            $table-&gt;string(&apos;name&apos;, 50)-&gt;change();                          // 修改字段属性</span><br><span class="line">            $table-&gt;renameColumn(&apos;from&apos;, &apos;to&apos;);                            // 字段重命名</span><br><span class="line">            $table-&gt;dropColumn(&apos;votes&apos;);                                   // 删除字段</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Reverse the migrations.</span><br><span class="line">     *</span><br><span class="line">     * @return void</span><br><span class="line">     */</span><br><span class="line">    public function down()</span><br><span class="line">    &#123;</span><br><span class="line">        Schema::dropIfExists(&apos;user&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成表结构设计之后执行如下命令进行数据库迁移，如果数据库配置无误的话，框架会按照迁移文件自动创建、修改表结构，完成数据库迁移操作：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ php artisan migrate          // 完成所有未执行的迁移</span><br><span class="line">$ php artisan migrate --force  // 强制执行迁移</span><br><span class="line">$ php artisan migrate:rollback // 回滚所有迁移  </span><br><span class="line">$ php artisan migrate:refresh  // 回滚所有迁移，并重新执行所有迁移，相当于重建数据库</span><br></pre></td></tr></table></figure><h2 id="数据库填充"><a href="#数据库填充" class="headerlink" title="数据库填充"></a>数据库填充</h2><p>参考文档：<a href="https://learnku.com/index.php/docs/laravel/6.x/seeding/5174" target="_blank" rel="noopener">数据填充</a></p><p>后端开发最头疼的就是模拟数据了，特别是新建数据库以后还要一条一条记录手动 mock 那就太糟心了。Laravel 自带了一个数据库填充引擎，可以按照工厂填空类进行数据库填充测试数据。这里分三步走战略：</p><ol><li>准备对应模型类和数据填充工厂类</li><li>生成数据填充执行类</li><li>执行填充</li></ol><h3 id="准备类文件"><a href="#准备类文件" class="headerlink" title="准备类文件"></a>准备类文件</h3><p>创建工厂类之前你务必要先准备好对应的 <code>User</code> 模型，在本例中，<code>User</code> 模型文件位于 <code>/app/User.php</code>，然后创建工厂类 <code>/database/factories/UserFactory.php</code> ，并为每个字段写好数据填充要求：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">use Illuminate\Support\Str;</span><br><span class="line">use Faker\Generator as Faker;</span><br><span class="line"></span><br><span class="line">$factory-&gt;define(App\User::class, function (Faker $faker) &#123;</span><br><span class="line">    return [</span><br><span class="line">        &apos;name&apos;              =&gt; $faker-&gt;name,</span><br><span class="line">        &apos;email&apos;             =&gt; $faker-&gt;unique()-&gt;safeEmail,</span><br><span class="line">        &apos;email_verified_at&apos; =&gt; now(),</span><br><span class="line">        &apos;password&apos;          =&gt; &apos;$2y$10$TKh8H1.PfQx37YgCzwiKb.KjNyWgaHb9cbcoQgdIVFlYg7B77UdFm&apos;, // secret</span><br><span class="line">        &apos;remember_token&apos;    =&gt; Str::random(10),</span><br><span class="line">    ];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="生成填充执行类"><a href="#生成填充执行类" class="headerlink" title="生成填充执行类"></a>生成填充执行类</h3><p>使用如下命令生成填充执行类文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ php artisan make:seeder UserTableSeeder</span><br></pre></td></tr></table></figure><p>修改 <code>/database/seeds/UserTableSeeder.php</code> 文件，约束填充的记录条数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">use Illuminate\Database\Seeder;</span><br><span class="line"></span><br><span class="line">class UserTableSeeder extends CommonSeeder</span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">     * Run the database seeds.</span><br><span class="line">     *</span><br><span class="line">     * @return void</span><br><span class="line">     */</span><br><span class="line">    public function run()</span><br><span class="line">    &#123;</span><br><span class="line">        static $createdAt;</span><br><span class="line"></span><br><span class="line">        //单独插入一条数据</span><br><span class="line">        App\User::insert([</span><br><span class="line">            &apos;id&apos;             =&gt; 1,</span><br><span class="line">            &apos;name&apos;           =&gt; &apos;admin&apos;,</span><br><span class="line">            &apos;password&apos;       =&gt; sha1(&apos;ooxxooxx&apos;),</span><br><span class="line">            &apos;email&apos;          =&gt; &apos;&apos;,</span><br><span class="line">            &apos;remember_token&apos; =&gt; str_random(60),</span><br><span class="line">            &apos;created_at&apos;     =&gt; $createdAt ?: $createAt = $this-&gt;randDate(),</span><br><span class="line">            &apos;updated_at&apos;     =&gt; $createdAt ?: $createdAt = $this-&gt;randDate(),</span><br><span class="line">        ]);</span><br><span class="line"></span><br><span class="line">        //生成 4 个用户</span><br><span class="line">        factory(App\User::class, 4)-&gt;create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并在 <code>/database/seeds/DatabaseSeeder.php</code> 从添加需要填充的类文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">use Illuminate\Database\Seeder;</span><br><span class="line"></span><br><span class="line">class DatabaseSeeder extends Seeder</span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">     * Run the database seeds.</span><br><span class="line">     *</span><br><span class="line">     * @return void</span><br><span class="line">     */</span><br><span class="line">    public function run()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;call([</span><br><span class="line">            PostTableSeeder::class,</span><br><span class="line">            UserTableSeeder::class,</span><br><span class="line">        ]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行填充"><a href="#执行填充" class="headerlink" title="执行填充"></a>执行填充</h3><p>执行数据库填充命令收货一堆假数据：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ php artisan db:seed                             // 执行 DatabaseSeeder.php 内定义的所有数据库填充</span><br><span class="line">$ php artisan db:seed --class=ExampleTableSeeder  // 执行指定填充类的数据填充</span><br></pre></td></tr></table></figure><h2 id="伪造数据"><a href="#伪造数据" class="headerlink" title="伪造数据"></a>伪造数据</h2><p>可以看到上述填充类中使用了 <code>$faker</code> 这个玩意儿，其对应的是一个可堪使用的数据填充工具 <a href="https://github.com/fzaninotto/Faker" target="_blank" rel="noopener">Faker</a>，提供了诸如电话号码、地址、邮箱、用户名、文章标题、文章摘要、文章内容、图片链接等一系列的填充项，基本能够覆盖大部分需求。关于中文数据填充的相关操作可以阅读《<a href="https://blog.csdn.net/luyaran/article/details/74732423" target="_blank" rel="noopener">使用 Laravel 数据填充功能生成中文测试数据</a>》</p><p>另外，框架自带的 <code>Illuminate\Support\Str</code> 也提供了很多丰富的字符串处理方法可堪使用。</p><h2 id="查询构造器"><a href="#查询构造器" class="headerlink" title="查询构造器"></a>查询构造器</h2><p>参考文档：<a href="https://learnku.com/index.php/docs/laravel/6.x/queries/5171" target="_blank" rel="noopener">查询构造器</a></p><p>这部分没太多可说的，掌握基本的 <code>select()</code>、<code>where()</code>、<code>whereIn()</code>、<code>group()</code>、<code>latest()</code>、<code>get()</code>、<code>paginate()</code> 基本可以完成 80% 的工作了，需要提到的是，由于查询构造器的查询方法返回值不同，这里需要格外注意：</p><ul><li><code>find($id)</code> 需要一个 id 并返回一个模型。如果不存在匹配的模型，则返回 <code>null</code>。</li><li><code>findOrFail($id)</code> 需要一个 id 并返回一个模型。如果不存在匹配的模型，则会引发错误，它会抛出一个 <code>error</code>。</li><li><code>first()</code> 返回在数据库中找到的第一条记录。如果不存在匹配的模型，则返回 <code>null</code>。</li><li><code>firstOrFail()</code> 返回在数据库中找到的第一条记录。如果不存在匹配的模型，则会引发错误。它会抛出一个 <code>error</code>。</li></ul><h1 id="Eloquent-ORM"><a href="#Eloquent-ORM" class="headerlink" title="Eloquent ORM"></a>Eloquent ORM</h1><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>参考文档：<a href="https://learnku.com/index.php/docs/laravel/6.x/eloquent/5176" target="_blank" rel="noopener">查询构造器</a></p><p>在定义模型时，有两个模型类属性比较重要：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected $guarded = [&apos;id&apos;, &apos;deleted_at&apos;];      //不可批量更新字段</span><br><span class="line">protected $hidden  = [&apos;deleted_at&apos;];    //查询时不可见字段</span><br></pre></td></tr></table></figure><p>上述字段可以视为<strong>黑名单</strong>属性，对应的<strong>白名单</strong>属性为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected $fillable = [&apos;name&apos;];     //可批量更新字段</span><br><span class="line">protected $visible  = [&apos;tag&apos;];      //查询时可见字段</span><br></pre></td></tr></table></figure><h2 id="软删除"><a href="#软删除" class="headerlink" title="软删除"></a>软删除</h2><p>相关操作参见：<a href="https://laravelacademy.org/post/1020.html" target="_blank" rel="noopener">Eloquent ORM 实例教程 —— 模型删除及软删除相关实现</a></p><p>某些表字段设计为软删除，而非物理删除，在模型内使用软删除，只需两步：</p><ol><li>引用软删除 trait</li><li>增加软删除字段</li></ol><h3 id="引用软删除-Trait"><a href="#引用软删除-Trait" class="headerlink" title="引用软删除 Trait"></a>引用软删除 Trait</h3><p>首先在目标模型上使用  <code>Illuminate\Database\Eloquent\SoftDeletes</code> trait：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace App;</span><br><span class="line"></span><br><span class="line">use Illuminate\Database\Eloquent\Model;</span><br><span class="line">use Illuminate\Database\Eloquent\SoftDeletes;</span><br><span class="line"></span><br><span class="line">class Flight extends Model</span><br><span class="line">&#123;</span><br><span class="line">    use SoftDeletes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="增加软删除字段"><a href="#增加软删除字段" class="headerlink" title="增加软删除字段"></a>增加软删除字段</h3><p>这一部分不再赘述，可以参照前文数据库迁移部分，新增一个软删除字段，默认新增的软删除字段名为 <code>deleted_at</code>。</p><p>你也可以手动修改数据库表结构增加自定义名称的软删除字段，当然，你需要在对应的模型中使用 <code>DELETED_AT</code> 类常量指定自定义的软删除字段名：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace App;</span><br><span class="line"></span><br><span class="line">use Illuminate\Database\Eloquent\Model;</span><br><span class="line">use Illuminate\Database\Eloquent\SoftDeletes;</span><br><span class="line"></span><br><span class="line">class Flight extends Model</span><br><span class="line">&#123;</span><br><span class="line">    use SoftDeletes;</span><br><span class="line">    const DELETED_AT = &apos;custom_delete_colunm&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h3><p>一般来说，完成前述设置后已经可以正常使用软删除，当你在模型实例上使用 <code>delete()</code> 方法删除数据实例时，当前日期时间会写入 <code>deleted_at</code> 字段，表示该记录被软删除。同时，查询出来的结果也会自动排除已被软删除的记录。</p><p>需要硬删除的话使用 <code>forceDelete()</code> 方法即可。</p><p>为了使模型定义更加清晰，不妨在目标模型内设置类成员变量，显式指定 <code>deleted_at</code> 字段的类型：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected $dates = [&apos;deleted_at&apos;];</span><br></pre></td></tr></table></figure><p>当然，如果你不想将该字段的值设为删除日期，也可以对其进行改造，具体改造方式可以参阅《<a href="http://blog.dreamlikes.cn/archives/892" target="_blank" rel="noopener">Laravel5软删除（SoftDeletes）的deleted_at改造</a>》</p><h2 id="修改器"><a href="#修改器" class="headerlink" title="修改器"></a>修改器</h2><p>对数据库字段的特殊处理，可以使用 <a href="https://learnku.com/docs/laravel/5.7/eloquent-mutators/2297" target="_blank" rel="noopener">Eloquent 修改器</a> 对入库字段进行预处理，比如姓名首字母大写才能入库等等。</p><p>另外，某字段储存为 json 格式，处理时需要转换为 PHP 数组，也只需在模型内声明 <code>$cast</code> 属性加入 array 类型转换，当你访问的时候就会自动被转换为 PHP 数组：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected $casts = [</span><br><span class="line">    &apos;options&apos; =&gt; &apos;array&apos;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><p><code>cursor</code> 方法允许你使用游标遍历数据库，它只执行一次查询。处理大量的数据时， <code>cursor()</code> 方法可以大大减少内存的使用量，比如导入、导出数据时，如果直接 <code>foreach</code> 遍历变量，可能会犹豫变量太大导致内存溢出。此事使用基于迭代器的游标可以大大提升程序的鲁棒性：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foreach (Flight::where(&apos;foo&apos;, &apos;bar&apos;)-&gt;cursor() as $flight) &#123;</span><br><span class="line">    //</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关联模型"><a href="#关联模型" class="headerlink" title="关联模型"></a>关联模型</h2><p>参考文档：<a href="https://learnku.com/index.php/docs/laravel/6.x/eloquent-relationships/5177" target="_blank" rel="noopener">关联模型</a></p><p>这一部分可以说是 Laravel 的精髓所在。框架设计的模型关联可以将多个模型之间的关联关系在 Model 中定义清楚，便于数据查询和后期维护，特别是在例如列表页、详情页等需求中轻松地获取有关联关系的将数据对象，完全无需自己手动拼接、处理数据。</p><p>举两个例子：</p><ul><li><p>在 User 和 Post 模型中绑定关联关系后，就可以使用 <code>$post-&gt;comments</code> 来获取该文章对应的全部评论。</p></li><li><p>在列表查询时，可能需要减少多次查询，避免 <code>1+N</code> 次查询。比如文章列表：</p><ol><li>获取文章</li><li>获取每篇文章的评论</li></ol></li></ul><p>ps. 数据库中文章表为 <code>post</code>，评论表为 <code>comment</code></p><p>如果遍历 <code>$posts</code> 使用关联查询 <code>$post-&gt;comments</code> 将造成过多不必要的 SQL 查询。假设该页有 10 条 post 记录，正常情况将执行 <code>1+10=11</code> 条 SQL。为解决这种多查询问题，可以使用<a href="https://learnku.com/docs/laravel/5.8/eloquent-relationships/3932#eager-loading" target="_blank" rel="noopener">预加载</a>来实现最简查询。</p><p>使用时，在查询语句中使用 <code>with()</code> 即可，如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$books = App\Book::with(&apos;author&apos;)-&gt;get();</span><br><span class="line"></span><br><span class="line">foreach ($books as $book) &#123;</span><br><span class="line">    echo $book-&gt;author-&gt;name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取关联对象的数量可以使用<a href="https://learnku.com/docs/laravel/5.8/eloquent-relationships/3932#counting-related-models" target="_blank" rel="noopener">关联模型计数</a> 的 <code>withCount()</code> 方法，它将放在结果模型的 <code>{relation}_count</code> 列，如：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$posts = App\Post::withCount(&apos;comments&apos;)-&gt;get();</span><br><span class="line"></span><br><span class="line">foreach ($posts as $post) &#123;</span><br><span class="line">    echo $post-&gt;comments_count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><p>处理跨域问题可以考虑使用 <a href="https://xueyuanjun.com/post/9273.html" target="_blank" rel="noopener">Laravel CORS 扩展包</a></p><hr><p>暂时就写这么多，上述技巧基本可以涵盖常见的 CURD 需求（滑稽。如果你有其他推荐的奇技淫巧不妨在评论区留言。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Laravel 作为大名鼎鼎的 PHP Web 框架，有着「过度设计」的美誉（滑稽）。也就免不了附带着一些需要学习和摸索才能掌握的奇技淫巧（好吧其实只需要看看文档就行）。笔者结合自身的开发经验，把值得一提的东西梳理成文，便于读者在使用 Laravel 进行开发时事半功倍。&lt;/p&gt;
&lt;h1 id=&quot;Composer&quot;&gt;&lt;a href=&quot;#Composer&quot; class=&quot;headerlink&quot; title=&quot;Composer&quot;&gt;&lt;/a&gt;Composer&lt;/h1&gt;&lt;p&gt;已经 9102 年了，Composer 作为 PHP 的包管理工具，相信已经不需要做介绍了。使用 Laravel 的过程中不可避免地会使用到各种各样的第三方包，Laravel 毫无疑问是使用 Composer 进行包管理的，对于国内开发者而言，第一件事显然是把 Composer 换为国内源，只需执行一下命令即可修改全局设置：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ composer config -g repo.packagist composer https://packagist.phpcomposer.com&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;调试代码&quot;&gt;&lt;a href=&quot;#调试代码&quot; class=&quot;headerlink&quot; title=&quot;调试代码&quot;&gt;&lt;/a&gt;调试代码&lt;/h1&gt;&lt;h2 id=&quot;打印变量&quot;&gt;&lt;a href=&quot;#打印变量&quot; class=&quot;headerlink&quot; title=&quot;打印变量&quot;&gt;&lt;/a&gt;打印变量&lt;/h2&gt;&lt;p&gt;一般使用框架自带的 &lt;code&gt;dd()&lt;/code&gt; 方法而不是 PHP 原生方法 &lt;code&gt;print_r()&lt;/code&gt; 或 &lt;code&gt;var_dump()&lt;/code&gt; 来打印变量信息，因为 &lt;code&gt;dd()&lt;/code&gt; 方法可以打印多个任何类型变量：&lt;code&gt;dd($object, 123, [123, 324]);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;顺便一提，所谓 &lt;em&gt;dd&lt;/em&gt; 的意思是 &lt;strong&gt;dump, die&lt;/strong&gt;，而在最新的 Laravel 6 框架中，新增了 &lt;code&gt;ddd()&lt;/code&gt; 方法，它是 &lt;code&gt;dd()&lt;/code&gt; 方法的升级版，意思是 &lt;strong&gt;dump, die, debug&lt;/strong&gt;，你可以在&lt;a href=&quot;https://flareapp.io/blog/1-introducing-ddd-a-new-global-helper-for-laravel&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这篇文章&lt;/a&gt;查看该方法的介绍。&lt;/p&gt;
&lt;h2 id=&quot;打印-SQL-语句&quot;&gt;&lt;a href=&quot;#打印-SQL-语句&quot; class=&quot;headerlink&quot; title=&quot;打印 SQL 语句&quot;&gt;&lt;/a&gt;打印 SQL 语句&lt;/h2&gt;&lt;p&gt;在使用框架的 ORM 查询构造器时，可以通过 &lt;code&gt;toSql()&lt;/code&gt; 方法输出原生 SQL 语句。&lt;/p&gt;
&lt;p&gt;SQL 语句中的参数值由于被 &lt;code&gt;?&lt;/code&gt; 代替，可以使用 &lt;code&gt;getBindings()&lt;/code&gt; 输出构造器中的查询条件：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;?php&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$builder = DB::table(&amp;apos;user&amp;apos;)-&amp;gt;where(&amp;apos;id&amp;apos;, 1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$bindings = $builder-&amp;gt;getBindings();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$sql = str_replace(&amp;apos;?&amp;apos;, &amp;apos;%s&amp;apos;, $builder-&amp;gt;toSql());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$sql = sprintf($sql, ...$bindings);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dd($sql);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://acuario.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="PHP" scheme="https://acuario.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/PHP/"/>
    
      <category term="Laravel" scheme="https://acuario.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/PHP/Laravel/"/>
    
    
      <category term="学习笔记" scheme="https://acuario.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="教程" scheme="https://acuario.xyz/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="PHP" scheme="https://acuario.xyz/tags/PHP/"/>
    
      <category term="Laravel" scheme="https://acuario.xyz/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>播客札记（四）：消费主义&amp;审美</title>
    <link href="https://acuario.xyz/podcast-note-4/"/>
    <id>https://acuario.xyz/podcast-note-4/</id>
    <published>2019-09-15T17:29:19.000Z</published>
    <updated>2019-09-15T17:38:09.975Z</updated>
    
    <content type="html"><![CDATA[<h1 id="翻转问答-VOL30-道理能解决消费主义和奢侈的否定欲望？"><a href="#翻转问答-VOL30-道理能解决消费主义和奢侈的否定欲望？" class="headerlink" title="翻转问答 VOL30 | 道理能解决消费主义和奢侈的否定欲望？"></a>翻转问答 VOL30 | 道理能解决消费主义和奢侈的否定欲望？</h1><p><a href="https://podtail.com/podcast/翻转电台flip-radio/--30/" target="_blank" rel="noopener">Episode Archive</a></p><h2 id="道理无法解决问题"><a href="#道理无法解决问题" class="headerlink" title="道理无法解决问题"></a>道理无法解决问题</h2><ul><li>消费主义本身并不是一个多深的批判，对消费主义的批评不需要过高的学术门槛。</li><li>批判难度低并不意味着不具备批判价值。</li><li>掌握道理本身不难，但改变和解决问题并不能通过了解某个道理来完成。</li></ul><h2 id="个人主义与消费依存"><a href="#个人主义与消费依存" class="headerlink" title="个人主义与消费依存"></a>个人主义与消费依存</h2><ul><li>消费主义与消费不是一回事。</li><li>个人主义兴起之后，社会分工的消费交换使消费主义与消费的关联越来越紧密。</li><li>依靠消费来维持日常生活，并不一定是消费主义的，而「由单一消费提供一切」的生活就是消费主义的。举例来说，购买器材录制播客，在录制过程中产出的内容并不是消费行为本身能够购买而来的，所以这一行为本身不是消费主义的。简单来看，消费过程中是否有内容产出，可以视为判断是否是消费主义的一个依据。</li></ul><h2 id="平民主义与消费权的平等"><a href="#平民主义与消费权的平等" class="headerlink" title="平民主义与消费权的平等"></a>平民主义与消费权的平等</h2><ul><li>消费权的平等伴随这消费门槛的降低而逐渐消失。在过去，某些消费具有门槛，例如衣冠不整不可进入餐厅；贵族社会使用的产品为特供等。</li><li>消费权的不平等意味着在既有时代背景下，消费作为一种客体并不是最重要的东西，而导致消费不平等的因素或许比消费更重要，例如前述例子中的文明程度、权力等。</li><li>平民主义兴起使得导致消费权不平等的因素越来越被反对，导致消费权不平等的各种特权亦被排斥，进而消逝。例如，一辆好车应该卖给谁，不以驾驶技术高低而论，而是价高者得。</li><li>在诉诸消费权平等的过程中，金钱逐渐成为了决定消费的最重要的要素。附着在消费行为上的其他价值被渐渐瓦解，消费内涵的价值成了钱的价值。</li><li>追求钱的价值会让物质的使用意义逐渐消逝，成为被观看的现象，让<strong>社会景观化</strong>。</li><li>物质本身的使用价值，需要更多的公共场合来展示，需要更多的公众关注。公共场合越小，公共场合越萎缩，社会越景观化，社会就越容易进入消费主义。</li></ul><a id="more"></a><h2 id="奢侈的问题"><a href="#奢侈的问题" class="headerlink" title="奢侈的问题"></a>奢侈的问题</h2><ul><li>消费社会和消费品不仅提供了某种视觉表象，对于使用者而言还展示某种不必要的奢侈体验。其背后有强烈的「由俭入奢易，由奢入俭难」效应。抖音在互联网时代带给人廉价甚至无物质成本的奢侈体验，带给人高频率的精神刺激，这是任何文艺作品无法提供的。</li><li>消费主义自身提供了特别自洽的体系，当人进入消费主义之后，真正的阻碍只有是自身经济和金钱的成长。买的越多，则愈加排除传统价值，而消费主义又可在此过程中提供充足的合理化说辞，让人满足于符号消费和消费主义本身，从而维持一个「快乐的生活」，在现代社会下，「快乐生活」更容易被看到，也导致了对个体自身更多的正向反馈。</li></ul><h2 id="人必然会选择消费主义吗"><a href="#人必然会选择消费主义吗" class="headerlink" title="人必然会选择消费主义吗"></a>人必然会选择消费主义吗</h2><ul><li>人的满足是边际效益递减的，这要求人的消费越来越多，越来越快。这和资本主义的生产力过剩不谋而合。从方方面面来看，消费主义都符合现代社会的特征。</li></ul><h2 id="生的，肯定的，创造的欲望与死的，否定的，消费的欲望"><a href="#生的，肯定的，创造的欲望与死的，否定的，消费的欲望" class="headerlink" title="生的，肯定的，创造的欲望与死的，否定的，消费的欲望"></a>生的，肯定的，创造的欲望与死的，否定的，消费的欲望</h2><ul><li>巴塔耶的耗费经济学认为，消费是一种浪费（waste），消费具有强烈的「浪费」和「毁灭」的欲望的。现代社会对多媒体作品的消费，根本上算是一种浪费和毁灭。其他领域的消费也包含巨大的浪费、过剩和毁灭的意味。</li><li>巴塔耶普遍经济学的意图就是把衰败的世界与人的内在生命、主观经验协调一致。这有死的世界，他认为是物质性的、普遍的能量之流，不停顿地要求消耗和散失，最终意味着我们能累积起来的资源的完全毁灭。</li><li>消费主义本身是一种强烈的否定的、死的欲望，无论对于物品还是自己，消费主义强调的是浪费、毁灭、自我的物化、自我的非人化；其反面是生的欲望，强调的是自我独特性、强调生存、强调自我肯定，它导向的是创造行为而非消费行为，这与规模化的商品生产和直接获取他人商品背道而驰。</li><li>死的欲望不是在生理上杀死人，而是在精神上让人不是「人」。在消费主义内部，有强烈的让人不是人的冲动。这种冲动一方面来自经济系统本身——它需要人通过这种浪费的、标准化的消费来否定自己，也是人在资本主义背景下的自我选择。</li><li>整个城市的分工生活，是所有「奢侈」的集合。「奢侈」选择包含着否定的、死的欲望，过多的「奢侈」选择会阻碍人作为人的发展，让人进入非人化的状态。</li></ul><h2 id="消费主义不是死局"><a href="#消费主义不是死局" class="headerlink" title="消费主义不是死局"></a>消费主义不是死局</h2><ul><li>消费主义真正控制我们的三个要素：<ul><li>奢侈快感</li><li>对社会景观的依赖</li><li>奢侈与背后的一套概念</li></ul></li><li>从任何角度对消费主义「控制三要素」的回击，都是自我生活和个体发展尝试脱离消费主义的有效途径。</li><li>消费主义不是非此即彼，例如看电影行为本身是消费主义，但如果能留下对电影本身的任何创造性内容，那看电影本身就不再是消费主义行为。</li><li>消费主义和技术进步带来的便利性，有些是创造的便利性，有些是享乐和消费的便利性，但在系统内部二者并非对称关系，消费的便利性远远大于创造的便利性。即便技术的发展让人的创造成本大大降低，但实际上人的享乐成本被降低得更多。</li><li>考虑反对消费主义的消费选择，可以从消费本身的创造性可能来进行衡量。</li><li>西方的思想（古希腊）认为「知道」就是美德，而东方的思想（印度）认为践行才是美德，人不可能通过对道理的思考和理解来改变生活，而需要切身实践。</li><li>消费主义不是死局，切实可行的建议是，为了与你有关系的人，创作个什么东西，一顿佳肴，一篇文章，一幅画，什么都行</li></ul><hr><h1 id="翻电问答-VOL21-美的丧失与美的教育"><a href="#翻电问答-VOL21-美的丧失与美的教育" class="headerlink" title="翻电问答 VOL21 | 美的丧失与美的教育"></a>翻电问答 VOL21 | 美的丧失与美的教育</h1><p><a href="https://podtail.com/podcast/翻转电台flip-radio/翻电问答-21-美的丧失与美的教育/" target="_blank" rel="noopener">Episode Archive</a></p><ul><li>批评美丑前，需要对自我生活的文化选择和评价进行审视和思考。</li><li>对美丑的批判难以取得共识，而相对容易获得共识的批判一般出现在公权力介入的美丑批判中，如商店的标牌规范、公共建筑规范。</li><li>如今对艺术作品的评价，多用一个哲学框架进行分析，而非进行美和丑的简单判断，批判的难度并不低。但另一方面，人们又乐于进行审美评判。</li></ul><h2 id="美与丑的界限是模糊的么？"><a href="#美与丑的界限是模糊的么？" class="headerlink" title="美与丑的界限是模糊的么？"></a>美与丑的界限是模糊的么？</h2><ul><li>导致批判美丑变为难以进行的话题的一大原因是大众认为「美与丑的界限是模糊的」。</li><li>对善恶、美丑的讨论容易陷入复杂论的视角，即认为讨论的主体是不可轻易判断、得出结论的。亦容易产生明显的主客二元论想法，认为「美丑是个主观的东西」。「____是主观的」一类防守性言论也容易让人服从于达成共识的压力，产生难以达成共识的思维惯性，阻碍沟通与思考。</li><li>康德在《判断力批判》中认为，美是一种先验综合，虽然美是主观判断，但并不是不可讨论之物：</li></ul><blockquote><p>一个对象，一束美丽的花，引起了我们的情感，而这种情感呢，我认为它是有普遍性的，我把这种情感叫做 “美”。我相信人人看到这朵花都会觉得美，都会有这种情感。具体的东西里有普遍性，不需要你带来一个概念加在它的上面，去规定它，它自己就表现出某种普遍性了。就是说，这朵花，它可以引起每一个人的美感，这种美感是有普遍性的。那么，“这朵花是美的”，这个判断与 “这朵花是植物”，或者 “这朵花是红的” 这样的判断，是大不一样的。——<a href="https://zhuanlan.zhihu.com/p/23421249" target="_blank" rel="noopener">邓晓芒：康德的《判断力批判》主要在讲什么？</a></p></blockquote><ul><li>「美」是高度词义弱化和异化的词汇，导致对美的讨论难以进行：<ul><li>美的生理学基础中，最常被讨论的是性冲动与审美的关系——这是人际关系劣化的的结果，认为人与人的关系变为生理性要素占主导地位，但这样动物性的视角在谈论美的时候过于狭隘。</li><li>科学主义的劣化途径使得「美」更易被量化，易于得出基于数据的结果，能够形成具有统计学意义的实验。让人产生「美」具有建构性特点的错觉，并将美视为与先验无关，并无实质基础的社会文化综合产物。</li></ul></li></ul><h2 id="美育可以解决美的问题么？"><a href="#美育可以解决美的问题么？" class="headerlink" title="美育可以解决美的问题么？"></a>美育可以解决美的问题么？</h2><ul><li>生活中接受美与丑的门槛都是相同的，个体审美能力的缺失在于忽视美的存在，而非商业或政治的责任。</li><li>对美育的痴迷并不能解决人最根本的审美问题。教育万能论的思维导向让人认为美育能够改变人的审美能力，但实际上，文化教育不能让人有文化，美育教育亦不能让人有审美。</li><li>教育只能给人知识，让人了解知识、掌握技术和逻辑推理，但无法让人获得审美能力，因为「美」是直觉判断的能力而非外部学习的存在。 </li></ul><h2 id="审美是一种技能和能力吗？"><a href="#审美是一种技能和能力吗？" class="headerlink" title="审美是一种技能和能力吗？"></a>审美是一种技能和能力吗？</h2><ul><li>审美是人在成长过程中逐渐唤醒的判断力。它在儿时以潜能的方式蕴藏于体内，因此是先验的，这个潜能在综合的不断判断之中慢慢唤起。正如荣格所认为的那样，人在儿时并不具有纯真、美好的品质，人在出生时什么都没有，这些潜能随着人的逐渐长大生发出来，才慢慢出现了这些品质。</li></ul><h2 id="美的-“缺失”-就是-“拒绝长大”"><a href="#美的-“缺失”-就是-“拒绝长大”" class="headerlink" title="美的 “缺失” 就是 “拒绝长大”"></a>美的 “缺失” 就是 “拒绝长大”</h2><ul><li>对「美」本身的否定，一方面否定了成长给人带来的差异，「拒绝长大」没，否定了成长带来品质的改变；另一方面拒绝了当下所处环境的恶劣，拒绝了充斥着丑恶的生存空间。</li><li>当今社会相对单一的审美判断，使得人们普遍不认为成长应该视为获得美的途径，从而过分看重「成长」之外的东西，例如财富、地位、资源。</li><li>美是一个责任——人的决断要求人以某种特定判断力作为标准，而非儿时的生理快感作为判断力标准。获得以美作为标准的判断力需要承担的最大责任是「相信」，相信美感需要的是决断、专注和对自我的承诺。放弃对美的信任，就可以随波逐流，让美流失。</li><li>一切以消费、逃避的心态对待美都是不可能获得美的。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;翻转问答-VOL30-道理能解决消费主义和奢侈的否定欲望？&quot;&gt;&lt;a href=&quot;#翻转问答-VOL30-道理能解决消费主义和奢侈的否定欲望？&quot; class=&quot;headerlink&quot; title=&quot;翻转问答 VOL30 | 道理能解决消费主义和奢侈的否定欲望？&quot;&gt;&lt;/a&gt;翻转问答 VOL30 | 道理能解决消费主义和奢侈的否定欲望？&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://podtail.com/podcast/翻转电台flip-radio/--30/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Episode Archive&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;道理无法解决问题&quot;&gt;&lt;a href=&quot;#道理无法解决问题&quot; class=&quot;headerlink&quot; title=&quot;道理无法解决问题&quot;&gt;&lt;/a&gt;道理无法解决问题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;消费主义本身并不是一个多深的批判，对消费主义的批评不需要过高的学术门槛。&lt;/li&gt;
&lt;li&gt;批判难度低并不意味着不具备批判价值。&lt;/li&gt;
&lt;li&gt;掌握道理本身不难，但改变和解决问题并不能通过了解某个道理来完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;个人主义与消费依存&quot;&gt;&lt;a href=&quot;#个人主义与消费依存&quot; class=&quot;headerlink&quot; title=&quot;个人主义与消费依存&quot;&gt;&lt;/a&gt;个人主义与消费依存&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;消费主义与消费不是一回事。&lt;/li&gt;
&lt;li&gt;个人主义兴起之后，社会分工的消费交换使消费主义与消费的关联越来越紧密。&lt;/li&gt;
&lt;li&gt;依靠消费来维持日常生活，并不一定是消费主义的，而「由单一消费提供一切」的生活就是消费主义的。举例来说，购买器材录制播客，在录制过程中产出的内容并不是消费行为本身能够购买而来的，所以这一行为本身不是消费主义的。简单来看，消费过程中是否有内容产出，可以视为判断是否是消费主义的一个依据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;平民主义与消费权的平等&quot;&gt;&lt;a href=&quot;#平民主义与消费权的平等&quot; class=&quot;headerlink&quot; title=&quot;平民主义与消费权的平等&quot;&gt;&lt;/a&gt;平民主义与消费权的平等&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;消费权的平等伴随这消费门槛的降低而逐渐消失。在过去，某些消费具有门槛，例如衣冠不整不可进入餐厅；贵族社会使用的产品为特供等。&lt;/li&gt;
&lt;li&gt;消费权的不平等意味着在既有时代背景下，消费作为一种客体并不是最重要的东西，而导致消费不平等的因素或许比消费更重要，例如前述例子中的文明程度、权力等。&lt;/li&gt;
&lt;li&gt;平民主义兴起使得导致消费权不平等的因素越来越被反对，导致消费权不平等的各种特权亦被排斥，进而消逝。例如，一辆好车应该卖给谁，不以驾驶技术高低而论，而是价高者得。&lt;/li&gt;
&lt;li&gt;在诉诸消费权平等的过程中，金钱逐渐成为了决定消费的最重要的要素。附着在消费行为上的其他价值被渐渐瓦解，消费内涵的价值成了钱的价值。&lt;/li&gt;
&lt;li&gt;追求钱的价值会让物质的使用意义逐渐消逝，成为被观看的现象，让&lt;strong&gt;社会景观化&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;物质本身的使用价值，需要更多的公共场合来展示，需要更多的公众关注。公共场合越小，公共场合越萎缩，社会越景观化，社会就越容易进入消费主义。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="播客札记" scheme="https://acuario.xyz/categories/%E6%92%AD%E5%AE%A2%E6%9C%AD%E8%AE%B0/"/>
    
    
      <category term="Podcast" scheme="https://acuario.xyz/tags/Podcast/"/>
    
      <category term="播客" scheme="https://acuario.xyz/tags/%E6%92%AD%E5%AE%A2/"/>
    
      <category term="翻转电台" scheme="https://acuario.xyz/tags/%E7%BF%BB%E8%BD%AC%E7%94%B5%E5%8F%B0/"/>
    
      <category term="消费主义" scheme="https://acuario.xyz/tags/%E6%B6%88%E8%B4%B9%E4%B8%BB%E4%B9%89/"/>
    
      <category term="欲望" scheme="https://acuario.xyz/tags/%E6%AC%B2%E6%9C%9B/"/>
    
      <category term="审美" scheme="https://acuario.xyz/tags/%E5%AE%A1%E7%BE%8E/"/>
    
      <category term="美丑" scheme="https://acuario.xyz/tags/%E7%BE%8E%E4%B8%91/"/>
    
  </entry>
  
  <entry>
    <title>《Modern PHP》学习笔记</title>
    <link href="https://acuario.xyz/modern-php-summary/"/>
    <id>https://acuario.xyz/modern-php-summary/</id>
    <published>2019-08-24T08:33:23.000Z</published>
    <updated>2019-08-24T08:52:09.940Z</updated>
    
    <content type="html"><![CDATA[<h1 id="命名空间（namespace）"><a href="#命名空间（namespace）" class="headerlink" title="命名空间（namespace）"></a>命名空间（namespace）</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>PHP 命名空间与操作系统的物理文件系统不同，这是一个虚拟概念，没必要和文件系统中的目录结构完全对应。但是大多数 PHP 组件为了兼容 PSR-4 自动加载器标准，会把子命名空间放到文件系统的子目录中。</li><li>从技术层面来看，命名空间只是 PHP 语言中的一种记号，PHP 解释器会将其作为前缀添加到类、接口、函数和常量的名称前面。</li><li>不同代码可能使用相同的类名、接口名、函数名或常量名，如果不使用命名空间，名称会起冲突，导致 PHP 执行出错。而使用命名空间，把代码放在唯一的厂商命名空间中，这样不同命名空间下的代码就可以使用相同的名称命名类、接口、函数和常量。</li><li>在同一个命名空间或子命名空间中的所有类没必要在同一个 PHP 文件中声明。你可以在 PHP 文件的顶部指定一个命名空间或子命名空间，此时，这个文件中的代码就是该命名空间或子命名空间的一部分。因此，我们可以在不同的文件中编写属于同一个命名空间的多个类。</li></ul><a id="more"></a><h2 id="导入和别名"><a href="#导入和别名" class="headerlink" title="导入和别名"></a>导入和别名</h2><ul><li><strong>导入</strong>是指在每个 PHP 文件中告诉 PHP 想使用哪个命名空间、类、接口、函数和常量。导入后就不用输入全名了。</li><li><strong>创建别名</strong>是指告诉 PHP 我要使用简单的名称引用导入的类、接口、函数或常量。</li><li>使用 <code>use</code> 关键字导入代码时无需在开头加上符号，因为 PHP 假定导入的是<strong>完全限定</strong>的命名空间。</li><li><code>use</code> 关键字必须出现在<strong>全局作用域</strong>中（即不能在类或函数中），因为这个关键字在编译时使用。不过，use 关键字可以在命名空间声明语句之后使用，导入其他命名空间中的代码。</li><li>导入函数和常量:</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">use func Namespace\functionName;</span><br><span class="line">use constant Namespace\CONST_NAME;</span><br><span class="line">functionName();</span><br><span class="line">echo CONST_NAME;</span><br></pre></td></tr></table></figure><ul><li><strong>一个文件定义一个类</strong>，一个文件只使用一个命名空间。</li><li>有些代码可能没有命名空间，这些代码在全局命名空间中。如果需要在命名空间中引用其他命名空间中的类、接口、函数或常量，必须使用完全限定的 PHP 类名（命名空间类名）。在命名空间中引用全局命名空间中的代码时，要在类、接口、函数或常量的名称前加上 <code>\</code> 符号。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace My\App;</span><br><span class="line"></span><br><span class="line">Class Foo</span><br><span class="line">&#123;</span><br><span class="line">    public function dosomething() &#123;</span><br><span class="line">        $exception1 = new Exception();      // \My\App\Exception 类中搜索</span><br><span class="line">        $exception2 = new \Exception();     // PHP 原生的 Exception 类</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="接口（interface）"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a>接口（interface）</h1><ul><li>接口是两个 PHP 对象之间的契约，其目的不是让一个对象依赖另一个对象的身份，而是依赖另一个对象的能力。</li><li>接口将项目代码和依赖解耦，并允许项目代码依赖任何实现了预期接口的第三方代码而<strong>不用关心第三方代码是如何实现接口的，只关心第三方代码是否实现了指定的接口</strong>。</li></ul><p>例程（<a href="https://github.com/codeguy/modern-php/tree/master/02-features/interfaces" target="_blank" rel="noopener">完整版</a>）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$documentStore = new DocumentStore();</span><br><span class="line"></span><br><span class="line">// Add HTML document</span><br><span class="line">$htmlDoc = new HtmlDocument(&apos;http://php.net&apos;);</span><br><span class="line">$documentStore-&gt;addDocument($htmlDoc);</span><br><span class="line"></span><br><span class="line">// Add terminal command document</span><br><span class="line">$cmdDoc = new CommandOutputDocument(&apos;cat /etc/hosts&apos;);</span><br><span class="line">$documentStore-&gt;addDocument($cmdDoc);</span><br><span class="line"></span><br><span class="line">print_r($documentStore-&gt;getDocuments());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class DocumentStore</span><br><span class="line">&#123;</span><br><span class="line">    protected $data = [];</span><br><span class="line">    public function addDocument(Documentable $document)</span><br><span class="line">    &#123;</span><br><span class="line">        $key = $document-&gt;getId();</span><br><span class="line">        $value = $document-&gt;getContent();</span><br><span class="line">        $this-&gt;data[$key] = $value;</span><br><span class="line">    &#125;</span><br><span class="line">    public function getDocuments()</span><br><span class="line">    &#123;</span><br><span class="line">        return $this-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Documentable</span><br><span class="line">&#123;</span><br><span class="line">    public function getId();</span><br><span class="line">    public function getContent();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CommandOutputDocument implements Documentable</span><br><span class="line">&#123;</span><br><span class="line">    protected $command;</span><br><span class="line"></span><br><span class="line">    public function __construct($command)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;command = $command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function getId()</span><br><span class="line">    &#123;</span><br><span class="line">        return $this-&gt;command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function getContent()</span><br><span class="line">    &#123;</span><br><span class="line">        return shell_exec($this-&gt;command);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class HtmlDocument implements Documentable</span><br><span class="line">&#123;</span><br><span class="line">    protected $url;</span><br><span class="line"></span><br><span class="line">    public function __construct($url)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;url = $url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function getId()</span><br><span class="line">    &#123;</span><br><span class="line">        return $this-&gt;url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function getContent()</span><br><span class="line">    &#123;</span><br><span class="line">        $ch = curl_init();</span><br><span class="line">        curl_setopt($ch, CURLOPT_URL, $this-&gt;url);</span><br><span class="line">        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);</span><br><span class="line">        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 3);</span><br><span class="line">        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);</span><br><span class="line">        curl_setopt($ch, CURLOPT_MAXREDIRS, 3);</span><br><span class="line">        $html = curl_exec($ch);</span><br><span class="line">        curl_close($ch);</span><br><span class="line"></span><br><span class="line">        return $html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="性状（trait）"><a href="#性状（trait）" class="headerlink" title="性状（trait）"></a>性状（trait）</h1><ul><li>性状既不是类也不是接口，而是类的部分实现（即常量，属性和方法），可以混入一个或多个现有的 PHP 类中。</li><li>性状的作用：<ol><li>表明类可以做什么（类似接口）；</li><li>提供模块化实现（类似类）。</li></ol></li><li>性状能把模块化的实现方式注入多个无关的类中。而且性状还能促进代码重用。</li><li>使用性状的场景：<ol><li>创建一个基类，然后共同集成这个基类，将共用方法写在基类中。但无关的两个类并不应集成相同的父类。</li><li>创建接口，然后在两个类中分别实现该接口并使用。但如果实现方法相同，则违背了 DRY（Don’t Repeat Yourself）原则。</li></ol></li><li>与定义类和接口一样，一个文件只定义一个性状。</li><li>命名空间、类、接口函数和常量<strong>在类的定义体外</strong>导入，而性状<strong>在类的定义体内</strong>导入。</li><li>PHP 解释器在编译时会把性状复制粘贴到类的定义体中，但是<strong>不会处理这个操作引入的不兼容问題</strong>。如果性状假定类中有特定的属性或方法（在性状中没有定义），要确保相应的类中有对应的属性和方法。</li></ul><p>例程：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$adapter = new \Ivory\HttpAdapter\CurlHttpAdapter();</span><br><span class="line">$geocoder = new \Geocoder\Provider\GoogleMaps($adapter);</span><br><span class="line"></span><br><span class="line">$store = new RetailStore();</span><br><span class="line">$store-&gt;setAddress(&apos;420 9th Avenue, New York, NY 10001 USA&apos;);</span><br><span class="line">$store-&gt;setGeocoder($geocoder);</span><br><span class="line"></span><br><span class="line">$latitude = $store-&gt;getLatitude();</span><br><span class="line">$longitude = $store-&gt;getLongitude();</span><br><span class="line"></span><br><span class="line">echo $latitude, &apos;:&apos;, $longitude;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class RetailStore</span><br><span class="line">&#123;</span><br><span class="line">    use TraitExample;</span><br><span class="line"></span><br><span class="line">    //......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">trait Geocodable</span><br><span class="line">&#123;</span><br><span class="line">    /** @var string */</span><br><span class="line">    protected $address;</span><br><span class="line"></span><br><span class="line">    /** @var \Geocoder\Geocoder */</span><br><span class="line">    protected $geocoder;</span><br><span class="line"></span><br><span class="line">    /** @var \Geocoder\Model\AddressCollection */</span><br><span class="line">    protected $geocoderResult;</span><br><span class="line"></span><br><span class="line">    public function setGeocoder(\Geocoder\Geocoder $geocoder)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;geocoder = $geocoder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function setAddress($address)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;address = $address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function getLatitude()</span><br><span class="line">    &#123;</span><br><span class="line">        if (!isset($this-&gt;geocoderResult)) &#123;</span><br><span class="line">            $this-&gt;geocodeAddress();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return $this-&gt;geocoderResult-&gt;first()-&gt;getLatitude();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function getLongitude()</span><br><span class="line">    &#123;</span><br><span class="line">        if (!isset($this-&gt;geocoderResult)) &#123;</span><br><span class="line">            $this-&gt;geocodeAddress();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return $this-&gt;geocoderResult-&gt;first()-&gt;getLongitude();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected function geocodeAddress()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;geocoderResult = $this-&gt;geocoder-&gt;geocode($this-&gt;address);</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="生成器（generator）"><a href="#生成器（generator）" class="headerlink" title="生成器（generator）"></a>生成器（generator）</h1><ul><li>生成器是简单的<strong>迭代器</strong>。</li><li>PHP 生成器不要求类实现 <code>Iterator</code> 接口，并会根据需求即时计算并产出要迭代的值，不占用宝贵的内存资源。</li><li>生成器是<strong>一次性的</strong>，无法多次迭代同个生成器，但可以重建或克隆生成器</li><li>每次产出一个值之后，生成器的内部状态都会停顿；向生成器请求下一个值时，内部状态又会恢复。生成器的内部状态会一直在停顿和恢复之间切换，直到抵达函数定义体的末尾或遇到空的 return；语句为止。</li><li>生成器是<strong>只能向前进的迭代器</strong>，不能使用生成器在数据集中执行后退、快进或査找操作，只能让生成器计算并产生下一个值。迭代大型数据集或数列时最适合使用生成器，因为这样占用的系统内存量极少。</li><li>更多技巧与实践：<a href="https://www.twitter.com/ircmaxell" target="_blank" rel="noopener">@ircmaxell</a> - <a href="https://blog.ircmaxell.com/2012/07/what-generators-can-do-for-you.html" target="_blank" rel="noopener">What Generators Can Do For You</a></li></ul><p>例程一：生成一个范围内的数值数组且善用内存</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function makeRange($length) &#123;</span><br><span class="line">    for ($i = 0; $i &lt; $length; $i++) &#123;</span><br><span class="line">        yield $i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foreach (makeRange(1000000) as $i) &#123;</span><br><span class="line">    echo $i . PHP_EOL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例程二：读取一个超过 PHP 可用内存上限的 CSV 文件。只为 CSV 文件中的一行分配内存，而不会把整个 CSV 文件都读取到内存中。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function getRows($file) &#123;</span><br><span class="line">    $handle = fopen($file, &apos;rb&apos;);</span><br><span class="line">    if (!$handle) &#123;</span><br><span class="line">        throw new Exception();</span><br><span class="line">    &#125;</span><br><span class="line">    while (!feof($handle)) &#123;</span><br><span class="line">        yield fgetcsv($handle);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose($handle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foreach (getRows(&apos;data.csv&apos;) as $row) &#123;</span><br><span class="line">    print_r($row);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="闭包（closure）"><a href="#闭包（closure）" class="headerlink" title="闭包（closure）"></a>闭包（closure）</h1><ul><li><strong>闭包</strong>是指在创建时封装周围状态的函数。即便闭包所在的环境不存在了，闭包中封装的状态依然存在。</li><li><strong>匿名函数</strong>就是没有名称的函数，可以调用，还可以传入参数。</li><li>匿名函数<strong>可以赋值给变量</strong>，还能像对象那样传递。</li><li>匿名函数适合作为函数或方法的回调。</li><li>在 PHP 中，匿名函数 = 闭包。</li><li>闭包和匿名函数是<strong>伪装成函数的对象</strong>。</li><li>PHP 闭包不会自动封装应用的状态，必须手动调用闭包对象的 <code>bindto()</code> 方法或者使用 <code>use</code> 关键字，把状态附加到 PHP 闭包上，这样即便返回的闭包对象跳出了其函数的作用域，它也会记住参数的值，即将应用状态封装起来。</li><li>与任何其他 PHP 对象类似，每个闭包实例都可以使用 $this 关键字获取闭包的内部状态。<code>bindto()</code> 方法可以把 Closure 对象的内部状态绑定到其他对象上。</li><li>闭包可以访问绑定闭包的对象中受保护和私有的成员变量。</li></ul><p>例程一：普通闭包</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$numbersPlusOne = array_map(function ($number) &#123;</span><br><span class="line">    return $number + 1;</span><br><span class="line">&#125;, [1,2,3]);</span><br><span class="line"></span><br><span class="line">print_r($numbersPlusOne);</span><br><span class="line"></span><br><span class="line">// Outputs --&gt; [2,3,4]</span><br></pre></td></tr></table></figure><p>例程二：封装应用状态的闭包</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function enclosePerson($name) &#123;</span><br><span class="line">    return function ($doCommand) use ($name) &#123;</span><br><span class="line">        return sprintf(&apos;%s, %s&apos;, $name, $doCommand);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Enclose &quot;Clay&quot; string in closure</span><br><span class="line">$clay = enclosePerson(&apos;Clay&apos;);</span><br><span class="line"></span><br><span class="line">// Invoke closure with command</span><br><span class="line">echo $clay(&apos;get me sweet tea!&apos;);</span><br><span class="line">// Outputs --&gt; &quot;Clay, get me sweet tea!&quot;</span><br></pre></td></tr></table></figure><h1 id="Zend-OPcache"><a href="#Zend-OPcache" class="headerlink" title="Zend OPcache"></a>Zend OPcache</h1><ul><li>PHP 是解释型语言，PHP 解释器执行 PHP 脚本时会解析 PHP 脚本代码，把 PHP 代码编译成一系列 <a href="http://bit.ly/zend-opcode" target="_blank" rel="noopener">Zend 操作码</a>，然后执行字节码。Zend OPcache 可以让 PHP 解释器从内存中读取预先编译好的字节码，然后立即执行。这样能节省很多时间，极大地提升应用的性能。</li><li><p>启用步骤：</p><ol><li>编译：<code>$ ./configure --enable-opcache</code></li><li>启用扩展：<code>zend_extension=/path/to/opcache.so</code></li><li><p>配置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">opcache.validate_timestamps = 1 //检测 PHP 脚本变动。建议生产环境设为 0</span><br><span class="line">opcache.revalidate_freq = 0 //检査 PHP 脚本内容变化的周期，单位秒。</span><br><span class="line">opcache.memory_consumption = 64 // 为操作码缓存分配的内存量（单位是 MB）。分配的内存量应该够保存应用中所有 PHP 脚本编译得到的操作码。</span><br><span class="line">opcache.interned_strings_buffer = 16 // 用来存储驻留字符串（interned string）的内存量（单位是 MB）。默认值为 4MB。</span><br><span class="line">opcache.max_accelerated_files = 4000 // 操作码缓存中最多能存储多少个 PHP 脚本。</span><br><span class="line">opcache.fast_shutdown = 1 // 设置操作码使用更快的停机步骤</span><br></pre></td></tr></table></figure></li></ol></li></ul><h1 id="内置的-HTTP-服务器"><a href="#内置的-HTTP-服务器" class="headerlink" title="内置的 HTTP 服务器"></a>内置的 HTTP 服务器</h1><ul><li>从 PHP 5.4.0 起，PHP 内置了 Web 服务器。</li><li>启动本地运行：<code>$ php -S localhost:4000</code></li><li>启动局域网访问：<code>$ php -S 0.0.0.0:4000</code></li><li>指定配置文件启动：<code>$ php -S localhost:8000 -c app/config/php.ini</code></li><li>指定路由器脚本启动：<code>$ php -S localhost:8000 router.php</code></li><li>内置的 HTTP 服务器仅用于本地开发调试，不应使用于生产环境。</li></ul><h1 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h1><ul><li>PHP Framework Interop Group（简称 PHP-FIG，<a href="http://www.php-fig.org" target="_blank" rel="noopener">http://www.php-fig.org</a> ）。PHP-FIG 由一些 PHP 框架代表组成，PHP-FIG 制定了推荐规范，PHP 框架可以自愿实现这些规范，改进与其他框架的通信和共享功能。</li><li>PHP-FIG 的使命是实现框架的互操作性：通过接口、自动加载机制和标准的风格，让框架相互合作。</li><li>接口：框架通过 PHP 接口假定第三方依赖提供了什么方法，而不关心依赖是如何实现接口的。<ul><li>自动加载：PHP 解释器在运行时按需自动找到并加载 PHP 类的过程。只需使用一个自动加载器就能混合搭配多个 PHP 组件。</li><li>风格：指定如何使用空格、大小写和括号的位置（等等）之类的代码格式规范。</li></ul></li></ul><h2 id="PSR-1：基本的代码风格"><a href="#PSR-1：基本的代码风格" class="headerlink" title="PSR-1：基本的代码风格"></a>PSR-1：基本的代码风格</h2><ul><li>PHP 标签：使用 <code>&lt;?php ?&gt;</code> 或 <code>&lt;?= ?&gt;</code></li><li>编码：使用 <code>UTF-8</code> 编码</li><li>目的：一个 PHP 文件只处理一件事</li><li>自动加载：PHP 命名空间和类必须遵守 PSR-4 自动加载器标准</li><li>类的名称：PHP 类的名称必须一直使用<strong>大驼峰式</strong>（CamelCase）</li><li>常量名称：PHP 常量的名称必须全部使用<strong>大写</strong>字母</li><li>方法名称：PHP 方法的名称必须一直使用<strong>小驼峰式</strong>（camelCase）</li></ul><h2 id="PSR-2：严格的代码风格"><a href="#PSR-2：严格的代码风格" class="headerlink" title="PSR-2：严格的代码风格"></a>PSR-2：严格的代码风格</h2><ul><li>贯彻 PSR-1</li><li>缩进：使用四个空格缩进。</li><li>文件和代码行：使用 UNIX 换行符（LF），文末<strong>留一个空行</strong>，<strong>不使用</strong> PHP 关闭标签 <code>?&gt;</code>。每行代码<strong>不超过</strong> 80 个字符，<strong>至少不能超过</strong> 120 个字符。每行末尾<strong>不能有空格</strong>。</li><li>关键字：使用<strong>小写字母</strong>。</li><li>命名空间：命名空间声明语句和 <code>use</code> 声明语句后<strong>留一个空行</strong>。</li><li>类：类定义体的起始括号在类名之后<strong>新起一行写</strong>。扩展类或实现接口的 <code>extends</code> 和 <code>implements</code> 关键字必须和类名<strong>写在同一行</strong>。</li><li>方法：方法定义体的起始括号要在方法名之后<strong>新起一行写</strong>。方法定义体的结束括号要在方法定义体之后新起一行写。起始圆括号之后<strong>没有空格</strong>，结束圆括号之前<strong>没有空格</strong>。方法的参数后面有<strong>一个逗号和空格</strong>。</li><li>可见性：类中的每个属性和方法都要声明可见性。<code>abstract</code> 或 <code>final</code> 限定符放在可见性关键字<strong>之前</strong>，<code>static</code> 限定符放在可见性关键字<strong>之后</strong>。</li><li>控制结构：所有控制结构关键字（<code>if</code>、<code>elseif</code>、<code>else</code>、<code>switch</code>、<code>case</code>、<code>while</code>、<code>do while</code>、<code>for</code>、<code>foreach</code>、<code>try</code>、<code>catch</code>）后面都要有<strong>一个空格</strong>。控制结构关键字后面的起始圆括号后面<strong>没有空格</strong>，结束圆括号之前<strong>没有空格</strong>，起始括号和控制结构关键字<strong>写在同一行</strong>，结束括号<strong>单独写在一行</strong>。</li></ul><h2 id="PSR-3：日志记录器接口"><a href="#PSR-3：日志记录器接口" class="headerlink" title="PSR-3：日志记录器接口"></a>PSR-3：日志记录器接口</h2><ul><li>PSR-3 是一个接口，规定 PHP 日志记录器组件可以实现的方法。</li><li>PSR-3 要求日志记录器必须实现 9 个方法：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace Psr\Log;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * See https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-3-logger-interface.md</span><br><span class="line"> * for the full interface specification.</span><br><span class="line"> */</span><br><span class="line">interface LoggerInterface</span><br><span class="line">&#123;</span><br><span class="line">    public function emergency($message, array $context = array());</span><br><span class="line">    public function alert($message, array $context = array());</span><br><span class="line">    public function critical($message, array $context = array());</span><br><span class="line">    public function error($message, array $context = array());</span><br><span class="line">    public function warning($message, array $context = array());</span><br><span class="line">    public function notice($message, array $context = array());</span><br><span class="line">    public function info($message, array $context = array());</span><br><span class="line">    public function debug($message, array $context = array());</span><br><span class="line">    public function log($level, $message, array $context = array());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>推荐使用符合 PSR-3 规范的日志记录器 <a href="https://packagist.org/packages/monolog/monolog" target="_blank" rel="noopener">monolog/monolog</a></li></ul><h2 id="PSR-4：自动加载器"><a href="#PSR-4：自动加载器" class="headerlink" title="PSR-4：自动加载器"></a>PSR-4：自动加载器</h2><ul><li>PSR-4 是一个标准的自动加载器策略，规定运行时按需査找 PHP 类、接口或性状，并将其载入 PHP 解释器。</li><li>自动加载器的引入解决了使用 <code>require()</code> 函数和 <code>include()</code> 函数手动引入文件的繁琐。</li><li>PSR-4 推荐规范不要求改变代码的实现方式，只建议如何使用文件系统目录结构和 PHP 命名空间组织代码。</li><li>PSR-4 自动加载器策略依赖 PHP 命名空间和文件系统目录结构査找并加载 PHP 类、接口和性状。</li><li>PSR-4 会把命名空间的前缀和文件系统中的目录对应起来。命名空间的前缀可以是顶层命名空间，也可以是顶层命名空间加上任意一个子命名空间。</li><li>推荐使用依赖管理器 <a href="https://getcomposer.org/" target="_blank" rel="noopener">Composer</a> 来自动生成符合 PSR-4 规范的自动加载器。</li></ul><h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><ul><li>PHP 组件是一系列相关的类、接口和性状，用于解决某个具体问题。组件中的类、接口和性状通常放在同一个命名空间中。</li><li>好的 PHP 组件具有以下特征：<ul><li>作用单一：专注于解决一个问题，而且使用简单的接口封装功能。</li><li>小型：只包含解决某个问题所需的最少代码。</li><li>合作：PHP 组件之间能良好合作。把代码放在自己的命名空间中，防止与其他组件有名称冲突。</li><li>测试良好：组件本身会提供测试，而且有充足的测试覆盖度。</li><li>文档完善：有个 README 文件，说明组件的作用，如何安装，以及如何使用。抑或有网站介绍详细信息。</li></ul></li><li>如果是能通过一些 PHP 组件准确解决问题的小型项目，那就使用组件。如果是有多个团队成员开发的大型项目，而且能从框架提供的约定、准则和结构中受益，那就使用框架。</li><li>查找组件目录：<a href="https://packagist.org/" target="_blank" rel="noopener">Packagist</a></li><li>安装组件的工具：<a href="https://getcomposer.org/" target="_blank" rel="noopener">Composer</a></li><li>自动加载是指在不使用 <code>require()</code>、<code>require_once()</code>、<code>include()</code> 或 <code>include_once()</code> 函数的情况下按需自动加载 PHP 类。</li><li>在较旧的 PHP 版本中可以使用 <code>autoload()</code> 函数自己编写自动加载器；实例化尚未加载的类时，PHP 解释器会自动调用这个函数。后来，PHP 在 SPL 库中引入了更灵活的 <code>sql_autoload_register()</code> 函数。如何自动加载 PHP 类完全由开发者决定。依赖管理器 Composer 为项目中的所有 PHP 组件自动生成符合 PSR 标准的自动加载器。Composers 有效抽象了依赖管理和自动加载。</li><li>Composer 和 Packagisti 都使用 <code>vendor/package</code> 这种命名约定，避免不同厂商的 PHP 组件有名称冲突。</li><li>PHP 组件版本号（如，1.13.2)语义：<ol><li>第一个数字是主版本号，用于破坏了向后兼容性的版本更新。</li><li>第二个数字是次版本号，用于没破坏向后兼容性的小幅功能更新。</li><li>第三个数字是修订版本号，用于对向后兼容的缺陷的修正。</li></ol></li><li><code>composer install</code> 命令不会安装比 <code>composer.lock</code> 文件中列出的版本号新的版本。</li><li><code>composer update</code> 命令会把组件更新到最新稳定版，还会更新 <code>composer.lock</code> 文件，写入 PHP 组件的新版本号。</li><li>Composer 创建的自动加载器就是 <code>vendor/autoload.php</code> 文件。Composer 下载各个 PHP 组件时会检査每个组件的 <code>composer.json</code> 文件，确定如何加载该组件。</li><li>Composer 仓库的凭据 <code>auth.php</code> 文件放在和 <code>composer.json</code> 文件同级目录，且不应加入版本控制：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;http-basic&quot;: &#123;</span><br><span class="line">        &quot;example.org&quot; :&#123;</span><br><span class="line">            &quot;username&quot;: &quot;your-name&quot;,</span><br><span class="line">            &quot;password&quot;: &quot;your-password&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>composer.json</code> 文件结构：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;组件名称&quot;,</span><br><span class="line">    &quot;description&quot;: &quot;描述&quot;,</span><br><span class="line">    &quot;keywords&quot;: [关键词],</span><br><span class="line">    &quot;homepage&quot;: &quot;组件主页&quot;,</span><br><span class="line">    &quot;license&quot;: &quot;软件许可协议&quot;,</span><br><span class="line">    &quot;authors&quot;: [作者信息],</span><br><span class="line">    &quot;support&quot;: &#123;获取技术支持的方式&#125;,</span><br><span class="line">    &quot;require&quot;: &#123;依赖的组件&#125;,</span><br><span class="line">    &quot;require-dev&quot;: &#123;开发该组件时依赖的组件&#125;,</span><br><span class="line">    &quot;suggest&quot;: &#123;建议安装的组件&#125;,</span><br><span class="line">    &quot;autoload&quot;: &#123;自动加载方式&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Packagist 从组件的 <code>composer.json</code> 文件中读取了组件的名称、描述、关键字依赖和建议。还会发现显示了仓库的分支和标签。同时 Packagist 会把仓库的标签和语言版本号对应起来。</p></li></ul><h1 id="良好实践"><a href="#良好实践" class="headerlink" title="良好实践"></a>良好实践</h1><h2 id="过滤、验证和转义"><a href="#过滤、验证和转义" class="headerlink" title="过滤、验证和转义"></a>过滤、验证和转义</h2><ul><li>不要相信任何来自不受自己直接控制的数据源中的数据。</li><li>过滤输入：转义或删除不安全的字符。在数据到达应用的存储层之前，一定要过滤输入数据。建议不使用正则表达式函数过滤 HTML，正则表达式很复杂，可能导致 HTML 无效，且出错的几率高。</li><li>验证数据：确认输入的数据符合预期，在应用的存储层保存符合特定格式的正确数据。避免数据库出现潜在的错误。</li><li>转义输出：避免渲染恶意代码，还能防止应用的用户无意中执行恶意代码。</li></ul><h2 id="密码"><a href="#密码" class="headerlink" title="密码"></a>密码</h2><ul><li>绝对不能知道用户的密码</li><li>绝对不要约束用户的密码</li><li>绝对不能通过电子邮件发送用户的密码</li><li>使用 <code>bcrypt</code> 计算用户密码的哈希值。<code>bcrypt</code> 算法会自动加盐，防止潜在的彩虹表攻击。<code>bcrypt</code> 算法永不过时，如果计算机的运算速度变快了，我们只需提高工作因子的值。<code>bcrypt</code> 算法得到了同行的大量审查，目前暂无漏洞。</li><li>加密和哈希不是一回事。加密是双向算法，加密的数据以后可以解密。而哈希是单向算法，哈希后的数据不能再还原成原始值，而且相同的数据得到的哈希值始终相同。</li></ul><h2 id="日期、时间和时区"><a href="#日期、时间和时区" class="headerlink" title="日期、时间和时区"></a>日期、时间和时区</h2><ul><li>推荐使用 <a href="https://github.com/briannesbitt/Carbon" target="_blank" rel="noopener"><code>nesbit/carbon</code></a> 组件处理日期和时间值的有用方法。</li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul><li>PDO 扩展：PDO（PHP Data Objects，PHP 数据对象）是一系列 PHP 类，抽象了不同数据库的具体实现，只通过一个用户界面就能与多种不同的 SQL 数据库通信。不管使用哪种数据库系统，使用一个接口就能编写和执行数据库査询</li><li>使用 PDO 时，建议编写符合 <code>ANSI/ISO</code> 标准的 SQL 语句，这样如果更换数据库系统 SQL 语句不会失效。</li><li>数据库凭据应保存在一个位于文档根目录之外的配置文件中，然后在需要使用凭据的 PHP 文件中导入。另外，凭据也不能纳入版本控制，避免因仓库公开而泄漏凭据。</li><li><strong>事务</strong>：指把一系列数据库语句当成单个逻辑单元（具有原子性）执行。事务中的一系列 SQL 査询要么都成功执行，要么根本不执行。</li><li>事务的一个副作用一一提升性能——事务把多个査询排成队列，一次全部执行。</li><li>PHP 中处理字符串的函数默认假设所有字符串都只使用 8 位字符，如果使用这些 PHP 原生的字符串函数处理包含多字节字符的 Unicode 字符串，可能会出错。为避免处理多字节字符串时出错，可以安装 <a href="http://php.net/manual/book.mbstring.php" target="_blank" rel="noopener"><code>mbstring</code> 扩展</a>。该扩展提供了能替代大多数 PHP 原生的且能处理多字节字符串的函数。</li><li>PHP 编码配置(<code>pip.ini</code>)：<code>default charset = &quot;utf-8&quot;</code></li></ul><h2 id="错误和异常"><a href="#错误和异常" class="headerlink" title="错误和异常"></a>错误和异常</h2><ul><li>错误会导致程序脚本停止执行，有些错误无法恢复，其他错误可使用全局错误处理程序处理。</li><li>预测測、捕获并处理异常是我们自己的责任。未捕获的异常会导致 PHP 应用终止运行，显示致命错误信息。而更糟的是，可能会暴露敏感的调试详细信息，让应用的用户看到。因此，一定要使用 <code>try/catch</code> 块捕获异常，然后使用优雅的方式处理。</li><li>捕获某种异常时只会运行其中一个 catch 块。如果 PHP 没找到适用的 catch 块，异常会向上冒泡，直到 PHP 脚本由于致命错误而终止运行。</li><li>PHP 异常可以在 PHP 应用的任何层级抛出和捕获。</li><li>PHP 异常和错误设置原则：<ul><li>一定要让 PHP 报告错误。</li><li>在开发环境中要显示错误。</li><li>在生产环境中不能显示错误。</li><li>在开发环境和生产环境中都要记录错误。</li></ul></li><li>推荐配置：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; 开发环境</span><br><span class="line">; 显示错误</span><br><span class="line">display_startup_errors = On</span><br><span class="line">display_errors = On</span><br><span class="line">; 报告所有错误</span><br><span class="line">error_reporting = -1</span><br><span class="line">; 记录错误</span><br><span class="line">log_errors = On</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;生产环境</span><br><span class="line">; 不显示错误</span><br><span class="line">display_startup_errors = Off</span><br><span class="line">display_errors = Off</span><br><span class="line">; 除了注意事项之外，报告所有其他错误</span><br><span class="line">error_reporting = E_ALL &amp; ~E_NOTICE</span><br><span class="line">; 记录错误</span><br><span class="line">log_errors = On</span><br></pre></td></tr></table></figure><ul><li>推荐使用 <a href="https://github.com/filp/whoops" target="_blank" rel="noopener"><code>Whoops</code></a> 组件在开发环境中处理 PHP 错误和异常。</li><li>推荐使用 <a href="https://github.com/Seldaek/monolog" target="_blank" rel="noopener"><code>Monolog</code></a> 组件在生产环境中记录 PHP 错误和异常。</li></ul><h1 id="主机"><a href="#主机" class="headerlink" title="主机"></a>主机</h1><ul><li>存储 PHP 应用的四种方式：<ul><li>共享服务器（Shared hosting）</li><li>虚拟私有服务器（VPS）</li><li>专用服务器</li><li>平台即服务（PasS）</li></ul></li><li>共享主机账户会与很多其他顾客的账户在同一个物理设备中。PHP 应用能使用多少设备在内存取决于这台设备中有多少账户。共享主机适合少预算，或简单需求。</li><li>虚拟私有服务器（VPS）提供了足够的系统资源，需要我们根据 PHP 应用的需求，自己动手配置和保护操作系统。</li><li>PasS 只需账号登陆，使用提供商的控制面板，单击按钮即可完成操作。有些 PasS 提供商会提供命令行工具或 Http Api，让我们部署和管理存储的 PHP 应用。适合小型 PHP 应用省心省事。</li></ul><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="PHP-FPM"><a href="#PHP-FPM" class="headerlink" title="PHP-FPM"></a>PHP-FPM</h2><ul><li>PHP-FPM 全局配置 <code>php-fpm.conf</code></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">emergency_restart_threshold = 10</span><br><span class="line">//在指定的一段时间内，如果失效的 PHP-FPM 子进程数超过这个值，PHP-FPM 主进程就优雅重启。</span><br><span class="line"></span><br><span class="line">emergency_restart_interval = 1m</span><br><span class="line">//设定 emergency_restart_threshold 设置采用的时间跨度。</span><br></pre></td></tr></table></figure><ul><li>PHP-FPM 进程池配置 <code>fpm/pool.d/*.conf</code> 或 <code>php-fpm.d/*.conf</code></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user = deploy</span><br><span class="line">//运行 PHP 应用的非根用户的用户名</span><br><span class="line"></span><br><span class="line">group = deploy</span><br><span class="line">//运行 PHP 应用的非根用户所属的用户组名</span><br><span class="line"></span><br><span class="line">listen = 127.0.0.1:9000</span><br><span class="line">//PHP-FPM 进程池监听的 IP 地址和端口号</span><br><span class="line"></span><br><span class="line">listen.allowed_clients = 127.0.0.1</span><br><span class="line">//可以向该 PHP-FPM 进程池发送请求的 IP 地址（一个或多个）。</span><br><span class="line"></span><br><span class="line">pm.max_children = 51</span><br><span class="line">//设定任何时间点 PHP-FPM 进程池中最多能有多少个进程。可以设置的值设为总内存 / 每个进程使用的内存大小</span><br><span class="line"></span><br><span class="line">pm.start_servers = 3</span><br><span class="line">//PHP-FPM 启动时 PHP-FPM 进程池中立即可用的进程数。建议设为 2 或 3。</span><br><span class="line"></span><br><span class="line">pm.min_spare_servers = 2</span><br><span class="line">//PHP 应用空闲时 PHP-FPM 进程池中可以存在的进程数量最小值。一般与 pm.start_servers 设置值一样</span><br><span class="line"></span><br><span class="line">pm.max spare servers = 4</span><br><span class="line">//PHP 应用空闲时 PHP-FPM 进程池中可以存在的进程数量最大值。一般比 pm.start_servers 设置的值大一点</span><br><span class="line"></span><br><span class="line">pm.max requests = 1000</span><br><span class="line">//回收进程之前，PHP-FPM 进程池中各个进程最多能处理的 HTP 请求数量。</span><br><span class="line"></span><br><span class="line">slowlog = /path/to/slowlog log</span><br><span class="line">//设置慢日志（处理时间超过 n 秒的 HTTP 请求信息）的绝对路径。注意 PHP-FPM 进程池所属的用户和用户组必须有这个文件的写权限。</span><br><span class="line"></span><br><span class="line">request_slowlog_timeout = 5s</span><br><span class="line">//慢日志记录的 HTTP 请求的时间下限，超过此值即记录慢日志</span><br></pre></td></tr></table></figure><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    # Nginx 监听端口</span><br><span class="line">    listen 80;</span><br><span class="line">    # 虚拟主机的域名</span><br><span class="line">    server_name example.com;</span><br><span class="line">    # HTTP 请求 URI 没指定文件时访问的默认文件</span><br><span class="line">    index index.php;</span><br><span class="line">    # Nginx 接受 HTTP 请求主体长度的最大值</span><br><span class="line">    client_max_body_size 50M;</span><br><span class="line">    # 错误日志文件路径</span><br><span class="line">    error_log /home/deploy/apps/logs/example.error.log;</span><br><span class="line">    # 访问日志文件路径</span><br><span class="line">    access_log /home/deploy/apps/logs/example_access.log;</span><br><span class="line">    # 文档根目录路径</span><br><span class="line">    root /home/deploy/apps/example.com/current/public;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        tryz_files $uri $uri/ /index.php$is_args$args;</span><br><span class="line">    &#125;</span><br><span class="line">    location ~ \.php &#123;</span><br><span class="line">        try_files $uri =404;</span><br><span class="line">        fastcgi_split_path_info ^(.+\.php)(/.+)$;</span><br><span class="line">        include fastcgi_params;</span><br><span class="line">        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">        fastcgi_param SCRIPT_NAME $fastcgi_script_name;</span><br><span class="line">        fastcgi_index index.php;</span><br><span class="line">        fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>指定匹配指定 URL 模式的 HTTP 请求。location / {} 块使用 try_files 指令依次进行如下操作：<ol><li>査找匹配所请求 URI 的文件</li><li>查找匹配所请求 URI 的目录</li><li>把 HTTP 请求的 URI 重写为 /index.php，把査询字符附加到 URI 的末尾。</li></ol></li><li>重写的 URL 和所有以 .php 结尾的 URI 都由 location ~ .php {} 块管理，上例中该块规定把 HTTP 请求转发给 PHP-FPM 进程池处理。</li></ul><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><ul><li><code>php.ini</code> 配置中，建议修改 <code>upload_max_filesize = 10MB</code> 设置允许上传文件的大小</li><li><code>php.ini</code> 配置中，建议修改 <code>max_execution_time = 5</code> 设置单个 PHP 进程在终止之前最长可以运行多少时间。</li><li>应该在较少的块中发送更多的数据，而不是在较多的块中发送较少的数据，这样能减少 HTTP 请求总数。为此需要在 <code>php.ini</code> 配置中启用 PHP 输出缓存功能：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">output_buffering = 4096 // 输出缓存区大小</span><br><span class="line">implicit_flush = false</span><br></pre></td></tr></table></figure><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p>使用 <a href="https://github.com/capistrano/capistrano" target="_blank" rel="noopener">Capistrano</a> 来进行项目部署，可以方便地进行迭代和回滚操作。Capistrano 会在远程服务器中保存之前部署的应用，而且每次部署的版本放在各自的目录中。Capistrano 会维护五个或更多之前部署的应用，以防需要回滚到早前版本。Capistrano 还会创建一个 <code>current/</code> 目录,通过符号链接指向当前部署的应用所在的目录。具体步骤如下：</p><ol><li>在本地安装 ruby 和 gem   </li><li>在本地安装 Capistrano：<code>$ gem install capistrano</code>   </li><li><p>在项目根目录进行初始化：<code>$ cap install</code>，产生的初始化文件结构如下：   </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── Capfile                 //配置文件</span><br><span class="line">├── config                  //分环境配置文件</span><br><span class="line">│   ├── deploy              //环境配置目录</span><br><span class="line">│   │   ├── production.rb   //生产环境设置</span><br><span class="line">│   │   └── staging.rb      //过渡环境设置</span><br><span class="line">│   └── deploy.rb           //所有环境的通用设置</span><br><span class="line">└── lib</span><br><span class="line">    └── capistrano</span><br><span class="line">            └── tasks</span><br></pre></td></tr></table></figure></li><li><p>在远程服务器安装 Git：<code>$ yum install git</code></p></li><li>部署时在本地执行部署命令：<code>$ cap production deploy</code></li><li>回滚时在本地执行部署命令：<code>$ cap production deploy:rollback</code></li></ol><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>不同的测试方式之间不是互斥：   </p><ul><li>单元测试：单独证实应用中的各个类、方法和函数能正常运行。PHP 通常使用 PHPUnit 单元测试框架进行单元测试。<a href="https://phpunit.de/" target="_blank" rel="noopener">PHPUnit</a> 遵守 xUnit 测试架构。</li><li>测试驱动开发（Test-Driven Development, TDD）：在编写应用代码之前先写测试。故意让测试失败以描述应用应该具有怎样的表现。开发好应用的功能后，最终测试会成功通过。</li><li>行为驱动开发（Behavior-Driven Development, BDD）：编写故事，描述应用的表现。按导向不同氛围两类，二者一般可以共存互补，使项目获得更全面的测试。<ul><li>SpecBDD 是一种单元测试，使用人类能读懂的流畅语言描述应用的实现方式。例如，可能会把某个 PHPUnit 测试命名为 <code>testrendertemplate()</code>，把等价的 SpecBDD 测试命名为 <code>itrendersthetemplate()</code>，和 Xunit 工具相比更易于阅读和理解。通常使用的 SpecBDD 测试工具是 <a href="http://www.phpspec.net/" target="_blank" rel="noopener">PHPSPEC</a></li><li>StoryBDD 也使用人类能读懂的故事，不过 StoryBDD 关注更多的是整体行为，而不是低层实现。StoryBDD 测试关注项目整体的运行结果，而 SpecBDD 测试关注开发过程中的每个细节，如类、方法的正确性。通常使用的 StoryBDD 测试工具是 [Behat](<a href="http://behat.org/）" target="_blank" rel="noopener">http://behat.org/）</a></li></ul></li></ul><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><ul><li>开发环境使用 <a href="http://xdebiug.org" target="_blank" rel="noopener">XDebug</a>：使用时会消耗大量系统资源，借助 <a href="http://kcachegrind.sourceforge.net/" target="_blank" rel="noopener">KCacheGrind</a> 和 <a href="https://sourceforge.net/projects/wincachegrind/" target="_blank" rel="noopener">WinCacheGrind</a> 查看分析报告。</li><li>生产环境使用 <a href="http://xhprof.io" target="_blank" rel="noopener">XHProf</a>：使用时会消耗的系统资源少，借助 XHGUI 查看分析报告。</li></ul><h1 id="HHVM-和-Hack"><a href="#HHVM-和-Hack" class="headerlink" title="HHVM 和 Hack"></a>HHVM 和 Hack</h1><ul><li>PHP 是传统意义上的解释型语言，而不是编译型语言。因此，在命令行或 Web 服务器调用解释器解释 PHP 代码之前，PHP 代码就是 PHP 代码。PHP 解释器会解释 PHP 脚本，把代码转换成一系列 <a href="http://php.net/manual/internals2.opcodes.php" target="_blank" rel="noopener">Zend 操作码</a>（机器码指令），再把这些操作码交给 Zend Engine 执行。但解释型语言执行的速度比編译型语言慢很多，因为每次执行解释型语言编写的代码时都要将其转换成机器码，消耗额外的系统资源。</li><li>2010 年 Facebook 开发一个 HPHPc 的编译器，把 PHP 代码编译为 C++ 代码，再把 C++ 代码编译成可执行文件。但 HPHPc 对性能的提升已经到顶。于是 Facebook 开发了下一代 HPHPc，即 HHVM。HHVM 先把 PHP 代码转换成一种字节码中间格式，而且会缓存转换得到的字节码，然后使用 JIT 编译器转换并优化缓存的字节码，将其变成 x86_64 机器码。之后 HPHPc 被废弃。</li><li><a href="http://hacklang.org" target="_blank" rel="noopener">Hack</a> 是一门服务器端语言，类似 PHP，且可以和 PHP 无缝集成。Hack 的开发者其实把 Hack 当做 PHP 的一种方言。从 PHP 转到 Hack 只需将 PHP 标签 <code>&lt;?php</code> 改为 <code>&lt;?hh</code> 即可。</li><li>Hack 既支持静态类型，也支持动态类型，且基本上能向后兼容普通的 PHP，所以其支持所有 PHP 动态类型特性。HHVM 读取 Hack 代码后会优化和缓存中间字节码，只在需要时才把 Hack 文件转换成 x86_64 机器码。Hack 充分利用了两种类型系统的特性，我们通过 Hack 的类型检査程序得到了静态类型的准确性和安全性，又通过 HVM 的 JIT 编译器得到了动态类型的灵活性和快速迭代。</li><li>Hack 自带一个单独的类型检査服务器，这个服务器在后台运行，会实时对代码做类型检査。</li><li><p>Hack 代码有三种編写模式：</p><ul><li>严格模式：<code>&lt;?hh // strict</code> 要求所有变量、函数、方法等代码都有合适的类型注解。且代码中不能有 Hack 之外的代码。</li><li>局部模式：<code>&lt;?hh // partial</code> 允许在 Hack 代码中使用还没转换成 Hack 的 PHP 代码。不要求注解函数或方法的所有参数，如果只注解部分参数，Hack 的类型检査程序也不会报错。</li><li>声明模式：<code>&lt;?php // decl</code> 允许严格模式的 Hack 代码调用未指定类型的代码。</li></ul></li><li><p>Hack 提供了 PHP 没有的新数据结构和接口数据结构：</p><ul><li><a href="https://docs.hhvm.com/hack/built-in-types/arrays" target="_blank" rel="noopener">集合</a>（矢量，映射， 集和值对。）</li><li><a href="https://docs.hhvm.com/hack/generics/introduction" target="_blank" rel="noopener">泛型</a></li><li><a href="https://docs.hhvm.com/hack/built-in-types/enumerated-types" target="_blank" rel="noopener">枚举</a></li><li><a href="https://docs.hhvm.com/hack/built-in-types/shapes" target="_blank" rel="noopener">形状</a></li><li><a href="https://docs.hhvm.com/hack/built-in-types/tuples" target="_blank" rel="noopener">元组</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;命名空间（namespace）&quot;&gt;&lt;a href=&quot;#命名空间（namespace）&quot; class=&quot;headerlink&quot; title=&quot;命名空间（namespace）&quot;&gt;&lt;/a&gt;命名空间（namespace）&lt;/h1&gt;&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;PHP 命名空间与操作系统的物理文件系统不同，这是一个虚拟概念，没必要和文件系统中的目录结构完全对应。但是大多数 PHP 组件为了兼容 PSR-4 自动加载器标准，会把子命名空间放到文件系统的子目录中。&lt;/li&gt;
&lt;li&gt;从技术层面来看，命名空间只是 PHP 语言中的一种记号，PHP 解释器会将其作为前缀添加到类、接口、函数和常量的名称前面。&lt;/li&gt;
&lt;li&gt;不同代码可能使用相同的类名、接口名、函数名或常量名，如果不使用命名空间，名称会起冲突，导致 PHP 执行出错。而使用命名空间，把代码放在唯一的厂商命名空间中，这样不同命名空间下的代码就可以使用相同的名称命名类、接口、函数和常量。&lt;/li&gt;
&lt;li&gt;在同一个命名空间或子命名空间中的所有类没必要在同一个 PHP 文件中声明。你可以在 PHP 文件的顶部指定一个命名空间或子命名空间，此时，这个文件中的代码就是该命名空间或子命名空间的一部分。因此，我们可以在不同的文件中编写属于同一个命名空间的多个类。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://acuario.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="PHP" scheme="https://acuario.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/PHP/"/>
    
    
      <category term="学习笔记" scheme="https://acuario.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="PHP" scheme="https://acuario.xyz/tags/PHP/"/>
    
      <category term="Modern PHP" scheme="https://acuario.xyz/tags/Modern-PHP/"/>
    
  </entry>
  
  <entry>
    <title>《精通正则表达式》学习笔记（六）</title>
    <link href="https://acuario.xyz/mastering-regex-summary-6/"/>
    <id>https://acuario.xyz/mastering-regex-summary-6/</id>
    <published>2019-08-17T15:00:53.000Z</published>
    <updated>2019-08-17T15:00:57.404Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="/mastering-regex-summary-1/">《精通正则表达式》学习笔记（一）</a><br>Ch.1 正则表达式入门<br>Ch.2 入门示例拓展</li><li><a href="/mastering-regex-summary-2/">《精通正则表达式》学习笔记（二）</a><br>Ch.3 正则表达式的特性和流派概览</li><li><a href="/mastering-regex-summary-3/">《精通正则表达式》学习笔记（三）</a><br>Ch.4 表达式的匹配原理</li><li><a href="/mastering-regex-summary-4/">《精通正则表达式》学习笔记（四）</a><br>Ch.5 正则表达式实用技巧</li><li><a href="/mastering-regex-summary-5/">《精通正则表达式》学习笔记（五）</a><br>Ch.6 打造高效正则表达式</li><li><a href="/mastering-regex-summary-6/">《精通正则表达式》学习笔记（六）</a><br>Ch.10 PHP 相关的正则表达式</li></ul><hr><h1 id="PHP-的正则流派"><a href="#PHP-的正则流派" class="headerlink" title="PHP 的正则流派"></a>PHP 的正则流派</h1><ul><li>PHP 的三种正则引擎是 <code>preg</code>、<code>creg</code> 和 <code>mb_ereg</code>。</li><li>在默认情况下，preg 套件的正则表达式是以字节为单位的，所以「<code>\C</code>」默认等价于「<code>(?d:.)</code>」，由 <code>s</code> 修饰的点号。不过，如果使用了修饰符 <code>u</code>，则 preg 套件就会以 UTF-8 字母为单位，也就是说，一个字符可能由 6 个字节组成。即使这样，「<code>\C</code>」仍然匹配单个字节。</li><li>「<code>\z</code>」和「<code>\Z</code>」都能够匹配字符串的末尾，而「<code>\Z</code>」同样能够匹配最后的换行符。</li><li>「<code>$</code>」的意义取决于模式修饰符 <code>m</code> 和 <code>D</code>：如果没有设定任何修饰符，「<code>$</code>」等价于「<code>\Z</code>」（在字符串结尾的换行符，或者是字符串结尾）；如果使用了 <code>m</code>，则它能够匹配内嵌的换行符，如果使用了模式修饰符 <code>D</code>，它能够匹配「<code>\z</code>」（只有在字符串的结尾）。如果同时设置了 <code>m</code> 和 <code>D</code>，则忽略 <code>D</code>。</li><li>PHP 正则引擎的处理方式完全是<strong>程序式</strong>的。</li></ul><a id="more"></a><h1 id="Preg-函数接口"><a href="#Preg-函数接口" class="headerlink" title="Preg 函数接口"></a>Preg 函数接口</h1><table><thead><tr><th>函数</th><th>用途</th></tr></thead><tbody><tr><td><code>preg_match</code></td><td>测试正则表达式能否在字待串中找到匹配，并提取数据</td></tr><tr><td><code>preg_match_all</code></td><td>从字苻串中提取数据</td></tr><tr><td><code>preg_replace</code></td><td>在字待串的副本中替换匹配的文本</td></tr><tr><td><code>preg_replace_callback</code></td><td>对字特事中的每处匹配文本调用处理函数</td></tr><tr><td><code>preg_split</code></td><td>将字苻串切分为子串数组</td></tr><tr><td><code>preg_grep</code></td><td>选出数组中能/不能由表达式匹配的元素</td></tr><tr><td><code>preg_quote</code></td><td>转义字符串中的正则表达式元字符</td></tr></tbody></table><h2 id="pattern-参数"><a href="#pattern-参数" class="headerlink" title="pattern 参数"></a>pattern 参数</h2><ul><li><code>patten</code> 参数是包含在一对斜线（分隔符）里头的参数。分隔符后面是模式修饰符。其参数的组成：<ol><li>分隔符</li><li>正则表达式</li><li>模式修饰符</li></ol></li></ul><h3 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h3><ul><li>preg 引擎要求正则表达式两端必须有分隔符，因为设计者希望它看起来更像 Perl，尤其在模式修饰符的使用方法上更是如此。</li><li>可以使用除了字母、数字、反斜线和空白字符之外的任何 ASCI 字符做分隔符。最常见的是一对斜线，或者两个 <code>!</code>、<code>#</code>。</li><li>分隔符的选取应该考虑实际情况，避免产生嵌套。如正则表达式内如果存在括号 <code>()</code>，则应该避免使用 <code>()</code> 作为分隔符。</li></ul><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><ul><li>因为正则表达式很有可能包含反斜线，所以在以字符串文字方式提供 pattern 参数时，最好使用 PHP 的单引号字符串，这样可以省略许多额外的转义。</li></ul><h3 id="模式修饰符"><a href="#模式修饰符" class="headerlink" title="模式修饰符"></a>模式修饰符</h3><ul><li>表达式内部的模式修饰符：在正则表达式内部，模式修饰符可以单独出现，来启用或停用某些特性，其作用范围持续到对应的结束括号。</li></ul><table><thead><tr><th>标准修饰符</th><th>用途</th><th>说明</th></tr></thead><tbody><tr><td><code>i</code></td><td>「<code>(?!)</code>」</td><td>忽略大小写</td></tr><tr><td><code>m</code></td><td>「<code>(?m)</code>」</td><td>增强的行铺点模式</td></tr><tr><td><code>s</code></td><td>「<code>(?s)</code>」</td><td>点号通配模式</td></tr><tr><td><code>x</code></td><td>「<code>(?x)</code>」</td><td>宽松排列和注释模式</td></tr></tbody></table><table><thead><tr><th>PHP 特有修饰符</th><th>用途</th><th>说明</th></tr></thead><tbody><tr><td><code>u</code></td><td></td><td>在 UTF-8 编码中，非 ASCI 字符以多个字节来存储，使用 <code>u</code> 修饰符能够以 UTF-8 编码处理正则表达式和目标字符串，确保多个字节会被作为单个字符来处理。处理时也不会修改数据，只是更改正则引擎处理数据的方式</td></tr><tr><td><code>S</code></td><td></td><td>启用 PCRE 的 “study” 优化特性，预先分析正则表达式，在某些顺利的情况下，在尝试匹配时速度会大大提升</td></tr><tr><td><code>D</code></td><td></td><td>把每个「<code>$</code>」替换为「<code>\z</code>」，即「<code>$</code>」匹配字符串的末尾，而不是字符串之内的换行符。</td></tr><tr><td><code>A</code></td><td></td><td>把匹配锚定在第一次尝试的位置</td></tr><tr><td><code>X</code></td><td>「<code>(?X)</code>」</td><td>启用 PCRE “额外功能（extra stuff）”，报告非无法识别的反斜线序列</td></tr><tr><td><code>e</code></td><td></td><td>将 replacement 作为 PHP 代吗（只用于 <code>preg_replace</code>)</td></tr><tr><td><code>U</code></td><td>「<code>(?U)</code>」</td><td>交换「<code>*</code>」和「<code>*?</code>」的匹配优先含义，<strong>建议不使用</strong></td></tr></tbody></table><h1 id="Preg-函数罗列"><a href="#Preg-函数罗列" class="headerlink" title="Preg 函数罗列"></a>Preg 函数罗列</h1><h2 id="preg-match"><a href="#preg-match" class="headerlink" title="preg_match"></a><code>preg_match</code></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int preg_match ( string $pattern , string $subject [, array &amp;$matches [, int $flags = 0 [, int $offset = 0 ]]] )</span><br></pre></td></tr></table></figure><ul><li><code>$matches</code> 末尾的空字符串都会被忽略。</li><li>使用命名捕获会使代码更易读，但使用了命名捕获，按数字编号的捕获仍然会插人 <code>$matches</code>。所以不推荐同时使用命名和数字编号来访问 <code>$matches</code> 的元素。</li></ul><p><img src="https://i.loli.net/2019/08/06/2tTh3QbLRim67zO.png" alt="命名捕获"></p><ul><li>参数 flags 可使用参数值：<code>PREG_OFFSET_CAPTURE</code> 使第 1 个元素是匹配的文本，第 2 个元素是这段文本在目标字符串中的偏移值。其通常按照<strong>字节</strong>来计数。</li></ul><h2 id="preg-match-all"><a href="#preg-match-all" class="headerlink" title="preg_match_all"></a><code>preg_match_all</code></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int preg_match_all ( string $pattern , string $subject [, array &amp;$matches [, int $flags = PREG_PATTERN_ORDER [, int $offset = 0 ]]] )</span><br></pre></td></tr></table></figure><ul><li>每个匹配都会创建一个包含匹配数据的数组，所以最后 matches 变量就是一个二维数组，其中的每个子数组对应一次匹配。</li><li>参数 flags 可使用参数值 <code>PREG_PATTERN_ORDER</code> 和 <code>PREG_SET_ORDER</code> 用于制定排列方式：</li></ul><table><thead><tr><th>类型</th><th>标志位</th><th>说明及示例</th></tr></thead><tbody><tr><td>按分组号</td><td><code>PREG_PATTERN_ORDER</code></td><td>将各次匹配中同样编号的分组编在一起</td></tr><tr><td>堆叠</td><td><code>PREG_SET_ORDER</code></td><td>将每次匹配的数据集中保存</td></tr></tbody></table><h2 id="preg-replace"><a href="#preg-replace" class="headerlink" title="preg_replace"></a><code>preg_replace</code></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] )</span><br></pre></td></tr></table></figure><ul><li>对文本进行査找-替换的办法。</li><li><code>subject</code> 也可以是一个字符串数组，搜索和替换是对每个字符串依次进行的。</li><li><code>pattern</code> 和 <code>replacement</code> 参数也可以是字符申数组。</li><li>如果 <code>subject</code> 参数是数组，则依次处理数组中的每个元素，返回值也是字符串数组。</li><li><code>preg_replace</code> 的程序要使用 <code>each()</code> 来按照数组的内部顺序历整个数组，而不关心它们的 keys 如何。</li><li>如果 <code>pattern</code> 或 <code>replacement</code> 数组的内部顺序不同于你希望匹配的顺序，可以使用 <code>sort()</code> 函数来确保每个数组的实际顺序和外表顺序是相同的。</li></ul><h2 id="preg-replace-callback"><a href="#preg-replace-callback" class="headerlink" title="preg_replace_callback"></a><code>preg_replace_callback</code></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mixed preg_replace_callback ( mixed $pattern , callable $callback , mixed $subject [, int $limit = -1 [, int &amp;$count ]] )</span><br></pre></td></tr></table></figure><ul><li><code>replacement</code> 参数变成了 PHP 回调函数，而不是字符串或是字符串数组。</li></ul><h2 id="preg-split"><a href="#preg-split" class="headerlink" title="preg_split"></a><code>preg_split</code></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array preg_split ( string $pattern , string $subject [, int $limit = -1 [, int $flags = 0 ]] )</span><br></pre></td></tr></table></figure><ul><li><code>preg_split</code> 找出目标字符串中不能由正则表达式匹配的部分。返回目标字符串中正则表达式匹配的部分別去之后的部分。相当于 PHP 中内建的简单 <code>explode</code> 函数，不过使用的是正则表达式，而且功能更强大。</li><li><code>limit</code> 参数用来设定切分之后数组长度的上限。达到 <code>limit</code> 之后的文本内容会全部保存到最后的元素当中。</li><li>参数 flags 可使用参数值：<ul><li><code>PREG_SPLIT_OFFSET_CAPTURE</code> 标志位会修改结果数组，把每个元素变为包含两个元素的数组（元素本身和它在字符串中的偏移值）。</li><li><code>PREG_SPLIT_NO_EMPTY</code> 标志位告诉 <code>preg_split</code> 忽略空字符串。</li><li><code>PREG_SPLIT_DELIM_CAPTURE</code> 标志位在结果中包含匹配的文本，以及捕获括号匹配的文本。</li></ul></li></ul><h2 id="preg-grep"><a href="#preg-grep" class="headerlink" title="preg_grep"></a><code>preg_grep</code></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">preg_grep ( string $pattern , array $input [, int $flags = 0 ] ) : array</span><br></pre></td></tr></table></figure><ul><li><code>preg_grep</code> 生成 <code>$input</code> 数组的副本，其中只保留了 <code>$value</code> 能够匹配 <code>$pattern</code> 的元素。</li></ul><h2 id="preg-quote"><a href="#preg-quote" class="headerlink" title="preg_quote"></a><code>preg_quote</code></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">preg_quote ( string $str [, string $delimiter = NULL ] ) : string</span><br></pre></td></tr></table></figure><ul><li>转义正则表达式字符，向其中每个正则表达式语法中的字符前增加一个反斜线。 </li></ul><h1 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h1><ol><li>回调函数通常要比模式修饰符 <code>e</code> 更快；</li><li>在太长的目标字符串中使用命名捕获必须进行更多的数据拷贝。</li><li>除非把同一个表达式应用到大规模的文本，或者大量小规模文本时，オ需要考虑模式修饰符 <code>S</code>。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-1/&quot;&gt;《精通正则表达式》学习笔记（一）&lt;/a&gt;&lt;br&gt;Ch.1 正则表达式入门&lt;br&gt;Ch.2 入门示例拓展&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-2/&quot;&gt;《精通正则表达式》学习笔记（二）&lt;/a&gt;&lt;br&gt;Ch.3 正则表达式的特性和流派概览&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-3/&quot;&gt;《精通正则表达式》学习笔记（三）&lt;/a&gt;&lt;br&gt;Ch.4 表达式的匹配原理&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-4/&quot;&gt;《精通正则表达式》学习笔记（四）&lt;/a&gt;&lt;br&gt;Ch.5 正则表达式实用技巧&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-5/&quot;&gt;《精通正则表达式》学习笔记（五）&lt;/a&gt;&lt;br&gt;Ch.6 打造高效正则表达式&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-6/&quot;&gt;《精通正则表达式》学习笔记（六）&lt;/a&gt;&lt;br&gt;Ch.10 PHP 相关的正则表达式&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&quot;PHP-的正则流派&quot;&gt;&lt;a href=&quot;#PHP-的正则流派&quot; class=&quot;headerlink&quot; title=&quot;PHP 的正则流派&quot;&gt;&lt;/a&gt;PHP 的正则流派&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;PHP 的三种正则引擎是 &lt;code&gt;preg&lt;/code&gt;、&lt;code&gt;creg&lt;/code&gt; 和 &lt;code&gt;mb_ereg&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;在默认情况下，preg 套件的正则表达式是以字节为单位的，所以「&lt;code&gt;\C&lt;/code&gt;」默认等价于「&lt;code&gt;(?d:.)&lt;/code&gt;」，由 &lt;code&gt;s&lt;/code&gt; 修饰的点号。不过，如果使用了修饰符 &lt;code&gt;u&lt;/code&gt;，则 preg 套件就会以 UTF-8 字母为单位，也就是说，一个字符可能由 6 个字节组成。即使这样，「&lt;code&gt;\C&lt;/code&gt;」仍然匹配单个字节。&lt;/li&gt;
&lt;li&gt;「&lt;code&gt;\z&lt;/code&gt;」和「&lt;code&gt;\Z&lt;/code&gt;」都能够匹配字符串的末尾，而「&lt;code&gt;\Z&lt;/code&gt;」同样能够匹配最后的换行符。&lt;/li&gt;
&lt;li&gt;「&lt;code&gt;$&lt;/code&gt;」的意义取决于模式修饰符 &lt;code&gt;m&lt;/code&gt; 和 &lt;code&gt;D&lt;/code&gt;：如果没有设定任何修饰符，「&lt;code&gt;$&lt;/code&gt;」等价于「&lt;code&gt;\Z&lt;/code&gt;」（在字符串结尾的换行符，或者是字符串结尾）；如果使用了 &lt;code&gt;m&lt;/code&gt;，则它能够匹配内嵌的换行符，如果使用了模式修饰符 &lt;code&gt;D&lt;/code&gt;，它能够匹配「&lt;code&gt;\z&lt;/code&gt;」（只有在字符串的结尾）。如果同时设置了 &lt;code&gt;m&lt;/code&gt; 和 &lt;code&gt;D&lt;/code&gt;，则忽略 &lt;code&gt;D&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;PHP 正则引擎的处理方式完全是&lt;strong&gt;程序式&lt;/strong&gt;的。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://acuario.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="RegEx" scheme="https://acuario.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/RegEx/"/>
    
    
      <category term="学习笔记" scheme="https://acuario.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="精通正则表达式" scheme="https://acuario.xyz/tags/%E7%B2%BE%E9%80%9A%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="RegEx" scheme="https://acuario.xyz/tags/RegEx/"/>
    
      <category term="PHP" scheme="https://acuario.xyz/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>《精通正则表达式》学习笔记（五）</title>
    <link href="https://acuario.xyz/mastering-regex-summary-5/"/>
    <id>https://acuario.xyz/mastering-regex-summary-5/</id>
    <published>2019-08-07T16:17:53.000Z</published>
    <updated>2019-08-11T15:23:47.249Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="/mastering-regex-summary-1/">《精通正则表达式》学习笔记（一）</a><br>Ch.1 正则表达式入门<br>Ch.2 入门示例拓展</li><li><a href="/mastering-regex-summary-2/">《精通正则表达式》学习笔记（二）</a><br>Ch.3 正则表达式的特性和流派概览</li><li><a href="/mastering-regex-summary-3/">《精通正则表达式》学习笔记（三）</a><br>Ch.4 表达式的匹配原理</li><li><a href="/mastering-regex-summary-4/">《精通正则表达式》学习笔记（四）</a><br>Ch.5 正则表达式实用技巧</li><li><a href="/mastering-regex-summary-5/">《精通正则表达式》学习笔记（五）</a><br>Ch.6 打造高效正则表达式</li><li><a href="/mastering-regex-summary-6/">《精通正则表达式》学习笔记（六）</a><br>Ch.10 PHP 相关的正则表达式</li></ul><hr><ul><li>因为 NFA 引擎容许用户进行精确控制，所以我们可以用心打造正则表达式。</li><li>调校表达式时需要考虑的两个因素是<strong>准确性</strong>和<strong>效率</strong>：精确匹配文本而不包含多余的内容，且速度要快。</li><li>优化表达式的关键在于彻底理解回溯背后的过程，学习些技巧来避免可能的回溯。</li><li>不同工具可能使用不同的优化措施。如果能够预先判断目标字符串基本无法匹配（例如目标宇符串缺少一个引擎能够预知的，匹配成功必须的字符），足够聪明的实现方式可以完全不应用正则表达式。</li><li>在分析效率时，不要忘了不同正则引擎的差异。</li></ul><a id="more"></a><h2 id="多选分支的顺序优化"><a href="#多选分支的顺序优化" class="headerlink" title="多选分支的顺序优化"></a>多选分支的顺序优化</h2><p>期望：匹配引号字符串（允许转义双引号）<br>RegEx：<code>&quot;(\\.|[^\\&quot;])*&quot;</code>   </p><ul><li><strong>多选分支的顺序很重要，其会影响回溯的发生与否和发生回溯的先后顺序。</strong></li><li>调换「<code>\\.</code>」和「<code>[^\\&quot;]</code>」的顺序，只有在遇到字符串中的转义字符时才会按照多选结构进行回溯，这样增加了第一个多选分支的成功匹配次数，有效减少回溯的次数。</li><li>为提高效率修改正则表达式时最需要考虑的问题是，改动是否会影响匹配的准确性。在关注效率的时候，万不可忘记准确性。<em>重新安排多选分支的顺序</em>这种操作，只有在排序与匹配成功无关时才不会影响准确性。</li><li>在任意正则表达式中，星号会对每个普通字符进行迭代（或者说“重复”），重复进入一退出多选结构（和括号）。星号量词作用于括号内的子表达式，每次迭代都需要进入然后再退出括号，因为引擎需要记录括号内的子表达式匹配的文本。为此必须进行处理。</li><li>优化表达式时，使一次迭代中读入尽可能多的字符，尽量减少发生回溯的次数，把星号迭代的次数减少到最小：</li></ul><p><img src="https://i.loli.net/2019/07/25/5d3925bdeb92a68557.jpg" alt></p><h2 id="指数级匹配（超线性，super-linear）"><a href="#指数级匹配（超线性，super-linear）" class="headerlink" title="指数级匹配（超线性，super-linear）"></a>指数级匹配（超线性，super-linear）</h2><ul><li>表达式「<code>&quot;([^\\&quot;]+|\\.)*&quot;</code>」在 POSIX NFA 中匹配 <code>very ...... long</code> 时需要超过 3 亿亿亿次回溯。因为正则表达式中某个元素受加号限定的同时，还受括号外的星号限定，无法区分哪个量词控制哪个特殊的字符。</li><li>对正则表达式「<code>([^\\&quot;]+)*</code>」来说，加号和星号二者分割（divvy up）字符串的可能性是成指数形式增长的。</li><li>对不同类型引擎指数级匹配的差异：<ul><li>如果其中的某个表达式，即使不能匹配，也能很快给出结果，那可能就是 DFA。</li><li>如果只有在能够匹配时才很快出结果，那就是传统型 NFA。</li><li>如果总是很慢，那就是 POSIX NFA。</li></ul></li></ul><h2 id="回溯实例"><a href="#回溯实例" class="headerlink" title="回溯实例"></a>回溯实例</h2><h3 id="匹配成功的回溯"><a href="#匹配成功的回溯" class="headerlink" title="匹配成功的回溯"></a>匹配成功的回溯</h3><ul><li>从局部来看，回溯就是倒退至未尝试的分支。</li></ul><p><img src="https://i.loli.net/2019/07/26/5d3a6ab8dec8f93141.jpg" alt="图像 (9).jpg"></p><ul><li>表达式「<code>&quot;.*&quot;</code>」在 <strong>NFA</strong> 引擎中的匹配过程如图所示：   <ol><li>多次匹配失败直到 A 处   </li><li>从 <code>A-B</code> 处均匹配成功，并在每个位置（共计 46 处）撒下面包屑，记录保存状态   </li><li>从 <code>B-C</code> 开始逐步回溯，直到 <code>C</code> 处匹配成功   </li></ol></li><li>表达式「<code>&quot;.*&quot;</code>」在 <strong>POSIX NFA</strong> 引擎中的匹配过程与 <strong>NFA</strong> 类似，但为了确认<strong><em>最长的匹配</em></strong>，还需进行一些确认操作：   <ol><li>多次匹配失败直到 <code>A</code> 处   </li><li>从 <code>A-B</code> 处均匹配成功，并在每个位置（共计 46 处）撒下面包屑，记录保存状态   </li><li>从 <code>B-C</code> 开始逐步回溯，知道 <code>C</code> 处匹配成功   </li><li>尝试过程 <code>D-E-F</code> 和 <code>F-G-H</code> 类似 <code>B-C-D</code>，只是 <code>F</code> 和 <code>H</code> 会被抛弃，因为它们匹配的文本都比 <code>D</code> 更短</li><li><code>I</code> 位置完成当前匹配的所有回溯，重新启动驱动过程，进行下一轮匹配尝试。但由于已经有匹配成功的文本，所以直接返回匹配结果。</li></ol></li></ul><h3 id="无法匹配成功的回溯"><a href="#无法匹配成功的回溯" class="headerlink" title="无法匹配成功的回溯"></a>无法匹配成功的回溯</h3><p>表达式「<code>&quot;.*&quot;!</code>」无法匹配范例文本，在匹配过程中进行多轮匹配尝试，每次尝试都有回溯产生，其匹配过程如图所示：</p><p><img src="https://i.loli.net/2019/07/26/5d3a6ab8eee6752532.jpg" alt></p><h3 id="通过优化表达式来减少回溯"><a href="#通过优化表达式来减少回溯" class="headerlink" title="通过优化表达式来减少回溯"></a>通过优化表达式来减少回溯</h3><p>表达式「<code>&quot;[^&quot;]*&quot;!</code>」通过使用「<code>[^&quot;]</code>」来替代「<code>.*</code>」，通过减少可能匹配的字符，从而大大降低了回溯产生的次数。减少的回溯就是有意的<strong>伴随效应（side effect）</strong></p><p><img src="https://i.loli.net/2019/07/26/5d3a6ab8c8c5e54462.jpg" alt></p><h3 id="多选结构的回溯"><a href="#多选结构的回溯" class="headerlink" title="多选结构的回溯"></a>多选结构的回溯</h3><p>使用多选结构时，需要注意引起的回溯对性能的影响。</p><p>文本：<code>The name &quot;McDonald&#39;s&quot; is said &quot;makudonarudo&quot; in Japanese</code>.<br>期望：<code>makudonarudo</code>   </p><table><thead><tr><th>RegEx</th><th>回溯次数</th></tr></thead><tbody><tr><td>「<code>[uvwxyz]</code>」</td><td>34</td></tr><tr><td>「<code>u|v|w|x|y|z</code>」</td><td>204</td></tr></tbody></table><h2 id="常见优化原理"><a href="#常见优化原理" class="headerlink" title="常见优化原理"></a>常见优化原理</h2><ul><li>提高匹配效率的优化原理主要有：<ol><li><strong>加速某些操作</strong></li><li><strong>避免冗余操作</strong></li></ol></li><li>只有在检测优化措施是否可行所需的时间少于节省下来的匹配时间的情况下，优化才是有益的。</li><li>优化所需的时间、节省的时间、优化的可能性这三者间存在互相制约的关系。</li></ul><h3 id="应用前的优化"><a href="#应用前的优化" class="headerlink" title="应用前的优化"></a>应用前的优化</h3><ul><li>编译缓存：<ul><li>正则表达式使用之前先进行错误检查，之后编译为内部形式检查字符串。</li><li>为提高编译效率，首次编译之后的内部形式会被保存或缓存下来，在此后的循坏中复用。</li><li>集成式处理中的编译缓存：正则表达式可能每次循环都会变化，优化措施是检査插值后的结果（也就是正则表达式的具体值），只有当具体值发生变化时才重新编译。</li><li>集成式处理中的编译缓存：编译形式与表达式在程序中所处的具体位置相关，正则表达式变化时，先检査插值后的结果（即正则表达式的具体值），当具体值发生变化时才重新编译。</li><li>程序式处理中的编译缓存：<ul><li>编译形式与表达式在程序中所处的具体位置无关，每次调用函数时，正则表达式必须重新编译。</li><li>将最近使用的正则表达式模式（regex pattern）缓存后关联到最终的编译形式。</li><li>调用“应用此表达式”函数之后，作为参数的正则表达式模式会与保存的正则表达式相比较，如果已存在于缓存中，就使用缓存的版本。如果没有，就直接编译这个正则表达式，将其存入缓存。无可用缓存时，丢弃一个最久未使用的编译形式。</li></ul></li><li>面向对象式处理中的编译缓存：正则表达式何时编译完全由程序决定。通过构造函数来进行编译。通过对象析构函数抛弃编译好的正则表达式。</li></ul></li><li>预查（子）字符串优化：在实际应用正则表达式之前，在目标字符串中快速扫描，检査所需的字符或者字符串一如果不存在，根本就不需要进行任何尝试。</li><li>长度判断优化：预先判断目标文本的长度是否满足正则表达式要求的最小长度，若不满足，则不进行任何尝试。</li></ul><h3 id="传动装置的优化"><a href="#传动装置的优化" class="headerlink" title="传动装置的优化"></a>传动装置的优化</h3><table><thead><tr><th>优化策略</th><th>释义</th><th>栗子</th></tr></thead><tbody><tr><td>字符串起始 / 行锚点</td><td>任何以「<code>^</code>」开头的正则表达式只能在「<code>^</code>」能够匹配的情况下才可能匹配。</td><td>「<code>^this|^that</code>」修改为「<code>^(this|that)</code>」或 「<code>^(?:this|that)</code>」</td></tr><tr><td>隐式锚点</td><td>如果正则表达式以「<code>.*</code>」或「<code>.+</code>」开头，且没有全局性多选结构（global alternation），则可以认为此正则表达式的开头有一个看不见的「<code>^</code>」。则使用上一节的“字符串起始 / 行锚点优化”，节省大量的时间。</td><td></td></tr><tr><td>字符串结束 / 行锚点</td><td>遇到末尾为「<code>$</code>」或其他结束锚点的正则表达式时，能够从字符申末尾倒数若干字符的位置开始尝试匹配。</td><td>「<code>regex(es)?$</code>」从倒数第 8 个字符开始匹配</td></tr><tr><td>开头字符 / 字符组 / 子串识别</td><td>容许传动装置预先检查字符串中的每个字符，只在可能匹配的位置进行应用，这样能节省大量的时间。避免从错误的位置开始执行匹配尝试。</td><td>「<code>this|that|other</code>」只能从「<code>[ot]</code>」位置开始匹配</td></tr><tr><td>内嵌文字字符串检查</td><td>类似初始字符串识别优化，使用高速的 Boyer-Moore 字符串检索算法寻找目标位置。</td><td></td></tr><tr><td>长度识别传动</td><td>当前位置距离字符申末尾的长度小于成功匹配所需最小长度，传动装置会停止匹配尝试。</td><td></td></tr></tbody></table><h3 id="正则表达式本身的优化"><a href="#正则表达式本身的优化" class="headerlink" title="正则表达式本身的优化"></a>正则表达式本身的优化</h3><ul><li>文字字符串连接：把多个字符串当作整体而非分离的个体，例如将「<code>abc</code>」视为整体而非，「<code>a</code>」然后「<code>b</code>」然后「<code>c</code>」。</li><li>化简量词：约束普通元素的加号、星号之类的量词。避免普通 NFA 引擎的大部分逐步处理开销（step-by-step overhead）。例如「<code>.*</code>」和「<code>(?:.)*</code>」在逻辑上是相等的，但是在进行此优化的系统中，「<code>.*</code>」实际上更快。</li><li>消除无必要括号：使用无括号的等价的表达式进行替换。如使用「<code>.*</code>」替换「<code>(?:.)*</code>」。</li><li>消除不需要的字符组：将只包含单个字符的字符组在内部进行转换。如「<code>[.]</code>」转换为「<code>\.</code>」。</li><li>忽略优先量词之后的字符优化：忽略优先量词通常比匹配优先量词要慢。如果文字字符跟在忽略优先量词之后，只要引擎没有触及那个文字字符，忽略优先量词可以作为普通的匹配优先量词来处理，从而跳过常规的“忽略”状态。</li><li>“过度”回溯检测：限定回溯堆栈的大小，即限定回溯的次数，在“超限”时停止匹配。</li><li>避免指数级匹配：在匹配尝试进入超线性状态时进行检测，记录每个量词对应的子表达式尝试匹配的位置，绕过重复尝试。</li><li>使用占有优先量词削减状态：不保留“在此处不进行匹配”的状态，在量词全部尝试完成之后抛弃所有备用状态，每一轮迭代时抛弃上轮的备用状态。否则，如应用「<code>.*</code>」会在匹配每个字符时创造一个状态，如果字符串很长，会占用大量的内存。</li><li>量词等价转换：根据不同语言的正则表达式特性，对量词进行替换，如「<code>\d\d\d\d</code>」替换为「<code>\d{4}</code>」。</li><li>需求识别：预先取消它认为对匹配结果没有价值的工作。</li></ul><h2 id="常见优化方法"><a href="#常见优化方法" class="headerlink" title="常见优化方法"></a>常见优化方法</h2><table><thead><tr><th>优化方法</th><th>释义</th><th>栗子</th></tr></thead><tbody><tr><td>避免重新编译</td><td>编译和定义正则表达式的次数应该尽可能的少。在循环外创建正则表达式对象，在循环中重复使用。函数式处理要保证循环中使用的正则表达式的数目少于工具所能缓存的上限。集成式处理避免在循环内的正则表达式中使用变量插值。</td><td></td></tr><tr><td>使用非捕获型括号</td><td>不需要引用的文本，使用非捕获型括号「<code>(?:...)</code>」节省捕获时间，减少回溯使用的状态的数量。</td><td></td></tr><tr><td>不要滥用括号</td><td>使用括号会阻止某些优化措施。</td><td></td></tr><tr><td>不要滥用字符组</td><td>使用元字符来替代单个字符的字符组</td><td>使用「<code>\.</code>」来替代「<code>[.]</code>」</td></tr><tr><td>使用起始锚点</td><td>以「<code>.*</code>」开头的正则表达式都应该在最前面添加「<code>^</code>」或者「<code>\A</code>」。配合开头字符 / 字符串 / 字串识别优化，节省不必要的工作。</td><td></td></tr><tr><td>将文字文本独立出来</td><td>“提取”必要元素：暴露必须的匹配内容。</td><td>使用「<code>xx*</code>」替代「<code>x+</code>」暴露匹配 <code>x</code>，使用「<code>------{0,2}</code>」替代「<code>-{5,7}</code>」暴露匹配 <code>-</code>。</td></tr><tr><td>将文字文本独立出来</td><td>“提取”多选结构开头的必须元素</td><td>使用「<code>------{0,2}</code>」替代「<code>-{5,7}</code>」暴露匹配 <code>-</code>。</td></tr><tr><td>将锚点独立出来</td><td>在表达式前面独立出 <code>^</code> 和 <code>\G</code></td><td></td></tr><tr><td>将锚点独立出来</td><td>在表达式末尾独立出 <code>$</code></td><td></td></tr></tbody></table><ul><li>如果目标字符串很长：<ul><li>分号接近字符串的开头，使用忽略优先量词。</li><li>分号接近宇符串末尾的位置，使用匹配优先量词。</li><li>若是随机数据，又不知道分号接近文首或文尾，则使用匹配优先的量词。</li></ul></li><li>如果目标字符串很短，使用何种优先量词无所谓。</li><li>多个小正则表达式的速度比一个大正则表达式要快得多。</li><li>在表达式的开头添加合适的环视结构，可以让表达式对文本进行“预査”，选择合适的开始位置。</li><li>固化分组和占有优先量词能够极大地提高匹配速度，而不会改变匹配结果。</li><li>主导引擎的匹配<ul><li>将最可能匹配的多选分支放在前头：许多时候多选分支的摆放顺序比优化更重要，但如果顺序与匹配正确无关，就应该把最可能匹配的多选分支放在首位。这一点只对传统型 NFA 引擎且只有存在匹配的时候才适用。对 POSIX NFA 或不存在匹配时，所有的多选分支都必须检测，所以顺序是无关紧要的。</li><li>将结尾部分分散到多选结构内：把尾部通配表达式加到多选结构之内，匹配时不需要退出多选结构就能发现失败，则匹配失败的更快。</li></ul></li><li>各种优化都是平等的，在优化时请务必小心，不要因小失大。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-1/&quot;&gt;《精通正则表达式》学习笔记（一）&lt;/a&gt;&lt;br&gt;Ch.1 正则表达式入门&lt;br&gt;Ch.2 入门示例拓展&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-2/&quot;&gt;《精通正则表达式》学习笔记（二）&lt;/a&gt;&lt;br&gt;Ch.3 正则表达式的特性和流派概览&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-3/&quot;&gt;《精通正则表达式》学习笔记（三）&lt;/a&gt;&lt;br&gt;Ch.4 表达式的匹配原理&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-4/&quot;&gt;《精通正则表达式》学习笔记（四）&lt;/a&gt;&lt;br&gt;Ch.5 正则表达式实用技巧&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-5/&quot;&gt;《精通正则表达式》学习笔记（五）&lt;/a&gt;&lt;br&gt;Ch.6 打造高效正则表达式&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-6/&quot;&gt;《精通正则表达式》学习笔记（六）&lt;/a&gt;&lt;br&gt;Ch.10 PHP 相关的正则表达式&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;因为 NFA 引擎容许用户进行精确控制，所以我们可以用心打造正则表达式。&lt;/li&gt;
&lt;li&gt;调校表达式时需要考虑的两个因素是&lt;strong&gt;准确性&lt;/strong&gt;和&lt;strong&gt;效率&lt;/strong&gt;：精确匹配文本而不包含多余的内容，且速度要快。&lt;/li&gt;
&lt;li&gt;优化表达式的关键在于彻底理解回溯背后的过程，学习些技巧来避免可能的回溯。&lt;/li&gt;
&lt;li&gt;不同工具可能使用不同的优化措施。如果能够预先判断目标字符串基本无法匹配（例如目标宇符串缺少一个引擎能够预知的，匹配成功必须的字符），足够聪明的实现方式可以完全不应用正则表达式。&lt;/li&gt;
&lt;li&gt;在分析效率时，不要忘了不同正则引擎的差异。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://acuario.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="RegEx" scheme="https://acuario.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/RegEx/"/>
    
    
      <category term="学习笔记" scheme="https://acuario.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="精通正则表达式" scheme="https://acuario.xyz/tags/%E7%B2%BE%E9%80%9A%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="RegEx" scheme="https://acuario.xyz/tags/RegEx/"/>
    
      <category term="正则表达式的优化" scheme="https://acuario.xyz/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>SSH配置登陆密钥和别名</title>
    <link href="https://acuario.xyz/configure-ssh-host-and-keychain/"/>
    <id>https://acuario.xyz/configure-ssh-host-and-keychain/</id>
    <published>2019-07-29T16:30:07.000Z</published>
    <updated>2019-08-02T16:50:30.831Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通常在 Shell 中使用 SSH 连接远程服务器时，我们需要输入完整的 SSH 命令，如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ssh user@example.com#连接远端22端口并输入密码登陆</span><br></pre></td></tr></table></figure><p>然后根据提示输入 <code>user</code> 用户的密码登陆主机。</p><p>有两个常用的参数：</p><ul><li><code>-p</code> 指定其他 SSH 端口，如 SSH 端口非 22 端口，可用此参数指定</li><li><code>-i</code> 指定私钥通过密钥登陆，可配置好密钥后对免密登陆</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 连接远端1234端口</span><br><span class="line">$ ssh user@example.com -p 1234</span><br><span class="line"></span><br><span class="line"># 使用私钥id_rsa登陆</span><br><span class="line">$ ssh user@example.com -i ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><p>但是随着手头服务器配置的增加，而不同服务器 IP、端口、用户、使用的密钥均不同，每次繁琐地查询和输入这么多配置和参数实在是麻烦，何况我怎么记得住这么多 IP 地址啊！（主要还是因为懒</p><a id="more"></a><h1 id="配置密钥登陆"><a href="#配置密钥登陆" class="headerlink" title="配置密钥登陆"></a>配置密钥登陆</h1><p>通过修改 SSH 的配置文件，为服务器预先配置好各主机的私钥和别名，之后就可以方便快捷地登陆服务器。</p><p>修改 <code>~/.ssh/config</code> 文件，格式如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host *</span><br><span class="line">AddKeysToAgent yes</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><p>上例配置 SSH 默认使用私钥 <code>~/.ssh/id_rsa</code> 进行连接。如果远端服务器已经事先将 <code>~/.ssh/id_rsa.pub</code> 添加到对应用户的 <code>~/.ssh/authorized_keys</code> 文件中，那么在本地执行命令 <code>$ ssh user@example.com</code> 后就可以自动免密登陆主机 <code>example.com</code></p><h1 id="配置主机别名"><a href="#配置主机别名" class="headerlink" title="配置主机别名"></a>配置主机别名</h1><p>对于个别不同的服务器配置，我们可以继续在 <code>~/.ssh/config</code> 文件中添加配置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host test</span><br><span class="line">Hostname localhost.test</span><br><span class="line">Port 1234</span><br><span class="line">IdentityFile ~/.ssh/test_rsa</span><br><span class="line">User ubuntu</span><br></pre></td></tr></table></figure><p>上例配置主机 <code>localhost.test:1234</code> 使用用户 <code>ubuntu</code> 和私钥 <code>~/.ssh/test_rsa</code> 进行连接。如果不配置 <code>IdentityFile</code> 则会提示输入密码才能登陆。</p><p>可以看到上述配置的 <code>Host</code> 项即为 SSH 连接的别名。该例中 <code>Host</code> 值为 <code>test</code>，那么我们在需要 SSH 连接主机 <code>localhost.test:1234</code> 的时候就可以直接执行命令立即免密登陆远端主机：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh test</span><br></pre></td></tr></table></figure><h1 id="命令别名"><a href="#命令别名" class="headerlink" title="命令别名"></a>命令别名</h1><p>如果不想这么麻烦，也可以通过设置命令别名来达到目的</p><p>修改 <code>~/.bash_profile</code> 文件，并根据服务器配置添加不同的命令别名：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alias myserver=&quot;ssh user@example.com&quot;</span><br><span class="line">alias myserver1234=&quot;ssh user@localhost.test -p 1234&quot;</span><br><span class="line">alias myserver=&quot;ssh user@remote.test -i ~/.ssh/id_rsa&quot;</span><br></pre></td></tr></table></figure><p>需要 SSH 连接主机 <code>localhost.test:1234</code> 的时候执行命令 <code>$ myserver1234</code> 即可。</p><p>真是好方便呢！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;通常在 Shell 中使用 SSH 连接远程服务器时，我们需要输入完整的 SSH 命令，如：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ ssh user@example.com			#连接远端22端口并输入密码登陆&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后根据提示输入 &lt;code&gt;user&lt;/code&gt; 用户的密码登陆主机。&lt;/p&gt;
&lt;p&gt;有两个常用的参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-p&lt;/code&gt; 指定其他 SSH 端口，如 SSH 端口非 22 端口，可用此参数指定&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-i&lt;/code&gt; 指定私钥通过密钥登陆，可配置好密钥后对免密登陆&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 连接远端1234端口&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ ssh user@example.com -p 1234&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 使用私钥id_rsa登陆&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ ssh user@example.com -i ~/.ssh/id_rsa&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是随着手头服务器配置的增加，而不同服务器 IP、端口、用户、使用的密钥均不同，每次繁琐地查询和输入这么多配置和参数实在是麻烦，何况我怎么记得住这么多 IP 地址啊！（主要还是因为懒&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="https://acuario.xyz/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="https://acuario.xyz/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="SSH" scheme="https://acuario.xyz/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>《精通正则表达式》学习笔记（四）</title>
    <link href="https://acuario.xyz/mastering-regex-summary-4/"/>
    <id>https://acuario.xyz/mastering-regex-summary-4/</id>
    <published>2019-07-23T13:44:11.000Z</published>
    <updated>2019-08-11T15:23:52.894Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="/mastering-regex-summary-1/">《精通正则表达式》学习笔记（一）</a><br>Ch.1 正则表达式入门<br>Ch.2 入门示例拓展</li><li><a href="/mastering-regex-summary-2/">《精通正则表达式》学习笔记（二）</a><br>Ch.3 正则表达式的特性和流派概览</li><li><a href="/mastering-regex-summary-3/">《精通正则表达式》学习笔记（三）</a><br>Ch.4 表达式的匹配原理</li><li><a href="/mastering-regex-summary-4/">《精通正则表达式》学习笔记（四）</a><br>Ch.5 正则表达式实用技巧</li><li><a href="/mastering-regex-summary-5/">《精通正则表达式》学习笔记（五）</a><br>Ch.6 打造高效正则表达式</li><li><a href="/mastering-regex-summary-6/">《精通正则表达式》学习笔记（六）</a><br>Ch.10 PHP 相关的正则表达式</li></ul><hr><blockquote><p>编写巧妙的正则表达式不仅仅是一种手艺(skill) 而且还是一种艺术(art)。</p></blockquote><h1 id="正则引擎的平衡法则"><a href="#正则引擎的平衡法则" class="headerlink" title="正则引擎的平衡法则"></a>正则引擎的平衡法则</h1><ul><li>只匹配期望的文本，排除不期望的文本。</li><li>易于控制和理解。</li><li>使用NFA引擎时必须保证效率——能够匹配时立即返回匹配结果，不能匹配时尽快报告匹配失败。</li></ul><a id="more"></a><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><h2 id="匹配-IP-地址"><a href="#匹配-IP-地址" class="headerlink" title="匹配 IP 地址"></a>匹配 IP 地址</h2><ul><li>「<code>[0-9]*\.[0-9]*\.[0-9]*\.[0-9]*</code>」会匹配 <code>and then ......</code></li><li>「<code>^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$</code>」字符组书写重复</li><li>「<code>^\d+\.\d+\.\d+\.\d+$</code>」会匹配非 IP 地址文本如：<code>1234.5678.9101112.131415</code></li><li>「<code>^\d\d\d\.\d\d\d\.\d\d\d\.\d\d\d$</code>」数字部分匹配不够灵活，仅能匹配 3 位数字</li><li>下面三个表达式会匹配非法 IP 地址数字 <code>999</code><ul><li>「<code>^\d{1,3}.\d{1,3}.\d{1,3}.\d{1,3}$</code>」</li><li>「<code>\d\d?\d?.\d\d?\d?.\d\d?\d?.\d\d?\d?$</code>」</li><li>「<code>\d(\d\d?)?.\d(\d\d?)?.\d(\d\d?)?.\d(\d\d?)?$</code>」</li></ul></li><li>分析 IP 地址结构可以得出以下规律：<ul><li>只包含一个或两个数字的字段，无需考虑合法性，即「<code>\d|\d\d</code>」。</li><li><code>0</code> 或 <code>1</code> 开头的三位数（<code>000</code>-<code>199</code>）都合法。即「<code>[01]\d\d</code>」。</li><li><code>2</code> 开头的三位数字，第二位数字小于 <code>5</code> 则合法（<code>255</code>），即「<code>2[0-4]\d</code>」。</li><li>若第二位数字是 <code>5</code>，第三位数字就必须小于 <code>6</code>（<code>256</code>），即「<code>25[0-5]</code>」。</li><li>上述结果为「<code>\d|\d\d|[01]\d\d|2[0-4]\d|25[0-5]</code>」</li><li>合并前三个多选分支「<code>\d|\d\d|[01]\d\d</code>」为「<code>[01]?\d\d?</code>」</li><li>综上，一个 IP 地址数字的表达式结果为「<code>[01]?\d\d?|2[0-4]\d|25[0-5]</code>」</li></ul></li><li><p>匹配一个 IP 地址的表达式为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">「^([01]?\d\d?|2[0-4]\d|25[0-5])\.([01]?\d\d?|2[0-4]\d|25[0-5])\.([01]?\d\d?|2[0-4]\d|25[0-5])\.([01]?\d\d?|2[0-4]\d|25[0-5])$」</span><br></pre></td></tr></table></figure></li><li><p>在「<code>^</code>」后添加环视「<code>(?!0+\.0+\.0+\.0+$)</code>」来避免匹配 <code>0.0.0.0</code></p></li><li>在表达式首尾添加环视「<code>(?&lt;![\w.])</code>…<code>(?![\w.])</code>」或使用「<code>(^| )</code>…<code>( |$)</code>」来保证匹配文本前后不出现「<code>[\w.]</code>」能匹配的字符，避免匹配嵌套型字符 <code>1.2.3.4.5.6</code> 中的 <code>1.2.3.4</code> 等类似 IP 地址的文本</li><li>某些时候，处理各种极端情形会降低投入产出比。更合适的做法是<strong>不依赖正则表达式完成全部工作，善用其他工具辅助验证</strong>。</li></ul><h2 id="处理文件名"><a href="#处理文件名" class="headerlink" title="处理文件名"></a>处理文件名</h2><p>文本：<code>/usr/local/bin/gcc</code><br>期望：<code>gcc</code>   </p><ol><li>去掉文件名开头的路径<br>RegEx：<code>^.*/</code><br>释义：使用匹配优先（贪婪）特性，匹配一整行，然后回溯到最后的斜线   </li></ol><ul><li>若匹配一个恰好没有斜线的字符串，正则引擎会在字符串的起始位置开始搜索。「<code>.*</code>」抵达字符串的末尾，但不断回退，直到最后它交还了匹配的所有字符，仍然无法匹配。此时，正则引擎得知<strong>在字符串的起始位</strong>不存在匹配。</li><li>之后传动装置开始工作，从第 2 个字符开始，依次尝试匹配整个正则表达式，在字符串的每个位置进行扫描回溯。若字符串很长，就可能存在大量的回溯（DFA 不存在这个问题)。</li><li>几乎所有以「<code>.*</code>」开头的正则表达式，在某个字符串的起始位置不能匹配，也就不能在其他任何位置匹配，它只会在字符串的起始位置尝试一次。</li><li>在正则表达式中写明开头位置的匹配规则更明智一些。</li></ul><ol start="2"><li>从路径中获取文件名<br>RegEx：<code>([^/]*)$</code><br>释义：在结尾设置一个锚点，忽略路径，从最后一个斜线开始匹配所有内容。   </li></ol><ul><li>该表达式的唯一要求是字符串有 <code>$</code> 能够匹配的结束位置</li><li>在 NFA 中，该表达式的效率很低，要进行 40+ 次回溯。</li></ul><ol start="3"><li>所在路径和文件名<br>RegEx：<code>^(.*)/(.*)$</code><br>释义：使用 <code>$1</code> 和 <code>$2</code> 来提取所在路径和文件名。第一个「<code>.*</code>」先捕获所有文本，不给「<code>/</code>」和 <code>$2</code> 留下任何字符，在尝试匹配「<code>/(.*)$</code>」时发生的回溯会把“交还的”部分留给后面的「<code>.*</code>」。   </li></ol><h2 id="匹配对称的括号"><a href="#匹配对称的括号" class="headerlink" title="匹配对称的括号"></a>匹配对称的括号</h2><ol><li>「<code>\(.*\)</code>」 匹配括号及括号内部的任何字符。</li><li>「<code>\([^)]*\)</code>」 匹配从一个开括号到最近的闭括号。</li><li>「<code>\([^()]*\)</code>」 匹配从一个开括号到最近的闭括号，但是不容许其中包含开括号。</li></ol><ul><li>上下述三个表达式用于匹配带括号的文本内容，匹配结果如图</li></ul><p><img src="https://i.loli.net/2019/07/17/5d2e05fe2848445405.png" alt="匹配带括号的文本"></p><ul><li>为解决<strong>正则表达式无法匹配任意深度的嵌套结构</strong>的问题，可以用正则表达式来匹<br>配特定深度的嵌套括号，但不是任意深度的嵌套括号。</li><li>处理单层嵌套的正则表达式是:「<code>\([^()]*(\([^()]*\)[^()]*)*\)</code>」</li></ul><h2 id="匹配浮点数"><a href="#匹配浮点数" class="headerlink" title="匹配浮点数"></a>匹配浮点数</h2><ul><li>「<code>-?[0-9]*\.?[0-9]*</code>」会匹配 <code>-.0</code></li><li>「<code>-?[0-9]*\.?[0-9]*</code>」会产生空匹配（匹配没有任何必须的元素），如 <code>this has no number</code>、<code>nothing here</code></li><li><strong>把真正意图表达清楚</strong>非常重要：一个浮点数必须要有至少一位数字，否则就不是一个合法的值。</li><li>「<code>-?[0-9]+</code>」用于限定浮点数含有数字的特性</li><li>「<code>(\.[0-9]*)?</code>」用于限定浮点数的<em>小数点</em>和<em>小数部分</em></li><li>综上，「<code>-?[0-9]+(\.[0-9]*)?</code>」即可用于匹配浮点数而不匹配空字符，即不产生<strong>空匹配</strong></li></ul><h2 id="匹配分隔符之内的文本"><a href="#匹配分隔符之内的文本" class="headerlink" title="匹配分隔符之内的文本"></a>匹配分隔符之内的文本</h2><p>文本：<code>a passport needs a &quot;2\&quot;x3\&quot; likeness&quot; of the holder</code><br>期望：<code>&quot;2\&quot;x3\&quot; likeness&quot;</code>   </p><ul><li>匹配分隔符之内的文本的主要步骤：<ol><li>匹配起始分隔符(opening delimiter)。</li><li>匹配正文(main text,即结束分隔符之前的所有文本)。</li><li>匹配结束分隔符。</li></ol></li><li>匹配开始和结束分隔符很容易，但匹配正文的时不能超越结束分隔符：<ul><li>匹配非引号内容：「<code>[^&quot;]</code>」   </li><li>匹配转义的反斜线需要使用环视：「<code>(?&lt;=\\)&quot;</code>」   </li><li>综上得出的表达式为「<code>&quot;([^&quot;]|(?&lt;=\\)&quot;)*&quot;</code>」，此时可以匹配 <code>2\&quot;x3\&quot;</code></li></ul></li></ul><p>文本：<code>&quot;/-|-\\&quot; or &quot;[^-^]&quot;</code><br>期望：<code>&quot;/-|-\\&quot;</code><br>RegEx：<code>&quot;([^&quot;]|(?&lt;=\\)&quot;)*&quot;</code><br>结果：<code>&quot;/-|-\\&quot; or &quot;</code>   </p><ul><li>第一个闭引号之前存在一个反斜线，该反斜线本身是被转义的，其后的引号是表示引用文本的结束。逆序环视无法识别这个被转义的反斜线。</li><li>匹配的位于开始分隔符和结東分隔符之间的文本可以包括转义的字符「<code>\\.</code>」，也可以包括非引号的任何字符「<code>[^&quot;]</code>」。</li><li>综上得出的表达式为「<code>&quot;(\\.|[^&quot;])*&quot;</code>」</li><li>匹配优先和忽略优先都期望获得匹配，如果找不到结束的引号，它就会回溯，从而降低性能。</li><li>如果回溯会导致不期望，与多选结构有关的匹配结果，可能是因为任何成功的匹配都不过是多选分支的排列顺序造成的偶然结果，</li><li>如果有<strong>占有优先量词</strong>或者是<strong>固化分组</strong>，那么这个正则表达式可以被持续优化以提升性能（特别是对于 NFA）</li></ul><h2 id="去除文本首尾的空白字符"><a href="#去除文本首尾的空白字符" class="headerlink" title="去除文本首尾的空白字符"></a>去除文本首尾的空白字符</h2><ol><li>去除文本首部的空白字符「<code>s/^\s+//</code>」<br>去除文本末尾的空白字符「<code>s/\s+$/</code>」   </li><li>去除文本首尾空白字符的表达式：「<code>s/\s*(.*?)\s*$/$1/s</code>」<br>该表达式因为忽略优先约束的点号每次应用时都要检查「<code>\s*$</code>」导致大量回溯，严重影响效率。</li><li>去除文本首尾空白字符的表达式：「<code>s/^\s*((?:.*\S)?)\s*$/$1/s</code>」后面的「<code>\S</code>」强迫回溯直到找到一个非空字符，把剩下的空白字符留给最后的「<code>\s*$</code>」，捕获括号之外的内容。</li></ol><h1 id="HTML-相关范例"><a href="#HTML-相关范例" class="headerlink" title="HTML 相关范例"></a>HTML 相关范例</h1><h2 id="匹配-HTML-Tag"><a href="#匹配-HTML-Tag" class="headerlink" title="匹配 HTML Tag"></a>匹配 HTML Tag</h2><p>RegEx：<code>&lt;(&quot;[^&quot;]*&quot;|&#39;[^&#39;]*&#39;|[^&#39;&quot;&gt;])*&gt;</code><br>释义：<br><img src="https://i.loli.net/2019/07/20/5d31ec5ad68a949796.png" alt="匹配 HTML Tag"></p><ul><li>引用字符串可能为空（例如 <code>alt=&quot;&quot;</code>）, 所以最开始的两个多选分支的引号中使用「<code>*</code>」而非「<code>+</code>」。</li><li>NFA 引擎下，多选分支之间不存在重复，所以最后的「<code>&gt;</code>」无法匹配是产生的回溯是不需要的，可使用非捕获型括号改写表达式以提高效率。</li></ul><h2 id="匹配-HTML-Link"><a href="#匹配-HTML-Link" class="headerlink" title="匹配 HTML Link"></a>匹配 HTML Link</h2><p>文本：<code>...&lt;a href=&quot;http://www.oreilly.com&quot;&gt;O&#39;Reilly Media&lt;/a&gt;...</code><br>期望：<code>http://www.oreilly.com</code> 和 <code>O&#39;Reilly Media</code><br>RegEx：<code>\b HRFF\s* = \s*(?:&quot;([^&quot;]*)&quot;|&#39;([^&#39;]*)&#39;|([^&#39;&quot;&gt;\S]+))</code><br>释义：<br><img src="https://i.loli.net/2019/07/20/5d31f0a71ac2934742.png" alt="匹配 HTML Link"></p><h2 id="校验-HTTP-URL"><a href="#校验-HTTP-URL" class="headerlink" title="校验 HTTP URL"></a>校验 HTTP URL</h2><p>将 URL 地址分解为主机名（hostname）和路径（path）两部分。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^http://        # 匹配协议</span><br><span class="line">([^/:]+)        # 捕获主机名</span><br><span class="line">(:(\d+))?       # 匹配端口号（可能没有）</span><br><span class="line">(/.*)?$         # 捕获路径</span><br></pre></td></tr></table></figure><h2 id="提取-URL"><a href="#提取-URL" class="headerlink" title="提取 URL"></a>提取 URL</h2><p>从纯文本中提取 URL 的正则表达式框架如下：<br><img src="https://i.loli.net/2019/07/22/5d34a44a170a511410.png" alt="提取纯文本中的URL"></p><h2 id="几个保持数据协调性的原则"><a href="#几个保持数据协调性的原则" class="headerlink" title="几个保持数据协调性的原则"></a>几个保持数据协调性的原则</h2><p>手动保持正则引擎的协调，才能忽略不需要的文本。有时为了提高表达式的效率，应该选择跳过不需要的文本，而非使用正向思维直接匹配目标文本。</p><ol><li>根据期望保持匹配的协调性<br>合理使用忽略优先量词，在后面的表达式失败之前，优先忽略容易引起大范围匹配成功的匹配操作。跳过我们希望跳过的文本而进行匹配。</li><li>不匹配时也应当保证协调性   </li><li>使用「<code>\G</code>」保证协调<br>「<code>\G</code>」用于匹配上一次匹配结束的位置。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-1/&quot;&gt;《精通正则表达式》学习笔记（一）&lt;/a&gt;&lt;br&gt;Ch.1 正则表达式入门&lt;br&gt;Ch.2 入门示例拓展&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-2/&quot;&gt;《精通正则表达式》学习笔记（二）&lt;/a&gt;&lt;br&gt;Ch.3 正则表达式的特性和流派概览&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-3/&quot;&gt;《精通正则表达式》学习笔记（三）&lt;/a&gt;&lt;br&gt;Ch.4 表达式的匹配原理&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-4/&quot;&gt;《精通正则表达式》学习笔记（四）&lt;/a&gt;&lt;br&gt;Ch.5 正则表达式实用技巧&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-5/&quot;&gt;《精通正则表达式》学习笔记（五）&lt;/a&gt;&lt;br&gt;Ch.6 打造高效正则表达式&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-6/&quot;&gt;《精通正则表达式》学习笔记（六）&lt;/a&gt;&lt;br&gt;Ch.10 PHP 相关的正则表达式&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;编写巧妙的正则表达式不仅仅是一种手艺(skill) 而且还是一种艺术(art)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;正则引擎的平衡法则&quot;&gt;&lt;a href=&quot;#正则引擎的平衡法则&quot; class=&quot;headerlink&quot; title=&quot;正则引擎的平衡法则&quot;&gt;&lt;/a&gt;正则引擎的平衡法则&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;只匹配期望的文本，排除不期望的文本。&lt;/li&gt;
&lt;li&gt;易于控制和理解。&lt;/li&gt;
&lt;li&gt;使用NFA引擎时必须保证效率——能够匹配时立即返回匹配结果，不能匹配时尽快报告匹配失败。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://acuario.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="RegEx" scheme="https://acuario.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/RegEx/"/>
    
    
      <category term="学习笔记" scheme="https://acuario.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="精通正则表达式" scheme="https://acuario.xyz/tags/%E7%B2%BE%E9%80%9A%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="RegEx" scheme="https://acuario.xyz/tags/RegEx/"/>
    
      <category term="正则引擎" scheme="https://acuario.xyz/tags/%E6%AD%A3%E5%88%99%E5%BC%95%E6%93%8E/"/>
    
      <category term="平衡法则" scheme="https://acuario.xyz/tags/%E5%B9%B3%E8%A1%A1%E6%B3%95%E5%88%99/"/>
    
      <category term="正则表达式实例" scheme="https://acuario.xyz/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AE%9E%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>《精通正则表达式》学习笔记（三）</title>
    <link href="https://acuario.xyz/mastering-regex-summary-3/"/>
    <id>https://acuario.xyz/mastering-regex-summary-3/</id>
    <published>2019-07-14T15:27:11.000Z</published>
    <updated>2019-08-11T15:23:57.508Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="/mastering-regex-summary-1/">《精通正则表达式》学习笔记（一）</a><br>Ch.1 正则表达式入门<br>Ch.2 入门示例拓展</li><li><a href="/mastering-regex-summary-2/">《精通正则表达式》学习笔记（二）</a><br>Ch.3 正则表达式的特性和流派概览</li><li><a href="/mastering-regex-summary-3/">《精通正则表达式》学习笔记（三）</a><br>Ch.4 表达式的匹配原理</li><li><a href="/mastering-regex-summary-4/">《精通正则表达式》学习笔记（四）</a><br>Ch.5 正则表达式实用技巧</li><li><a href="/mastering-regex-summary-5/">《精通正则表达式》学习笔记（五）</a><br>Ch.6 打造高效正则表达式</li><li><a href="/mastering-regex-summary-6/">《精通正则表达式》学习笔记（六）</a><br>Ch.10 PHP 相关的正则表达式</li></ul><hr><h1 id="正则引擎的分类"><a href="#正则引擎的分类" class="headerlink" title="正则引擎的分类"></a>正则引擎的分类</h1><p>正则引擎主要分为 3 类：</p><ol><li>DFA（符合或不符合 POSIX 标准的都属此类）</li><li>传统型 NFA</li><li>POSIX NFA</li></ol><table><thead><tr><th>引擎类型</th><th>程序</th><th>忽略优先量词（懒惰）</th><th>捕获型括号</th><th>回溯</th></tr></thead><tbody><tr><td>DFA</td><td><code>awk</code>（大多数版本）、<code>egrep</code>（大多数版本）、<code>flex</code>、<code>lex</code>、MySQL、Procmail</td><td>不支持</td><td>不支持</td><td>不支持</td></tr><tr><td>传统型 NFA</td><td>GNU Emacs、Java、<code>grep</code>（大多数版本）、<code>less</code>、<code>more</code>、.NET 语言、PCRE library、Perl、PHP（所有三套正则库）、Python、Ruby、sed（大多数版本）、<code>vi</code></td><td>支持</td><td>支持</td><td>支持，但性能差</td></tr><tr><td>POSIX NFA</td><td><code>mawk</code>、Mortice Kern Systems’utilities、GNU Emacs（明确指定时使用）</td><td>不支持</td><td>支持</td><td>支持，但性能差</td></tr><tr><td>DFA/NFA 混合</td><td>GNU <code>awk</code>、GNU <code>grep/egrep</code>、Tcl</td><td>支持</td><td>支持</td><td>DFA 支持</td></tr></tbody></table><ul><li>判断是否传统型 NFA：是否支持忽略优先量词（懒惰）。使用正则表达式 <code>nfa|nfa not</code> 来匹配字符串 <code>nfa not</code>，如果只匹配了 <code>nfa</code>，这就是传统型 NFA。如果整个 <code>nfa not</code> 都能匹配，则此引擎要么是 POSIXNFA，要么是 DFA。</li></ul><a id="more"></a><h1 id="匹配的基础"><a href="#匹配的基础" class="headerlink" title="匹配的基础"></a>匹配的基础</h1><p>普适规则：</p><ol><li>优先选择最左端（最靠开头）的匹配结果。</li><li>标准的匹配量词（<code>*</code>、<code>+</code>、<code>?</code> 和 <code>{m，n}</code>）是匹配优先（greedy，贪婪）的。</li></ol><ul><li>标准匹配量词的结果“可能”并非所有可能中最长的，但它们总是尝试匹配尽可能多的字符，直到<strong>匹配上限</strong>为止。如果最终结果并非该表达式的所有可能中最长的，原因肯定是匹配字符过多导致匹配失败。</li><li>「<code>.*</code>」永远不会失败，因为“不匹配任何字符”也是「<code>.*</code>」的可能结果之一。</li><li>「<code>(.*).*</code>」结果没有变化。开头的「<code>.*</code>」（括号中的）会霸占整个标题的文本，而不给第二个「<code>.*</code>」留下任何字符。而第二个「<code>.*</code>」的匹配失败并不要紧，因为「<code>.*</code>」不匹配任何字符也能成功。如果我们给第二个「<code>.*</code>」也加上括号，<code>$2</code>将会是空白。</li><li>表达式中的某些部分可能“<strong>强迫</strong>”之前匹配优先的部分“释放”（或者说“交还（unmatch）”） 某些字符。例如：「<code>^.*([0-9][0-9])</code>」将“<strong>强迫</strong>”「<code>.*</code>」交还两个数字使得匹配成功。</li><li>多个贪婪贪婪量词之间遵循「<strong>先来先服务</strong>」原则。例如：「<code>^.*([0-9]+)</code>」试图匹配 <code>copyright 2003</code> 时，「<code>([0-9]+)</code>」只能匹配到「3」而非「2003」，在该例子中，首先服务「<code>^.*</code>」，使其满足最贪婪的要求，然后才服务「<code>([0-9]+)</code>」。</li></ul><h1 id="表达式主导与文本主导"><a href="#表达式主导与文本主导" class="headerlink" title="表达式主导与文本主导"></a>表达式主导与文本主导</h1><ul><li>DFA：确定型有穷自动机</li><li>NFA：非确定型有穷自动机</li></ul><blockquote><p>NFA 以表达式本身为依据，进行匹配尝试，DFA 以匹配文本为依据，观察子表达式是否匹配成功。</p></blockquote><ul><li>NFA 引擎：表达式主导（regex-directed）——表达式中的控制权在不同的元素之间转换。正则表达式每次检查一部分（由引擎查看表达式的一部分），同时检查“当前文本（current text）”是否匹配表达式的当前部分。如果是，则继续表达式的下一部分，如此继续，直到表达式的所有部分都能匹配，即整个表达式能够匹配成功。</li><li>DFA 引擎：文本主导（text-directed）——在扫描字符串时，会记录“当前有效（currently in the works）”的所有匹配可能。</li><li>DFA引擎在扫描字符串时，会记录“当前有效（currently in the works）”的所有匹配可能。</li><li>DFA 扫描的字符串中的每个字符都对引擎进行了控制。在本例中，某个未完成的匹配也许是任意多个（只要可行）匹配的开始。不合适的匹配可能在扫描后继文字时会被去除。文本中出现的某个字符会令所有处理中的匹配可能失效，就会返回某个之前保留的完整匹配。如果不存在这样的完整匹配，则要报告在当前位置无法匹配。</li></ul><h2 id="NFA-和-DFA-比较"><a href="#NFA-和-DFA-比较" class="headerlink" title="NFA 和 DFA 比较"></a>NFA 和 DFA 比较</h2><ul><li>一般情况下，文本主导的 DFA 引擎要快一些。正则表达式主导的 NFA 引擎，因为需要对同样的文本尝试不同的子表达式匹配，可能会浪费时间。</li><li>在 NFA 的匹配过程中，目标文本中的某个字符可能会被正则表达式中的不同部分重复检测（甚至有可能被同一部分反复检测）。</li><li>DFA 引擎则是确定型的（deterministic）——目标文本中的每个字符只会检查（最多）一遍。</li><li>DFA 引擎会同时记录所有的匹配选择，所以不同表达式最终能够捕获的文本相同，在写法上的差异并无意义，选择哪一个表达式并无区别。</li><li>DFA 匹配很迅速、一致。</li></ul><h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><ul><li>如果正则表达式中余下的部分最终匹配失败，引擎会知道需要<strong>回溯</strong>到之前做出选择的地方，选择其他的备用分支继续尝试。</li><li>回溯仅发生于 NFA 引擎执行匹配时，这是由 NFA 的特性导致——NFA 引擎是表达式主导，在每次扫描文本后都检测是否满足量词和多选结构，如果不满足且无待扫描文本，则会一次又一次「撤销」扫描，取出最近一次满足匹配的结果。这个回滚动作就是「回溯」。</li><li><p>回溯的机制类似于面包屑 / 压栈（LIFO，Last In First Out，后进先出），也可以说面包屑即为压栈存储的一个个<strong>备用状态</strong>。</p><p>举个栗子，用「<code>[0-9+]</code>」来匹配 <code>a 1234 num</code> 的过程中：</p><p><img src="https://i.loli.net/2019/06/21/5d0c38074ab5f56669.png" alt></p><p>锚点从上到下形如面包屑，在匹配失败时回到上一级继续尝试匹配。<br>四个锚点的的状态都会作为保留状态记录下来，依次查看最长的匹配文本，并在匹配失败时一个接一个回溯回来。</p></li><li><p>回溯机制不但需要重新计算正则表达式和文本的对应位置，也需要维护括号内的子表达式所匹配文本的状态。</p></li><li>在匹配过程中，每次回溯都把当前状态中正则表达式的对应位置指向括号之前。</li><li>回溯对括号的这种处理，不但需要同时维护 <code>$1</code> 的状态，也会影响匹配的效率。</li><li>由星号（或其他任何匹配优先量词）限定的部分不受后面元素影响，而只是匹配尽可能多的内容。</li><li>忽略优先的匹配（懒惰）的原因在于，其首先考虑尝试忽略，如「<code>b??</code>」中的懒惰量词「<code>??</code>」会首先<strong>匹配零个</strong>文本 <code>b</code>（注意并不是<strong>不匹配</strong>）</li><li>简单说，懒惰量词就是匹配其能力的下限，比如「<code>b{3,8}?</code>」在匹配 <code>bbbbbbb</code> 时只匹配 3 个 <code>b</code>；「<code>b+?</code>」在匹配 <code>bbbbbbb</code> 时只匹配 1 个 <code>b</code>。</li></ul><h1 id="关于贪婪、懒惰和回溯的要点"><a href="#关于贪婪、懒惰和回溯的要点" class="headerlink" title="关于贪婪、懒惰和回溯的要点"></a>关于贪婪、懒惰和回溯的要点</h1><ul><li><p>由于「<code>*</code>」是贪婪的量词，所以在使用时还需谨慎，不能过分依赖。举个栗子：<br>文本：<code>The name &quot;McDonald&#39;s&quot; is said &quot;makudonarudo&quot; in Japanese.</code></p><ol><li><p>RegEx：<code>&quot;.*&quot;</code><br>结果：<code>&quot;McDonald&#39;s&quot; is said &quot;makudonarudo&quot;</code><br>释义：贪婪量词尽可能多地进行匹配</p></li><li><p>RegEx：<code>&quot;[^&quot;]*&quot;</code><br>结果：<code>&quot;McDonald&#39;s&quot;</code><br>释义：「<code>[^&quot;]</code>」尽可能多地匹配非<code>&quot;</code>的字符，即<code>&quot;</code>前的字母</p></li></ol></li><li><p>善用<strong>懒惰量词</strong>解决成对标签的问题。举个栗子：<br>文本：<code>...&lt;B&gt;Billions&lt;/B&gt; and &lt;B&gt;Zillions&lt;/B&gt; of suns....</code><br>期望：<code>&lt;B&gt;Billions&lt;/B&gt;</code></p><ol><li><p>RegEx：<code>&lt;B&gt;[^&lt;/B&gt;]&lt;/B&gt;</code><br>结果：匹配失败<br>释义：<code>[]</code>是字符范围元字符，无法表达<code>非&lt;/B&gt;</code>的含义，可以使用环视功能进行匹配</p></li><li><p>RegEx：<code>&lt;B&gt;.*?&lt;/B&gt;</code><br>结果：<code>&lt;B&gt;Billions&lt;/B&gt;</code><br>释义：「<code>*?</code>」为懒惰量词，可以尽可能少地匹配文本</p></li></ol></li><li><p>懒惰量词有时在处理成对符号时并不完美。举个栗子：<br>文本：<code>...&lt;B&gt;Billions and &lt;B&gt;Zillions&lt;/B&gt; of suns....</code><br>期望：<code>&lt;B&gt;Zillions&lt;/B&gt;</code></p><ol><li><p>RegEx：<code>&lt;B&gt;.*?&lt;/B&gt;</code><br>结果：<code>&lt;B&gt;Billions and &lt;B&gt;Zillions&lt;/B&gt;</code><br>释义：「<code>.*?</code>」会匹配左边的<code>&lt;B&gt;</code>标签，这是不满足期望的，可以使用<strong>排除环视</strong>功能进行匹配</p></li><li><p>RegEx：<br><img src="https://i.loli.net/2019/07/04/5d1e1c173fa1470167.png" alt><br>结果：<code>&lt;B&gt;Billions&lt;/B&gt;</code></p></li><li><p>RegEx：<br><img src="https://i.loli.net/2019/07/04/5d1e1c6c2cb0387976.png" alt><br>结果：<code>&lt;B&gt;Billions&lt;/B&gt;</code></p></li></ol></li><li><p>有一些问题是贪婪和懒惰都无法解决的问题，举个例子：<br>文本：<code>1.62500000002828</code>，<code>9.43</code>，<code>27.625</code><br>期望：替换过长小数为三位小数 <code>1.625</code>，<code>9.43</code>，<code>27.625</code></p><ol><li><p>RegEx：<code>$prive =~ s/(\.\d\d[1-9]?)\d*/$1/;</code><br>结果：<code>$1 = 1.625</code><br>释义：对于匹配三位小数，此表达式效率还不够高，部分匹配过程存在浪费</p></li><li><p>RegEx：<code>$prive =~ s/(\.\d\d[1-9]?)\d+/$1/;</code><br>结果：<code>$1 = 1.625</code>（正常替换），<code>$1 = 9.43</code> （不替换），<code>$1 = 27.62</code><br>释义：「<code>\.\d\d</code>」匹配了 <code>27.62</code>，「<code>\d+</code>」匹配了 <code>5</code>，「<code>[1-9]?</code>」为可选分支，优先级别比「<code>\d+</code>」低，不进行任何匹配，于是最终导致 <code>27.625</code> 被替换为 <code>27.62</code></p></li></ol></li><li><p>在<strong>只有一条可能的匹配路径时</strong>，使用<em>贪婪</em>和<em>懒惰</em>量词的正则表达式对结果无影响,只是因其尝试路径的次序不同，引擎尝试匹配的次数不同，即<strong>效率不同</strong>。</p></li></ul><h1 id="固化分组"><a href="#固化分组" class="headerlink" title="固化分组"></a>固化分组</h1><ul><li>在固化分组「<code>(?&gt;……)</code>」匹配结束时，它已经匹配的文本已经固化为一个单元，只能作为整体而保留或放弃。回溯永远也不能选择其中的状态。举个例子：「<code>(\.\d\d(?&gt;[1-9]?))\d+</code>」中固化分组「<code>(?&gt;[1-9]?)</code>」使得 <code>.625</code> 末尾的 5 会遭遇 「<code>[1-9]?</code>」的固化匹配，然后再「<code>\d+</code>」需要回溯时匹配失败，从而导致 <code>.625</code> 整个文本匹配失败，从而不被处理，提升执行效率。</li><li>贪婪和懒惰影响检测顺序，固化分组影响备用状态（面包屑）的取舍。</li><li>[<code>(?&gt;.*?)</code>」是一个相当复杂的正则表达式，它永远无法匹配任何字符。「<code>.*?</code>」是「<code>.*</code>」的忽略优先（懒惰）表示，它限定的是一个点号，所以首选的分支是忽略点号，把匹配点号的状态保留下来备用。但该备用状态马上又会因为匹配退出了固化分组而被放弃。</li><li>「<code>^\w+:</code>」无法匹配 <code>Subject</code>，但正则表达式必须从末尾依次向前尝试匹配各种备用状态后才能得出匹配失败的结论。使用固化分组正则表达式「<code>^(?&gt;\w+):</code>」将在尝试「<code>:</code>」匹配失败后直接抛弃固化分组内容「<code>\w+</code>」，即只需尝试 1 次匹配便得出匹配失败结论。<strong>大大提高匹配效率。</strong></li></ul><h1 id="环视"><a href="#环视" class="headerlink" title="环视"></a>环视</h1><ul><li>环视结构的匹配尝试结束，它就不会留下任何备用状态。</li><li>在肯定环视中使用捕获括号，就能模拟实现固化分组和占有优先量词。「<code>(?&gt;regex)</code>」可以用「<code>(?=(regex))\1</code>」来模拟。举个栗子：<ul><li>「<code>(?&gt;\w+):</code>」为固化分组表达式</li><li>「<code>^(?=(\w+))\1:</code>」为环视表达式，环视中的「<code>\w+</code>」是贪婪匹配的，匹配整个单词。当环视结束之后，备用状态都会被放弃(和固化分组一样)。但与固化分组不同：虽然此时捕获了单词，但它不是全局匹配的一部分。「<code>\1</code>」的使用是为了把匹配从这个单词结束的位置进行下去。</li></ul></li></ul><h1 id="多选结构"><a href="#多选结构" class="headerlink" title="多选结构"></a>多选结构</h1><ul><li>对 NFA 来说，多选结构既<strong>不是匹配优先的</strong>，也<strong>不是忽略优先的</strong>，而是<strong>按顺序排列</strong>的。</li><li>对 DFA 来说，多选结构匹配所有多选分支中能匹配最多文本的那个。</li><li>如果多选分支是<strong>按顺序排列</strong>的。，而能够匹配同样文本的多选分支又<strong>不只一个</strong>，就要小心安排多选分支的<strong>先后顺序</strong>。</li></ul><p>文本：<code>Jan 31 is Dad&#39;s birthday</code><br>期望：<code>Jan 31</code></p><ol><li><p>RegEx：<code>Jan (0?[1-9]|[12][0-9]|3[01])</code><br>结果：<code>Jan 3</code><br>释义：「<code>0?</code>」不会匹配成功，但后续的「<code>[0-9]</code>」会匹配 <code>3</code>，此时完成所有匹配需求，故匹配成功。</p></li><li><p>RegEx：<code>Jan ([12][0-9]|3[01]|0?[1-9])</code><br>RegEx：<code>Jan (31|[123]0|[012?[1-9]])</code><br>结果：<code>Jan 31</code><br>释义：上述两个 RegeEx 的多选结构顺序保证了匹配的内容与期望相符</p></li><li><p>RegEx：<code>Jan (0[1-9]|[12][0-9]?|3[01]?|[4-9])</code><br>结果：<code>Jan 31</code><br>释义：上述多选结构不受内部多选分支的顺序影响，均可匹配成功</p></li></ol><h1 id="NFA、DFA-和-POSIX"><a href="#NFA、DFA-和-POSIX" class="headerlink" title="NFA、DFA 和 POSIX"></a>NFA、DFA 和 POSIX</h1><p>NFA 和 DFA 引擎理应匹配相同文本，提供相同功能。但在实际中，因为人们需要更强的功能，更具表达能力的正则表达式，它们各自的表达式语意（解析方式）发生了变化。</p><h2 id="最左最长规则"><a href="#最左最长规则" class="headerlink" title="最左最长规则"></a>最左最长规则</h2><ul><li>如果传动装置在文本的某个特定位置启动 DFA 引擎，而在此位置又有一个或多个匹配的可能，DFA 就会选择这些可能中最长的。</li><li>POSIX 标准规定，如果在字符串的某个位置存在多个可能的匹配，应当返回的是最长的匹配。</li></ul><h2 id="速度和效率"><a href="#速度和效率" class="headerlink" title="速度和效率"></a>速度和效率</h2><ul><li>POSIX NFA 需要进行更多的回溯，尝试正则表达式的所有变体。所以表达式的差异会极大影响其匹配的效率。</li><li>DFA 引擎用更多时间和空间来换取匹配效率。</li></ul><table><thead><tr><th></th><th>DFA</th><th>NFA</th></tr></thead><tbody><tr><td>预编译阶段</td><td>优化措施的效果更好</td><td>编译更快，所需内存更少</td></tr><tr><td>匹配速度</td><td>与表达式无关</td><td>与表达式有关</td></tr><tr><td>匹配速度</td><td></td><td>NFA 尝试表达式的所有变体后才报告匹配失败，POSIX NFA 尝试匹配最长文本</td></tr><tr><td>匹配结果</td><td>返回最左最长文本</td><td>NFA 返回最左最长文本 / 其他文本</td></tr><tr><td>匹配能力</td><td></td><td>1. 支持捕获括号内的子表达式的文本（eg. 反向引用 / 后匹配信息）</td></tr><tr><td>匹配能力</td><td></td><td>2. 支持环视和其他零长度确认</td></tr><tr><td>匹配能力</td><td></td><td>3. 支持懒惰量词和多选结构</td></tr><tr><td>匹配能力</td><td></td><td>4. 支持贪婪量词和固化分子</td></tr><tr><td>实现难度</td><td></td><td>实现简单</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-1/&quot;&gt;《精通正则表达式》学习笔记（一）&lt;/a&gt;&lt;br&gt;Ch.1 正则表达式入门&lt;br&gt;Ch.2 入门示例拓展&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-2/&quot;&gt;《精通正则表达式》学习笔记（二）&lt;/a&gt;&lt;br&gt;Ch.3 正则表达式的特性和流派概览&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-3/&quot;&gt;《精通正则表达式》学习笔记（三）&lt;/a&gt;&lt;br&gt;Ch.4 表达式的匹配原理&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-4/&quot;&gt;《精通正则表达式》学习笔记（四）&lt;/a&gt;&lt;br&gt;Ch.5 正则表达式实用技巧&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-5/&quot;&gt;《精通正则表达式》学习笔记（五）&lt;/a&gt;&lt;br&gt;Ch.6 打造高效正则表达式&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-6/&quot;&gt;《精通正则表达式》学习笔记（六）&lt;/a&gt;&lt;br&gt;Ch.10 PHP 相关的正则表达式&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&quot;正则引擎的分类&quot;&gt;&lt;a href=&quot;#正则引擎的分类&quot; class=&quot;headerlink&quot; title=&quot;正则引擎的分类&quot;&gt;&lt;/a&gt;正则引擎的分类&lt;/h1&gt;&lt;p&gt;正则引擎主要分为 3 类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DFA（符合或不符合 POSIX 标准的都属此类）&lt;/li&gt;
&lt;li&gt;传统型 NFA&lt;/li&gt;
&lt;li&gt;POSIX NFA&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;引擎类型&lt;/th&gt;
&lt;th&gt;程序&lt;/th&gt;
&lt;th&gt;忽略优先量词（懒惰）&lt;/th&gt;
&lt;th&gt;捕获型括号&lt;/th&gt;
&lt;th&gt;回溯&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;DFA&lt;/td&gt;
&lt;td&gt;&lt;code&gt;awk&lt;/code&gt;（大多数版本）、&lt;code&gt;egrep&lt;/code&gt;（大多数版本）、&lt;code&gt;flex&lt;/code&gt;、&lt;code&gt;lex&lt;/code&gt;、MySQL、Procmail&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;传统型 NFA&lt;/td&gt;
&lt;td&gt;GNU Emacs、Java、&lt;code&gt;grep&lt;/code&gt;（大多数版本）、&lt;code&gt;less&lt;/code&gt;、&lt;code&gt;more&lt;/code&gt;、.NET 语言、PCRE library、Perl、PHP（所有三套正则库）、Python、Ruby、sed（大多数版本）、&lt;code&gt;vi&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持，但性能差&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;POSIX NFA&lt;/td&gt;
&lt;td&gt;&lt;code&gt;mawk&lt;/code&gt;、Mortice Kern Systems’utilities、GNU Emacs（明确指定时使用）&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持，但性能差&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DFA/NFA 混合&lt;/td&gt;
&lt;td&gt;GNU &lt;code&gt;awk&lt;/code&gt;、GNU &lt;code&gt;grep/egrep&lt;/code&gt;、Tcl&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;DFA 支持&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;判断是否传统型 NFA：是否支持忽略优先量词（懒惰）。使用正则表达式 &lt;code&gt;nfa|nfa not&lt;/code&gt; 来匹配字符串 &lt;code&gt;nfa not&lt;/code&gt;，如果只匹配了 &lt;code&gt;nfa&lt;/code&gt;，这就是传统型 NFA。如果整个 &lt;code&gt;nfa not&lt;/code&gt; 都能匹配，则此引擎要么是 POSIXNFA，要么是 DFA。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://acuario.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="RegEx" scheme="https://acuario.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/RegEx/"/>
    
    
      <category term="学习笔记" scheme="https://acuario.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="精通正则表达式" scheme="https://acuario.xyz/tags/%E7%B2%BE%E9%80%9A%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="RegEx" scheme="https://acuario.xyz/tags/RegEx/"/>
    
      <category term="正则引擎" scheme="https://acuario.xyz/tags/%E6%AD%A3%E5%88%99%E5%BC%95%E6%93%8E/"/>
    
      <category term="NFA" scheme="https://acuario.xyz/tags/NFA/"/>
    
      <category term="DFA" scheme="https://acuario.xyz/tags/DFA/"/>
    
      <category term="POSIX NFA" scheme="https://acuario.xyz/tags/POSIX-NFA/"/>
    
  </entry>
  
  <entry>
    <title>播客札记（三）：剧透&amp;外卖</title>
    <link href="https://acuario.xyz/podcast-note-3/"/>
    <id>https://acuario.xyz/podcast-note-3/</id>
    <published>2019-06-07T05:04:59.000Z</published>
    <updated>2019-09-15T17:29:09.314Z</updated>
    
    <content type="html"><![CDATA[<h1 id="八分-第-80-期-剧透的思考练习：言论自由还是道德错误？"><a href="#八分-第-80-期-剧透的思考练习：言论自由还是道德错误？" class="headerlink" title="八分 第 80 期 | 剧透的思考练习：言论自由还是道德错误？"></a>八分 第 80 期 | 剧透的思考练习：言论自由还是道德错误？</h1><p><a href="https://overcast.fm/+Oh0W-o4Pc" target="_blank" rel="noopener">Episode Archive</a></p><ul><li>剧透的伦理学基础：功利主义（效用主义）。</li><li>功利主义含义：所谓最大善的计算则必须依靠此行为所涉及的每个个体之苦乐感觉的总和，其中每个个体都被视为具相同分量，且快乐与痛苦是能够换算的，痛苦仅是 “负的快乐”。判断一件事的好坏，依据就是其是否增进人类最大的善，即增加人类的总体快乐。</li><li>剧透带来的双成伤害：<ol><li>剧透减少了观影的悬疑性，破坏了观影过程的乐趣；</li><li>剧透破坏了观影前对影视作品的期待与喜悦。</li></ol></li><li>剧透的言论自由基础：卡尔·波普尔在《开放社会及其敌人》中提出的「宽容悖论」。</li><li><p>宽容悖论：</p><blockquote><p>无限的宽容必然导致宽容的消失。如果我们把无限的宽容延伸到那些不宽容的人身上，如果我们不准备捍卫宽容社会以抵抗不宽容的冲击，那么宽容将被摧毁，并且我们还将容忍他们。</p></blockquote></li><li><p>穆勒认为，除非某个人的言论或行为伤害（肉体或利益受损）而非冒犯（情绪、尊严受损）到一个人，否则其言论或行为不应被任何力量禁止。</p></li><li>剧透是否是对肉体和精神的真实伤害？还是仅仅只是一种冒犯？</li><li>剧透与权利的关系：如果剧透者是创作者本人，其是否有权剧透？这一剧透行为是否有合理性？</li><li>剧透与历史的关系：历史作品是否可以剧透？</li><li>真正伟大的作品不惧怕剧透。类型文学 / 作品是不可被剧透的。</li><li>剧透的另一种观赏乐趣：心平气和地感受作品的细节。</li><li>互联网的出现为剧透文化带来的改变：电影预告片即是对剧透文化的利用。</li><li>希区柯克的《惊魂记》告诫观众请勿剧透，助长了影片本身的神秘性。</li></ul><a id="more"></a><hr><h1 id="翻电-Special-VOL02-如何看待外卖行业和我们的责任？"><a href="#翻电-Special-VOL02-如何看待外卖行业和我们的责任？" class="headerlink" title="翻电 Special VOL02 | 如何看待外卖行业和我们的责任？"></a>翻电 Special VOL02 | 如何看待外卖行业和我们的责任？</h1><p><a href="https://overcast.fm/+GsFhie5AY" target="_blank" rel="noopener">Episode Archive</a></p><h2 id="劳动异化理论"><a href="#劳动异化理论" class="headerlink" title="劳动异化理论"></a>劳动异化理论</h2><ul><li>劳动者是否掌握生产资料</li><li>如果劳动者被劳动以外的要素强迫，且劳动目的不属于自己、劳动对象不是自己，则该劳动过程将出现劳动异化</li></ul><h2 id="外卖工作为何是劳动异化的极端"><a href="#外卖工作为何是劳动异化的极端" class="headerlink" title="外卖工作为何是劳动异化的极端"></a>外卖工作为何是劳动异化的极端</h2><p>现代社会普遍存在劳动异化，外卖是劳动异化的极端例子：</p><ol><li>外卖的工作空间为社会飞地，工作时没有任何主要（固定）的社会空间，完全游离于世界之外；</li><li>外卖者对外交流的对象并不固定，且人际交流时间非常短暂。相比之下，出租车司机与乘客也有相对长时间的共处；</li><li>外卖工作不掌握任何生产资料，在社会生产链条中一无所有，没有任何生产实践。相比之下，风投工作亦是如此；</li><li>外卖工作不具备任何工作经验、技能的积累，纵使有产生了经验、技能，也很难复用到其他工作。</li></ol><h2 id="为何作为一个工作，外卖依然有伦理风险"><a href="#为何作为一个工作，外卖依然有伦理风险" class="headerlink" title="为何作为一个工作，外卖依然有伦理风险"></a>为何作为一个工作，外卖依然有伦理风险</h2><ul><li>社会底线不是维持社会成为一个好社会的标准，而是维持社会不崩溃的标准</li><li>外卖工作虽没有触及社会底线，但却是劳动异化最极端的状态。</li><li>「谁雇佣谁负责 / 谁施行谁负责」是缺乏说服力的，由自我需求产生的特定现实需要需求方承担社会责任。反例为儿童色情 / 毒品问题。</li></ul><h2 id="为何我们不是雇佣者也应该关注外卖"><a href="#为何我们不是雇佣者也应该关注外卖" class="headerlink" title="为何我们不是雇佣者也应该关注外卖"></a>为何我们不是雇佣者也应该关注外卖</h2><ul><li>外卖需求建立在手机、互联网之上。消费者为了避免与人交流，产生了这样「过度的」需求，这样的需求是商品社会「方便主义」至上的后果，它把心理负担和成本转嫁到外卖者身上。没有买卖就没有伤害。</li><li>大众具有选择性的同理心。体谅和同理心的适用对象不应只限于特殊岗位，如公权力赋权的对象，比如消防员。</li><li>同理心的对象不应以利益绑定为标准。仅对利益共同体给与同理心是功利主义的，若长此以往，互助互利的社会风气将会逐渐消解。</li><li>由于存在实然和应然的问题，带着负罪感的作为至少比毫不反思和理解要好，尝试理解外卖工作的特殊性和其中存在的道德风险，胜过以方便主义理所应当享用外卖服务。</li></ul><h2 id="问题反思"><a href="#问题反思" class="headerlink" title="问题反思"></a>问题反思</h2><p>主要的问题在于：</p><ol><li>要在多大程度上对马克思经济学的基本概念进行外延？</li><li>导致事情极端，不是一个因素的决定，而是多个因素的共同作用</li><li>劳动异化简而言之是：站在人的自身发展、自我意志的角度，来看待人与工作的关系。异化程度越高，对人本身的发展越不利。其他方面按下不表，因为前述论点足够进行话题讨论。</li></ol><p>反思结论如下：</p><ol><li>劳动异化这个概念，是对资本主义框架的一种解释。在讨论成熟的商业行为时，我们不妨先用该理论作为基础进行分析，当然也可以有其他理论的探讨。</li><li>现代性中很重要的一点就是时间和空间的概念与古时不同，城市的出现本就是一个以空间作为明显标志的产物。所以工作空间的固定对劳动者本身的劳动异化是有弱化作用的，这一点对城市内的从业者更加明显。</li><li>工作的技能经验在此可以理解为对某一工作本身熟悉度的掌握，对外卖行业而言这一点无从谈起。更加熟悉路况、地形，然后应用到出租车行业？除此之外的积累又有几多？出租车行业本身在其他几点上的情况也极其糟糕，劳动异化程度也不低。</li><li>对前述论点举特例无非是五十步笑一百步，劳动异化是多因素的共同作用，而非某一单一因素，恰恰只有外卖行业在前述劳动异化的极端性 (1)(2)(3)(4) 点上均有涉及，且程度不小，所以才可以讨论其职业道德风险的问题。而其他例子总能因某一因素的缺失而削弱其劳动异化程度。比如程序员寡言、风投行业不掌握生产资料，但其获得的回报（物质、心理、社会层面）在一定程度上能够弥补劳动异化带来的损失（物质 &amp; 精神层面）。</li><li>「方便无罪」让我想到「技术无罪」论，手机和互联网的出现在社会层面的积极作用当然不用多说，但如果基于功利主义来讨论「外卖是否更利于人与人的交流」的话，笔者认为答案是否定的。而且笔者也不认为「方便」在多大程度上促进了外卖从业者自我人格的发展。倒是在消费者口中助长了工具理性的态度。我们现在反对和反思的不恰恰就是工具理性的消费主义吗？</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;八分-第-80-期-剧透的思考练习：言论自由还是道德错误？&quot;&gt;&lt;a href=&quot;#八分-第-80-期-剧透的思考练习：言论自由还是道德错误？&quot; class=&quot;headerlink&quot; title=&quot;八分 第 80 期 | 剧透的思考练习：言论自由还是道德错误？&quot;&gt;&lt;/a&gt;八分 第 80 期 | 剧透的思考练习：言论自由还是道德错误？&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://overcast.fm/+Oh0W-o4Pc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Episode Archive&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;剧透的伦理学基础：功利主义（效用主义）。&lt;/li&gt;
&lt;li&gt;功利主义含义：所谓最大善的计算则必须依靠此行为所涉及的每个个体之苦乐感觉的总和，其中每个个体都被视为具相同分量，且快乐与痛苦是能够换算的，痛苦仅是 “负的快乐”。判断一件事的好坏，依据就是其是否增进人类最大的善，即增加人类的总体快乐。&lt;/li&gt;
&lt;li&gt;剧透带来的双成伤害：&lt;ol&gt;
&lt;li&gt;剧透减少了观影的悬疑性，破坏了观影过程的乐趣；&lt;/li&gt;
&lt;li&gt;剧透破坏了观影前对影视作品的期待与喜悦。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;剧透的言论自由基础：卡尔·波普尔在《开放社会及其敌人》中提出的「宽容悖论」。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;宽容悖论：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;无限的宽容必然导致宽容的消失。如果我们把无限的宽容延伸到那些不宽容的人身上，如果我们不准备捍卫宽容社会以抵抗不宽容的冲击，那么宽容将被摧毁，并且我们还将容忍他们。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;穆勒认为，除非某个人的言论或行为伤害（肉体或利益受损）而非冒犯（情绪、尊严受损）到一个人，否则其言论或行为不应被任何力量禁止。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;剧透是否是对肉体和精神的真实伤害？还是仅仅只是一种冒犯？&lt;/li&gt;
&lt;li&gt;剧透与权利的关系：如果剧透者是创作者本人，其是否有权剧透？这一剧透行为是否有合理性？&lt;/li&gt;
&lt;li&gt;剧透与历史的关系：历史作品是否可以剧透？&lt;/li&gt;
&lt;li&gt;真正伟大的作品不惧怕剧透。类型文学 / 作品是不可被剧透的。&lt;/li&gt;
&lt;li&gt;剧透的另一种观赏乐趣：心平气和地感受作品的细节。&lt;/li&gt;
&lt;li&gt;互联网的出现为剧透文化带来的改变：电影预告片即是对剧透文化的利用。&lt;/li&gt;
&lt;li&gt;希区柯克的《惊魂记》告诫观众请勿剧透，助长了影片本身的神秘性。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="播客札记" scheme="https://acuario.xyz/categories/%E6%92%AD%E5%AE%A2%E6%9C%AD%E8%AE%B0/"/>
    
    
      <category term="Podcast" scheme="https://acuario.xyz/tags/Podcast/"/>
    
      <category term="播客" scheme="https://acuario.xyz/tags/%E6%92%AD%E5%AE%A2/"/>
    
      <category term="翻转电台" scheme="https://acuario.xyz/tags/%E7%BF%BB%E8%BD%AC%E7%94%B5%E5%8F%B0/"/>
    
      <category term="剧透" scheme="https://acuario.xyz/tags/%E5%89%A7%E9%80%8F/"/>
    
      <category term="言论自由" scheme="https://acuario.xyz/tags/%E8%A8%80%E8%AE%BA%E8%87%AA%E7%94%B1/"/>
    
      <category term="外卖" scheme="https://acuario.xyz/tags/%E5%A4%96%E5%8D%96/"/>
    
      <category term="功利主义" scheme="https://acuario.xyz/tags/%E5%8A%9F%E5%88%A9%E4%B8%BB%E4%B9%89/"/>
    
      <category term="劳动异化" scheme="https://acuario.xyz/tags/%E5%8A%B3%E5%8A%A8%E5%BC%82%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>《精通正则表达式》学习笔记（二）</title>
    <link href="https://acuario.xyz/mastering-regex-summary-2/"/>
    <id>https://acuario.xyz/mastering-regex-summary-2/</id>
    <published>2019-06-05T13:35:55.000Z</published>
    <updated>2019-08-11T15:24:03.854Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="/mastering-regex-summary-1/">《精通正则表达式》学习笔记（一）</a><br>Ch.1 正则表达式入门<br>Ch.2 入门示例拓展</li><li><a href="/mastering-regex-summary-2/">《精通正则表达式》学习笔记（二）</a><br>Ch.3 正则表达式的特性和流派概览</li><li><a href="/mastering-regex-summary-3/">《精通正则表达式》学习笔记（三）</a><br>Ch.4 表达式的匹配原理</li><li><a href="/mastering-regex-summary-4/">《精通正则表达式》学习笔记（四）</a><br>Ch.5 正则表达式实用技巧</li><li><a href="/mastering-regex-summary-5/">《精通正则表达式》学习笔记（五）</a><br>Ch.6 打造高效正则表达式</li><li><a href="/mastering-regex-summary-6/">《精通正则表达式》学习笔记（六）</a><br>Ch.10 PHP 相关的正则表达式</li></ul><hr><h1 id="正则表达式的发展历程"><a href="#正则表达式的发展历程" class="headerlink" title="正则表达式的发展历程"></a>正则表达式的发展历程</h1><ul><li><p>1968 年 Ken Thompson 的文章 Regular Expression Search Algorithm 描述了一种正则表达式编译器，该编译器生成了 IBM7094 的 object 代码。由此也诞生了他的 <code>qed</code>，这种编辑器后来成了 Unix 中 <code>ed</code> 编辑器的基础。</p></li><li><p><code>ed</code> 有条命令 <code>g/Regular Expression/p</code>，读作 <em>Gjobal Regular Expression，Print</em>（应用正则表达式的全局输出）。这个功能最终成为独立的工具 <code>grep</code>，之后又产生了 <code>egrep</code>(Extended grep)。</p><ul><li>POSIX（Portable Operating System Interface，可移植操作系统接口）诞生于 1986 年，它是一系列标准，确保操作系统之间的移植性。POSIX 把各种常见的流派分为两大类：<br>Basic Regular Expressions（BREs）和 Extended Regular Expressions（EREs）。POSIX 程序必须支持其中的任意一种。</li></ul></li></ul><p><img src="https://i.loli.net/2019/05/30/5cef9d6eddef290952.png" alt="POSIX 正则表达式流派"></p><ul><li><p>Perl 的特性中值得一提的是，它提供了传统上只有专用工具 <code>sed</code> 和 <code>awk</code> 才提供的正则表达式操作符——这在通用脚本语言中是个首创。正则引擎的代码来自一个早期的项目——Larry 的新闻阅读器 <code>rn</code>（其中的正则表达式代码来自 James Gosling 的 <code>Emacs</code>。（James Gosling 后来去开发他自己的语言 <code>Java</code>，Java 1.4 提供了一个标准的正则表达式包。）</p></li><li><p>1997 年 Philip Hazel 开发了 <code>PCRE</code>，这是一套兼容 Perl 正则表达式的库，全面仿制 Perl 的正则表达式的语法和语义。其他的开发人员可以把 PCRE 整合到自己的工具和语言中，许多流行的软件都使用了 PCRE，例如 <code>PHP</code>、<code>Apache 2</code>、<code>Exim</code>、<code>Postfix</code> 和 <code>Nmap</code>。</p><a id="more"></a></li></ul><h1 id="正则表达式的注意事项和处理方法"><a href="#正则表达式的注意事项和处理方法" class="headerlink" title="正则表达式的注意事项和处理方法"></a>正则表达式的注意事项和处理方法</h1><p><img src="https://i.loli.net/2019/06/03/5cf503b6304ca16665.png" alt="若干常用工具的 Flavor 的简要考察"></p><ul><li><p>一款工具软件能够利用正则表达式实现的功能，通常比它所属的正则流派更重要。</p></li><li><p>程序设计语言有 3 种处理正则表达式的方式：</p><ol><li>集成式（integrated）：直接内建在语言之中，如 Perl。</li><li>程序式（procedural）</li><li>面向对象式（object-oriented）</li></ol><ul><li>程序式和面向对象式，是由普通的函数接收普通的字符串，把它们作为正则表达式进行处理。由不同的函数进行不同的、关系到一个或多个正则表达式的操作。</li></ul></li></ul><h1 id="字符串、字符编码和匹配模式"><a href="#字符串、字符编码和匹配模式" class="headerlink" title="字符串、字符编码和匹配模式"></a>字符串、字符编码和匹配模式</h1><ul><li><p><code>Unicode</code> 是一组字符设定，或者是从数字和字符之间的逻辑映射的<strong>概念编码</strong>。一个 “代码点（code point）”，通常用十六进制来表示，以 “<code>U+</code>” 开头。</p></li><li><p>支持 Unicode 的程序中的正则表达式通常支持 <code>\unum</code> 元序列，用来匹配一个具体的 Unicode 字符。</p></li><li><p>Unicode Version 3.1 诞生于 2001 年中期，增加了 <code>u+FFFF</code> 之后的代码点。例如，代表音乐谱号 <code>C</code>（Clef）的字符对应代码点 <code>U+1D121</code>。之前那些仅支持低于 <code>U+FPPP</code> 字符的程序无法处理这种情况。大多数程序的 <code>\unum</code> 只能支持最多 4 位十六进制数值。</p></li><li><p>能够处理这类新字符的程序通常提供了 <code>\x{nuwm}</code> 序列，<code>num</code> 可以为任意多位数字（这是为了增强只支持 4 位数字的 <code>\unum</code> 表示法）。你可以使用 <code>\x{1D121}</code> 来匹配这类 “谱号 <code>C</code>” 之类的字符。</p></li><li><p>正则模式和匹配模式</p><ul><li>不区分大小写的匹配模式：在匹配过程中会忽略字母的大小写。</li><li>宽松排列和注释模式：忽略字符组外部的所有空白字符。字符组内部的空白字符仍然有效，<code>#</code> 符号和换行符之间的内容视为注释。</li><li>点号通配模式（dot-match-all match mode，也叫 single-line mode “单行模式 “）：点号不受限制，可以匹配任何字符，包括换行符。修改了点号处理换行符的方式，从 “需要特殊处理” 变为 “不需要特殊处理”</li><li>增强的行锚点模式（Enhanced line-anchor match mode，也叫 “多行文本模式 “）：「<code>^</code>」能够匹配字符串中内嵌的文本行的开头位置，「<code>$</code>」能够匹配字符串中内嵌的文本行的换行符。改变了「<code>^</code>」和「<code>$</code>」匹配换行符的方式，从 “不需要特殊处理” 变为 “需要特殊处理”。</li><li>文字文本模式：几乎不识别任何正则表达式元字符。</li></ul></li></ul><h1 id="常用的元字符和特性"><a href="#常用的元字符和特性" class="headerlink" title="常用的元字符和特性"></a>常用的元字符和特性</h1><ul><li><p>字符表示法</p><ul><li>字符缩略表示法：<code>\n</code>、<code>\t</code>、<code>\a</code>、<code>\b</code>、<code>\e</code>、<code>\f</code>、<code>\r</code>、<code>\v</code>…</li><li>八进制转义：<code>\num</code></li><li>十六进制 /Unicode 转义：<code>\xnum</code>、<code>\x{num}</code>、<code>\unum</code>、<code>\Unum</code>…</li><li>控制字符：<code>\cchar</code></li></ul></li><li><p>字符组及相关结构</p><ul><li>普通字符组：<code>[a-z]</code> 和 <code>[*a-z]</code></li><li>几乎能匹配任何字符的元字符：点号</li><li>单个字节：<code>\C</code></li><li>Unicode 组合字符序列：<code>\X</code></li><li>字符组缩略表示法：<code>\w</code>、<code>\d</code>、<code>\s</code>、<code>\W</code>、<code>\D</code>、<code>\S</code></li><li>Unicode 属性、区块和分类：<code>\p{Prop}</code>、<code>\P{Prop}</code></li><li>字符组运算符：<code>[[a-z]&amp;&amp;[^aeiou]]</code></li></ul></li><li><p>锚点及其他 “零长度断言”</p><ul><li>行 / 字符串起点：<code>^</code>、<code>\A</code></li><li>行 / 字符串终点：<code>$</code>、<code>\Z</code>、<code>\z</code></li><li>本次匹配的开始位置（或者上次匹配的结束位置）：<code>\G</code></li><li>单词分界符：<code>\b</code>、<code>\B</code>、<code>\&lt;</code>、<code>\&gt;</code>…</li><li>顺序环视 <code>(?=…)</code>、<code>(?!…)</code>；</li><li>逆序环视 <code>(?&lt;=…)</code>、<code>(?&lt;!…)</code></li></ul></li><li><p>注释和模式修饰词</p><ul><li>模式修饰词：<code>(?modifier)</code>，例如 <code>(?i)</code> 或 <code>(?-i)</code></li><li>模式作用范围：<code>(?modifier:…)</code>，例如 <code>(?i:…)</code></li><li>注释：<code>(?#…)</code> 和 <code>#…</code></li><li>文字文本范围：<code>\Q…\E</code></li></ul></li><li><p>分组，捕获，条件判断和控制：</p><ul><li>捕获 / 分组括号：<code>(…)</code>、<code>\1</code>、<code>\2</code>，…</li><li>仅用于分组的括号：<code>(?:…)</code></li><li>命名捕获：<code>(?&lt;Name&gt;…)</code></li><li>固化分组：<code>(?&gt;…)</code> 永远也不会 “交还” 分组内已经匹配的任何内容。</li><li>多选结构：<code>…|…|…</code></li><li>条件判断：<code>(?if then|else)</code></li><li>匹配优先量词：<code>*</code>、<code>+</code>、<code>?</code>、<code>{num，num}</code> 贪心（greedy）模式，<strong>默认的</strong>量词匹配模式，匹配尽可能多的内容。</li><li>忽略优先量词：<code>*?</code>、<code>+?</code>、<code>??</code>、<code>{num，num)?</code> 懒惰模式，匹配尽可能少的内容，只需要满足下限，匹配就能成功。</li><li>占有优先量词：<code>*+</code>、<code>++</code>、<code>?+</code>、<code>{nuwm，nuwm}+</code> 类似固化分组，一旦匹配某些内容，就不会“交还”。</li></ul></li><li><p>固化分组就是一个<strong>只进不出</strong>的栈，被匹配入栈的内容不会交还，这导致若匹配了更多无关内容，将导致匹配失败（因为之前的匹配无法交还），最终的匹配结果将为空。例如：<code>!.+!</code> 可以匹配 <code>!Hola!</code>，但 <code>!(?&gt;.+)!</code> 无法匹配 <code>!Hola!</code>。其首先匹配尽可能多的内容 <code>Hola!</code>，但是之后的 <code>!</code> 无法匹配，会强迫 <code>.+</code> 释放之前匹配的 <code>!</code>，但固化分组无法释放，最终导致匹配失败。</p></li><li><p>所有的正则引擎都不会对单词进行语意分析：它们认为 “NE14AD8” 是一个单词，而 “M.I.T.” 不是。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-1/&quot;&gt;《精通正则表达式》学习笔记（一）&lt;/a&gt;&lt;br&gt;Ch.1 正则表达式入门&lt;br&gt;Ch.2 入门示例拓展&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-2/&quot;&gt;《精通正则表达式》学习笔记（二）&lt;/a&gt;&lt;br&gt;Ch.3 正则表达式的特性和流派概览&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-3/&quot;&gt;《精通正则表达式》学习笔记（三）&lt;/a&gt;&lt;br&gt;Ch.4 表达式的匹配原理&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-4/&quot;&gt;《精通正则表达式》学习笔记（四）&lt;/a&gt;&lt;br&gt;Ch.5 正则表达式实用技巧&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-5/&quot;&gt;《精通正则表达式》学习笔记（五）&lt;/a&gt;&lt;br&gt;Ch.6 打造高效正则表达式&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/mastering-regex-summary-6/&quot;&gt;《精通正则表达式》学习笔记（六）&lt;/a&gt;&lt;br&gt;Ch.10 PHP 相关的正则表达式&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&quot;正则表达式的发展历程&quot;&gt;&lt;a href=&quot;#正则表达式的发展历程&quot; class=&quot;headerlink&quot; title=&quot;正则表达式的发展历程&quot;&gt;&lt;/a&gt;正则表达式的发展历程&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1968 年 Ken Thompson 的文章 Regular Expression Search Algorithm 描述了一种正则表达式编译器，该编译器生成了 IBM7094 的 object 代码。由此也诞生了他的 &lt;code&gt;qed&lt;/code&gt;，这种编辑器后来成了 Unix 中 &lt;code&gt;ed&lt;/code&gt; 编辑器的基础。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;ed&lt;/code&gt; 有条命令 &lt;code&gt;g/Regular Expression/p&lt;/code&gt;，读作 &lt;em&gt;Gjobal Regular Expression，Print&lt;/em&gt;（应用正则表达式的全局输出）。这个功能最终成为独立的工具 &lt;code&gt;grep&lt;/code&gt;，之后又产生了 &lt;code&gt;egrep&lt;/code&gt;(Extended grep)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;POSIX（Portable Operating System Interface，可移植操作系统接口）诞生于 1986 年，它是一系列标准，确保操作系统之间的移植性。POSIX 把各种常见的流派分为两大类：&lt;br&gt;Basic Regular Expressions（BREs）和 Extended Regular Expressions（EREs）。POSIX 程序必须支持其中的任意一种。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/05/30/5cef9d6eddef290952.png&quot; alt=&quot;POSIX 正则表达式流派&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Perl 的特性中值得一提的是，它提供了传统上只有专用工具 &lt;code&gt;sed&lt;/code&gt; 和 &lt;code&gt;awk&lt;/code&gt; 才提供的正则表达式操作符——这在通用脚本语言中是个首创。正则引擎的代码来自一个早期的项目——Larry 的新闻阅读器 &lt;code&gt;rn&lt;/code&gt;（其中的正则表达式代码来自 James Gosling 的 &lt;code&gt;Emacs&lt;/code&gt;。（James Gosling 后来去开发他自己的语言 &lt;code&gt;Java&lt;/code&gt;，Java 1.4 提供了一个标准的正则表达式包。）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;1997 年 Philip Hazel 开发了 &lt;code&gt;PCRE&lt;/code&gt;，这是一套兼容 Perl 正则表达式的库，全面仿制 Perl 的正则表达式的语法和语义。其他的开发人员可以把 PCRE 整合到自己的工具和语言中，许多流行的软件都使用了 PCRE，例如 &lt;code&gt;PHP&lt;/code&gt;、&lt;code&gt;Apache 2&lt;/code&gt;、&lt;code&gt;Exim&lt;/code&gt;、&lt;code&gt;Postfix&lt;/code&gt; 和 &lt;code&gt;Nmap&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://acuario.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="RegEx" scheme="https://acuario.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/RegEx/"/>
    
    
      <category term="学习笔记" scheme="https://acuario.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="精通正则表达式" scheme="https://acuario.xyz/tags/%E7%B2%BE%E9%80%9A%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="RegEx" scheme="https://acuario.xyz/tags/RegEx/"/>
    
      <category term="正则流派" scheme="https://acuario.xyz/tags/%E6%AD%A3%E5%88%99%E6%B5%81%E6%B4%BE/"/>
    
      <category term="正则特性" scheme="https://acuario.xyz/tags/%E6%AD%A3%E5%88%99%E7%89%B9%E6%80%A7/"/>
    
      <category term="正则元字符" scheme="https://acuario.xyz/tags/%E6%AD%A3%E5%88%99%E5%85%83%E5%AD%97%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>如何加固Linux服务器[译]</title>
    <link href="https://acuario.xyz/how-to-secure-your-linux-server/"/>
    <id>https://acuario.xyz/how-to-secure-your-linux-server/</id>
    <published>2019-04-27T08:54:32.000Z</published>
    <updated>2019-04-29T14:53:29.810Z</updated>
    
    <content type="html"><![CDATA[<p><em>原文 <a href="https://medium.com/servers-101/how-to-secure-your-linux-server-6026cfcdefd8" target="_blank" rel="noopener">How To Secure Your Linux Server In 7 Easy Steps</a> 由 <a href="https://medium.com/@mutendebrian" target="_blank" rel="noopener">Brian Mutende</a> 发布于 Medium，翻译转载已获作者允许。<br>为配合博客目录系统显示，对原文章节名略有修改。</em></p><hr><p>大多数服务器经常会被黑客攻击。所以我决定写一篇简短的教程，让读者轻松加固自己的 Linux 服务器。</p><p>这并不是一篇完整的安全指南，但是它可以帮你阻断近九成常见的后端攻击，例如<strong>暴力破解</strong>和 <strong>DDoS</strong>。</p><p>最棒的是，你可以在一两个小时内就完成操作。</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ol><li>你需要一台Linux服务器。</li><li>你需要对命令行有基本的了解。<a href="https://learncodethehardway.org/unix/bash_cheat_sheet.pdf" target="_blank" rel="noopener">这里</a>提供一份 cheet sheet 供你使用。</li></ol><p>如果你已万事俱备，那就开始吧。</p><a id="more"></a><h1 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h1><h2 id="配置-SSH-密钥"><a href="#配置-SSH-密钥" class="headerlink" title="配置 SSH 密钥"></a>配置 SSH 密钥</h2><p>要访问远程服务器，你务必使用 SSH 密钥登录而不是使用密码登录。</p><p>密码登录的问题在于其很容易被暴力破解（你将在下文学到如何进一步防止这种情况）。另外，在每次访问服务器时，你都必须输入密码。为避免上述缺点，你必须设置 <strong>SSH 密钥验证</strong>。它比使用密码更安全，因为黑客无法将其暴力破解。除此以外，使用密钥也可以更方便和快速地连接服务器，而无需输入密码。</p><p>下面介绍如何为服务器设置 SSH 身份验证。</p><ul><li><p>在本地计算机上，运行下列命令生成 SSH 密钥对：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure><p>上述命令将引导你在几步之内生成 SSH 密钥。当然别忘了记住你保存密钥文件的位置。</p></li><li><p>使用以下命令将公钥添加到服务器：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-copy-id username@remote_host</span><br></pre></td></tr></table></figure><p>务必使用你的用户名和服务器的 IP 地址替换 <em>username</em> 和 <em>remote_host</em>。系统将提示你输入密码。</p></li><li><p>尝试使用以下命令登录服务器：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh username@remote_host</span><br></pre></td></tr></table></figure><p>别忘了将 <em>username</em> 和 <em>remote_host</em> 替换为服务器的详细信息。这时你会注意到，本次登录不再提示你输入密码。</p></li></ul><h2 id="保持系统时间最新"><a href="#保持系统时间最新" class="headerlink" title="保持系统时间最新"></a>保持系统时间最新</h2><p>许多安全协议依托于你的系统时间来执行定时任务，生成当天的日志和执行其他关键任务。</p><p>如果你的系统时间有误，可能会对你的服务器造成危害。为防止这种情况发生，你可以安装 NTP 客户端。该程序将使你的系统时间与全球 NTP 服务器保持同步。</p><p>安装 NTP 客户端命令如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install ntp</span><br></pre></td></tr></table></figure><p>之后你再也不用担心设置系统日期。</p><h2 id="查看活动端口"><a href="#查看活动端口" class="headerlink" title="查看活动端口"></a>查看活动端口</h2><p>服务器程序会暴露某些端口，以便于网络中的其他应用程序对其进行访问。黑客也可以在你的服务器上安装后门并暴露端口，从而控制你的服务器。因此，我们不希望服务器上的未知端口被请求侦听。</p><p>要查看活动端口，可以使用以下命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ss -lntup</span><br></pre></td></tr></table></figure><p>查看输出并检查任何你并不熟悉的端口或进程。尝试发现并追踪可能有害的服务和流程。如果你不知从何下手，请可以查看这份<a href="https://www.garykessler.net/library/bad_ports.html" target="_blank" rel="noopener">《「糟糕的」TCP/UDP 端口列表》</a>。</p><h2 id="设置防火墙"><a href="#设置防火墙" class="headerlink" title="设置防火墙"></a>设置防火墙</h2><p>防火墙允许你控制服务器上传入 / 传出特定端口的网络流量。通常我使用 UFW（<em>uncomplicated firewall</em>，简单防火墙）。（译者注：UFW 是 Ubuntu 系统上默认的防火墙组件）</p><p>你可以配置下述规则来控制 UFW 的运行：</p><ul><li>允许 / 禁止</li><li>传入流量 / 传出流量</li><li>流量目的地 / 流量源</li><li>特定端口 / 所有端口</li></ul><p>完成下面的例子，你将阻止白名单之外的所有网络流量。如果之后安装了其他程序，别忘了将运行所需的必要端口加入白名单。</p><h3 id="设置-UFW"><a href="#设置-UFW" class="headerlink" title="设置 UFW"></a>设置 UFW</h3><ul><li>安装ufw。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ufw</span><br></pre></td></tr></table></figure><ul><li>你可以禁止所有传出流量</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ufw default deny outgoing comment &apos;deny all outgoing traffic&apos;</span><br></pre></td></tr></table></figure><ul><li>或者允许所有传出流量</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ufw default allow outgoing comment &apos;allow all outgoing traffic&apos;</span><br></pre></td></tr></table></figure><ul><li>接下来，我们要禁止所有传入的流量……</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ufw default deny incoming comment &apos;deny all incoming traffic&apos;</span><br></pre></td></tr></table></figure><ul><li>…将 SSH 连接加入例外，以便访问系统。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ufw limit in ssh comment &apos;allow SSH connections in&apos;</span><br></pre></td></tr></table></figure><ul><li>如果你将 UFW 配置为禁止所有传出流量，别忘了根据需要允许特定流量。比如：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#允许端口 53 的流量输出 -  DNS </span><br><span class="line">sudo ufw allow out 53 comment &apos;allow DNS calls out&apos;</span><br><span class="line"></span><br><span class="line">#允许端口 123 的流量输出 -  NTP </span><br><span class="line">sudo ufw allow out 123 comment &apos;allow NTP out&apos;</span><br><span class="line"></span><br><span class="line">#允许 HTTP，HTTPS 或 FTP 的流量</span><br><span class="line">#根据你使用的 apt 源的不同，apt 可能需要如下设置</span><br><span class="line">sudo ufw allow out http comment &apos;allow HTTP traffic out&apos;</span><br><span class="line">sudo ufw allow out https comment &apos;allow HTTPS traffic out&apos;</span><br><span class="line">sudo ufw allow out ftp comment &apos;allow FTP traffic out&apos;</span><br><span class="line"></span><br><span class="line">#允许 whois</span><br><span class="line">sudo ufw allow out whois comment &apos;allow whois&apos;</span><br><span class="line"></span><br><span class="line">#允许端口 68 的流量输出 -  DHCP 客户端</span><br><span class="line">#如果你正在使用 DHCP，则需要如下设置</span><br><span class="line">sudo ufw allow out 68 comment &apos;allow the DHCP client to update&apos;</span><br></pre></td></tr></table></figure><ul><li>如需拒绝端口 99 上的任何流量，可使用以下命令：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ufw deny 99</span><br></pre></td></tr></table></figure><ul><li>最后，使用以下命令启动 UFW：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ufw enable</span><br></pre></td></tr></table></figure><p>你还可以使用以下命令查看 UFW 状态：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ufw status</span><br></pre></td></tr></table></figure><h2 id="防止自动化攻击"><a href="#防止自动化攻击" class="headerlink" title="防止自动化攻击"></a>防止自动化攻击</h2><p>你可以使用两个程序来阻止大多数自动化攻击：</p><ul><li><a href="http://www.cipherdyne.org/psad/" target="_blank" rel="noopener">PSAD</a></li><li><a href="https://www.fail2ban.org/" target="_blank" rel="noopener">Fail2Ban</a></li></ul><h3 id="PSAD-和-Fail2Ban-之间的区别"><a href="#PSAD-和-Fail2Ban-之间的区别" class="headerlink" title="PSAD 和 Fail2Ban 之间的区别"></a>PSAD 和 Fail2Ban 之间的区别</h3><p>我们知道，端口可以提供给服务器上的应用程序进行访问。攻击者为了访问你的服务器，也许会扫描你的服务器目前开放的端口。</p><p><strong>PSAD</strong> 监视网络活动，以检测并自定义阻止端口扫描和其他类型的可疑流量，如 DDoS 攻击或操作系统指纹识别尝试。</p><p><strong>Fail2Ban</strong> 扫描各种应用程序（如 FTP）的日志文件，并自动封禁有明显恶意行为（如自动登录尝试）的 IP。</p><p>以下指南将向你展示如何安装和配置 PSAD 和 Fail2Ban，以便它们与 UFW 一起使用。</p><ul><li><a href="https://zaiste.net/intro_fail2ban_with_ufw/" target="_blank" rel="noopener">安装 Fail2Ban</a></li><li><a href="https://gist.github.com/netson/c45b2dc4e835761fbccc" target="_blank" rel="noopener">安装 PSAD</a></li></ul><h2 id="安装-logwatch"><a href="#安装-logwatch" class="headerlink" title="安装 logwatch"></a>安装 logwatch</h2><p>服务器上的应用程序通常会将日志消息保存到日志文件中。除非你要手动监控日志文件，否则需要安装 logwatch。logwatch 将扫描系统日志文件并对其进行汇总。</p><p>你可以直接从命令行或计划任务运行 logwatch。例如，你可以配置 logwatch 将日志文件的每日摘要以电子邮件的形式发送给你。注意确保你的服务器可以正常发送电子邮件。</p><p>logwatch 通过 service 文件来获取读取和汇总日志文件的方式。你可以在 <code>/usr/share/logwatch/scripts/services</code> 中查看所有 service 文件。</p><p>logwatch 默认配置文件是 <code>/usr/share/logwatch/default.conf/logwatch.conf</code>。你可以通过使用命令行参数更改配置。</p><p>在 Ubuntu 或 Debian 上安装 logwatch，可运行以下命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install logwatch</span><br></pre></td></tr></table></figure><p>对于其他 Linux 发行版的用户，请查看 Linode 的<a href="https://www.linode.com/docs/uptime/monitoring/monitor-systems-logwatch/" target="_blank" rel="noopener">这篇指南</a>。</p><p>如果你需要查看 logwatch 收集的日志样本，你可以尝试直接运行 logwatch。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo /usr/sbin/logwatch --output stdout --format text --range yesterday --service all</span><br></pre></td></tr></table></figure><p>最后，然后 logwatch 每天发送一封电子邮件，其中包含我们日志文件的摘要。为实现此需求，可以打开文件 <em>/etc/cron.daily/00logwatch</em> 并找到 <em>execute</em> 行，然后将其更改为以下内容：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/usr/sbin/logwatch --output mail --format html --mailto root --range yesterday --service all</span><br></pre></td></tr></table></figure><h2 id="执行安全审计"><a href="#执行安全审计" class="headerlink" title="执行安全审计"></a>执行安全审计</h2><p>在加固 Linux 服务器后，你应该进行安全审计，以便排查任何可能被忽视的安全漏洞。为此，你可以使用 Lynis，这是一个可以实现以下功能的开源软件：</p><ul><li>安全审计。</li><li>一致性测试（例如 PCI，HIPAA，SOx）。</li><li>渗透测试。</li><li>漏洞检测。</li><li>系统强化。</li></ul><h3 id="如何使用-Lynis"><a href="#如何使用-Lynis" class="headerlink" title="如何使用 Lynis"></a>如何使用 Lynis</h3><p>首先，通过克隆其 Github 仓库来安装 Lynis。这可确保安装的是最新版本的 Lynis。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/CISOfy/lynis</span><br></pre></td></tr></table></figure><p>切换到我们克隆 Lynis 的目录：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd lynis</span><br></pre></td></tr></table></figure><p>最后，使用以下命令运行第一次安全审计：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lynis audit system</span><br></pre></td></tr></table></figure><p>你可以在 Lynis 的<a href="https://cisofy.com/lynis/" target="_blank" rel="noopener">官方网站</a>上了解更多相关信息。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>很高兴你能阅读这篇有关加固 Linux 服务器的 how-to 指南。希望你能从中获益。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;原文 &lt;a href=&quot;https://medium.com/servers-101/how-to-secure-your-linux-server-6026cfcdefd8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;How To Secure Your Linux Server In 7 Easy Steps&lt;/a&gt; 由 &lt;a href=&quot;https://medium.com/@mutendebrian&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Brian Mutende&lt;/a&gt; 发布于 Medium，翻译转载已获作者允许。&lt;br&gt;为配合博客目录系统显示，对原文章节名略有修改。&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;大多数服务器经常会被黑客攻击。所以我决定写一篇简短的教程，让读者轻松加固自己的 Linux 服务器。&lt;/p&gt;
&lt;p&gt;这并不是一篇完整的安全指南，但是它可以帮你阻断近九成常见的后端攻击，例如&lt;strong&gt;暴力破解&lt;/strong&gt;和 &lt;strong&gt;DDoS&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;最棒的是，你可以在一两个小时内就完成操作。&lt;/p&gt;
&lt;h1 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;你需要一台Linux服务器。&lt;/li&gt;
&lt;li&gt;你需要对命令行有基本的了解。&lt;a href=&quot;https://learncodethehardway.org/unix/bash_cheat_sheet.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;提供一份 cheet sheet 供你使用。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果你已万事俱备，那就开始吧。&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="https://acuario.xyz/categories/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Linux" scheme="https://acuario.xyz/categories/%E6%95%99%E7%A8%8B/Linux/"/>
    
    
      <category term="教程" scheme="https://acuario.xyz/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Linux" scheme="https://acuario.xyz/tags/Linux/"/>
    
      <category term="命令行" scheme="https://acuario.xyz/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
      <category term="服务器安全" scheme="https://acuario.xyz/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>播客札记（二）：996&amp;多才多艺</title>
    <link href="https://acuario.xyz/podcast-note-2/"/>
    <id>https://acuario.xyz/podcast-note-2/</id>
    <published>2019-04-24T16:00:00.000Z</published>
    <updated>2019-09-15T17:28:50.463Z</updated>
    
    <content type="html"><![CDATA[<h1 id="翻电-Special-VOL04-996-不仅是道德问题"><a href="#翻电-Special-VOL04-996-不仅是道德问题" class="headerlink" title="翻电 Special VOL04 | 996 不仅是道德问题"></a>翻电 Special VOL04 | 996 不仅是道德问题</h1><p><a href="https://overcast.fm/+GsFgwEus4" target="_blank" rel="noopener">Episode Archive</a></p><h2 id="996-的现状和成因"><a href="#996-的现状和成因" class="headerlink" title="996 的现状和成因"></a>996 的现状和成因</h2><ul><li>超时工作 / 加班最多的工作往往处于社会两端：高收入者（高管、投行）和低收入者（工厂工人、出租车司机、快递员、外卖员）。</li><li>高收入者超时工作的原因：由于社会分工程度有上限，具有创造性的工作实际难以再被细节分工。而此类工作大多是无法分工的高产出单人项目。</li><li>低收入者超时工作的原因：此类工作是计件工资制度，多劳多得。</li><li>正常工作是固定工资模式，其处于高收入者和低收入者之间，涉及的创造性的工作和计件工作不多。</li><li>996 运动的爆发来源于高收入者工作模式对正常工作，即固定工资模式的侵入。</li><li>互联网行业的军备竞赛导致了对 996 工作制的需求。</li><li>不患寡而患不均，996 的出现往往是企业文化的整体问题，而非个别部门的个别现象。</li></ul><h2 id="商业模式与-996-的关系"><a href="#商业模式与-996-的关系" class="headerlink" title="商业模式与 996 的关系"></a>商业模式与 996 的关系</h2><ul><li>普通企业的盈利是基于商品的利润。工作量增多带来的投入产出比相对较低。</li><li>互联网行业的盈利是基于股本的增值。估值方法为公司的产品能力、用户数等因素。</li><li>劳动与劳动的区分不在于脑体，而在于资本密集程度。资本市场的存在催生互联网行业和投行等领域的高薪 996。</li><li>八小时工作制最早由英国空想社会主义者罗伯特・欧文于 1817 年 8 月提出。其后由于欧美资本家对劳工的剥削不断加剧，1886 年 5 月 1 日美国芝加哥爆发了历史最大的罢工，倡导实行八小时工作制。</li><li>经济下行期强调、诉求加班文化的企业将会越来越多。在经济下行期，加班将不再只是劳资问题，而将是企业与企业之间军备竞赛的问题。企业主认为在经济下行期控制支出成本的同时提高工作产出，形成企业与企业之间的重商主义。为合理化这一观念，将会出现越来越多提倡奋斗、勤劳文化的论调。</li></ul><a id="more"></a><hr><h1 id="翻转问答-VOL19-应该成为多才多艺的人吗？"><a href="#翻转问答-VOL19-应该成为多才多艺的人吗？" class="headerlink" title="翻转问答 VOL19 | 应该成为多才多艺的人吗？"></a>翻转问答 VOL19 | 应该成为多才多艺的人吗？</h1><p><a href="https://overcast.fm/+GsFiolXRY" target="_blank" rel="noopener">Episode Archive</a></p><h2 id="多样的人生有什么样的假设基础"><a href="#多样的人生有什么样的假设基础" class="headerlink" title="多样的人生有什么样的假设基础"></a>多样的人生有什么样的假设基础</h2><ul><li>假设基础：世间的很多禀赋没有高下之分，各种的才能之间都是平等的。</li><li>上述假设是多元主义的，同时也具有平民主义的特点。</li></ul><h2 id="过去的年代人们有什么样的生活重心"><a href="#过去的年代人们有什么样的生活重心" class="headerlink" title="过去的年代人们有什么样的生活重心"></a>过去的年代人们有什么样的生活重心</h2><ul><li>中世纪社会认为人寻求救赎、追求彼岸最重要，所以僧侣的地位最高。</li><li>法国大革命将第一阶级和第三阶级平等化，不因不同社会分工而地位不同。</li><li>古希腊没有社会分工，专业化只存在于奴隶中。但依然有依据城邦的存续而发展出来的作为人的第一要务——成为伟大的战士、成为关心城邦政事的自由民。eg.埃斯库罗斯的墓志铭</li><li>儒家的承礼启仁是古时的时代精神。</li><li>现代社会多才多艺的精英来自于文艺复兴时期的知识分子。</li></ul><h2 id="今天为何生活失去重心"><a href="#今天为何生活失去重心" class="headerlink" title="今天为何生活失去重心"></a>今天为何生活失去重心</h2><ul><li>今天的时代失去重心，一切问题没有被化解和体认，而是被掩盖起来，最终导致了现代社会推崇多元精英。</li><li>我们不应宣扬没有实指的东西（eg. 优秀、厉害），而应该宣扬找到自己的使命和重心。</li></ul><h2 id="技术化生活的起点和有效性"><a href="#技术化生活的起点和有效性" class="headerlink" title="技术化生活的起点和有效性"></a>技术化生活的起点和有效性</h2><ul><li>一切多元精英论调的滥觞——《高效人士的 7 个习惯》。</li><li>网络上充斥的技术化指导实际难有成效，如：<ol><li><em>有效时间内提高产出</em>；</li><li><em>如何面临抉择</em>。</li></ol></li><li>上述技术化指导有效的前提假设是：一个人只要改变想法就可以改变行为，改变行为就可以改变生活。但是改变想法、改变行为和改变生活之间并未有很强的联系。</li></ul><h2 id="每一个时代都有唯一重要的事"><a href="#每一个时代都有唯一重要的事" class="headerlink" title="每一个时代都有唯一重要的事"></a>每一个时代都有唯一重要的事</h2><ul><li>每一个时代都有唯一重要和可欲的事，不代表所有人必须做同样的事。根据人的理解不同，切入点可以不同。</li><li>可欲的事非常少，每个人都应以自己的方式体认这个时代的时代精神，并以自己的特殊性和个体性切入行事当中。</li></ul><h2 id="面向真相敞开"><a href="#面向真相敞开" class="headerlink" title="面向真相敞开"></a>面向真相敞开</h2><ul><li>如果要接近时代症结，就需要面向真相敞开。由于现代社会语言已经弱化和腐化，从语言的方向接近真相已经比较困难，所以可以尝试回到身体感受，从具有个体性的身体感受开始找回自己的重心，不要被人为的概念和方法影响。</li><li>我们不应该要求自己成为一个比别人更优秀和厉害的人，因为在任何领域毫无止境的比较将把人拉入没有赢面的游戏之中。</li><li>不仅仅接受哲学道理，而是感悟其人的经历和经历对其道理带来的影响。eg. 维特根斯坦</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;翻电-Special-VOL04-996-不仅是道德问题&quot;&gt;&lt;a href=&quot;#翻电-Special-VOL04-996-不仅是道德问题&quot; class=&quot;headerlink&quot; title=&quot;翻电 Special VOL04 | 996 不仅是道德问题&quot;&gt;&lt;/a&gt;翻电 Special VOL04 | 996 不仅是道德问题&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://overcast.fm/+GsFgwEus4&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Episode Archive&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;996-的现状和成因&quot;&gt;&lt;a href=&quot;#996-的现状和成因&quot; class=&quot;headerlink&quot; title=&quot;996 的现状和成因&quot;&gt;&lt;/a&gt;996 的现状和成因&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;超时工作 / 加班最多的工作往往处于社会两端：高收入者（高管、投行）和低收入者（工厂工人、出租车司机、快递员、外卖员）。&lt;/li&gt;
&lt;li&gt;高收入者超时工作的原因：由于社会分工程度有上限，具有创造性的工作实际难以再被细节分工。而此类工作大多是无法分工的高产出单人项目。&lt;/li&gt;
&lt;li&gt;低收入者超时工作的原因：此类工作是计件工资制度，多劳多得。&lt;/li&gt;
&lt;li&gt;正常工作是固定工资模式，其处于高收入者和低收入者之间，涉及的创造性的工作和计件工作不多。&lt;/li&gt;
&lt;li&gt;996 运动的爆发来源于高收入者工作模式对正常工作，即固定工资模式的侵入。&lt;/li&gt;
&lt;li&gt;互联网行业的军备竞赛导致了对 996 工作制的需求。&lt;/li&gt;
&lt;li&gt;不患寡而患不均，996 的出现往往是企业文化的整体问题，而非个别部门的个别现象。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;商业模式与-996-的关系&quot;&gt;&lt;a href=&quot;#商业模式与-996-的关系&quot; class=&quot;headerlink&quot; title=&quot;商业模式与 996 的关系&quot;&gt;&lt;/a&gt;商业模式与 996 的关系&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;普通企业的盈利是基于商品的利润。工作量增多带来的投入产出比相对较低。&lt;/li&gt;
&lt;li&gt;互联网行业的盈利是基于股本的增值。估值方法为公司的产品能力、用户数等因素。&lt;/li&gt;
&lt;li&gt;劳动与劳动的区分不在于脑体，而在于资本密集程度。资本市场的存在催生互联网行业和投行等领域的高薪 996。&lt;/li&gt;
&lt;li&gt;八小时工作制最早由英国空想社会主义者罗伯特・欧文于 1817 年 8 月提出。其后由于欧美资本家对劳工的剥削不断加剧，1886 年 5 月 1 日美国芝加哥爆发了历史最大的罢工，倡导实行八小时工作制。&lt;/li&gt;
&lt;li&gt;经济下行期强调、诉求加班文化的企业将会越来越多。在经济下行期，加班将不再只是劳资问题，而将是企业与企业之间军备竞赛的问题。企业主认为在经济下行期控制支出成本的同时提高工作产出，形成企业与企业之间的重商主义。为合理化这一观念，将会出现越来越多提倡奋斗、勤劳文化的论调。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="播客札记" scheme="https://acuario.xyz/categories/%E6%92%AD%E5%AE%A2%E6%9C%AD%E8%AE%B0/"/>
    
    
      <category term="Podcast" scheme="https://acuario.xyz/tags/Podcast/"/>
    
      <category term="播客" scheme="https://acuario.xyz/tags/%E6%92%AD%E5%AE%A2/"/>
    
      <category term="翻转电台" scheme="https://acuario.xyz/tags/%E7%BF%BB%E8%BD%AC%E7%94%B5%E5%8F%B0/"/>
    
      <category term="996" scheme="https://acuario.xyz/tags/996/"/>
    
      <category term="加班文化" scheme="https://acuario.xyz/tags/%E5%8A%A0%E7%8F%AD%E6%96%87%E5%8C%96/"/>
    
      <category term="多才多艺的人生" scheme="https://acuario.xyz/tags/%E5%A4%9A%E6%89%8D%E5%A4%9A%E8%89%BA%E7%9A%84%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB 与 MyISAM 的区别</title>
    <link href="https://acuario.xyz/differences-between-innodb-and-myisam/"/>
    <id>https://acuario.xyz/differences-between-innodb-and-myisam/</id>
    <published>2019-04-21T09:24:56.000Z</published>
    <updated>2019-04-21T10:12:49.618Z</updated>
    
    <content type="html"><![CDATA[<p>目前 MySQL 的数据库引擎一般使用 InnoDB 和 MyISAM，但两者存在一些差别。网上零零散散的文章看起来比较麻烦，这里以表格汇总对比二者区别。如有纰漏，还望读者在评论区指正。</p><table><thead><tr><th></th><th>InnoDB</th><th>MyISAM</th></tr></thead><tbody><tr><td>MySQL 默认引擎</td><td>✅</td><td>❌</td></tr><tr><td>事务</td><td>✅</td><td>❌</td></tr><tr><td>并发</td><td>表级锁 ✅<br>行级锁 ✅，采用 MVCC 来支持高并发，有可能死锁</td><td>表级锁 ✅<br>行级锁 ❌</td></tr><tr><td>外键</td><td>✅</td><td>❌</td></tr><tr><td>在线热备份</td><td>✅</td><td>❌</td></tr><tr><td>COUNT (*)</td><td>无 meta-data 缓存，查全表获取</td><td>有 meta-data 缓存，直接获取</td></tr><tr><td>崩溃恢复</td><td>通过事务日志来恢复数据库</td><td>损坏率高，恢复速度慢，不能安全恢复</td></tr><tr><td>其他</td><td>默认隔离级别是可重复读（REPEATABLE READ），通过多版本并发控制（MVCC）+ 间隙锁（Next-Key Locking）防止幻影读</td><td>设计简单，数据以紧密格式存储</td></tr><tr><td>索引特性</td><td>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</td><td>DELAY_KEY_WRITE 选项：修改后，新索引数据写入内存中的键缓冲区，清理键缓冲区或者关闭表时才写入磁盘。极大提升写入性能，但崩溃时会造成索引损坏</td></tr><tr><td>全文索引</td><td>>= MySQL 5.6.4 ✅<br>  &lt; MySQL 5.6.4 ❌</td><td>✅<br>支持 BLOB 和 TEXT 的前 500 个字符索引</td></tr><tr><td>自有特性</td><td>内部优化：<br>1. 可预测性读加快读操作<br>2. 自适应哈希索引加速插入操作的插入缓冲区</td><td>1. 支持压缩表和空间数据索引<br>2.并发插入（CONCURRENT INSERT）：在表有读取操作的同时，也可以往表中插入新的记录</td></tr></tbody></table><hr><p>参考链接：<br><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/MySQL.md#%E4%B8%89%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E" target="_blank" rel="noopener">技术面试必备基础知识：MySQL</a><br><a href="http://cxymrzero.github.io/blog/2015/08/17/myisam-innodb/" target="_blank" rel="noopener">MyISAM 与 InnoDB 区别</a><br><a href="https://juejin.im/post/5b1685bef265da6e5c3c1c34" target="_blank" rel="noopener">MySQL 常见的两种存储引擎：MyISAM 与 InnoDB 的爱恨情仇</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目前 MySQL 的数据库引擎一般使用 InnoDB 和 MyISAM，但两者存在一些差别。网上零零散散的文章看起来比较麻烦，这里以表格汇总对比二者区别。如有纰漏，还望读者在评论区指正。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Inno
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://acuario.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="MySQL" scheme="https://acuario.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL/"/>
    
    
      <category term="学习笔记" scheme="https://acuario.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="MySQL" scheme="https://acuario.xyz/tags/MySQL/"/>
    
      <category term="数据库" scheme="https://acuario.xyz/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>播客札记（一）：亲密关系&amp;中医</title>
    <link href="https://acuario.xyz/podcast-note-1/"/>
    <id>https://acuario.xyz/podcast-note-1/</id>
    <published>2019-04-11T16:00:00.000Z</published>
    <updated>2019-09-15T17:28:27.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="翻转问答-VOL8-亲密关系"><a href="#翻转问答-VOL8-亲密关系" class="headerlink" title="翻转问答 VOL8 | 亲密关系"></a>翻转问答 VOL8 | 亲密关系</h1><p><a href="https://overcast.fm/+GsFgR-JZI" target="_blank" rel="noopener">Episode Archive</a></p><h2 id="亲密关系的特点"><a href="#亲密关系的特点" class="headerlink" title="亲密关系的特点"></a>亲密关系的特点</h2><ul><li>个人主义社会——代表排除共同体、排除外部主张的合理性，关注自我的合理性，且自我合理性不与所处共同体相关，是一种纯粹的根本的自我。</li><li>亲密关系是一种纯粹关系，与个人主义的自我产生关联，过去的亲密关系属于共同体（家庭、集体），如今属于自我。</li><li>现代自我拥有物理和心理意义上更多的私人空间，亲密关系与私人空间的冲突恰是其特殊性。</li><li>亲密关系可以充分满足自我认可。因为：<ol><li>亲密关系是自信心和基础安全感的来源；</li><li>亲密关系是制度化社会中几乎唯一的非制度要素的情景，用以释放制度压抑（福柯提出性和药物释放制度压抑）；</li><li>荣格心理学认为，亲密关系是人与自身异性人格（anima 和 animus）达成和解的要素，即是自身自信。</li></ol></li></ul><h2 id="亲密关系为何脆弱"><a href="#亲密关系为何脆弱" class="headerlink" title="亲密关系为何脆弱"></a>亲密关系为何脆弱</h2><ul><li>现代生活中，维系亲密关系的外部必然性消失，促使人反思自身的亲密关系，但亲密关系本身禁不起反思。</li><li>社会流动性越来越大，增加了更多亲密关系的选择。</li><li>亲密关系博弈成为囚徒困境博弈，结合亲密关系边际效应使人更愿意考虑成本和收益而做出选择。</li><li>开放式关系看似消解了亲密关系的囚徒困境，但依旧无法达成 anima 和 animus 和解，且个人主义的本质下，亲密关系是一对一的。</li></ul><a id="more"></a><h2 id="现代知识异化中对亲密关系的-5-种关键隐喻"><a href="#现代知识异化中对亲密关系的-5-种关键隐喻" class="headerlink" title="现代知识异化中对亲密关系的 5 种关键隐喻"></a>现代知识异化中对亲密关系的 5 种关键隐喻</h2><ol><li>健康——感情健康。根本原因是纯粹的亲密关系失去了基础。难免被套用到客观评判体系，引入制度和技术对亲密关系进行调和。</li><li>企业——如何「经营」感情。</li><li>镜像神经元——充分了解对方、完全换位思考理解对方。</li><li>信仰——亲密关系是心诚则灵的东西。信仰在宗教中只照顾生活中与自我存在相关的绝对要素，如救赎——而不是现实功利主义在乎的东西。</li><li>自我——爱别人首先要爱自己。这是纯粹个人主义对亲密关系的排除。但除了自恋之外的「爱」本身就是否定自我的过程，要爱自己，不得不承认宾我与主我的存在，并反对接受宾我的反思。能够做到彻底的自爱的人，定是一个绝对自私的人。</li></ol><h2 id="如何保卫亲密关系"><a href="#如何保卫亲密关系" class="headerlink" title="如何保卫亲密关系"></a>如何保卫亲密关系</h2><ol><li>不仅保卫亲密关系，也要保卫其他真正的关系——如亲情关系、友情关系。</li><li>通过其他真正的关系来锻炼自己承担人际风险的能力，从而减弱自己的胆怯和容易在亲密关系中收到的伤害。</li></ol><hr><h1 id="翻转问答-VOL9-如何看待中医和西医的对比"><a href="#翻转问答-VOL9-如何看待中医和西医的对比" class="headerlink" title="翻转问答 VOL9 | 如何看待中医和西医的对比"></a>翻转问答 VOL9 | 如何看待中医和西医的对比</h1><p><a href="https://overcast.fm/+GsFjiSGOA" target="_blank" rel="noopener">Episode Archive</a></p><ul><li>伪科学是指任何经宣称为科学，或描述方式看起来像科学，但实际上并不符合科学方法基本要求的知识、缺乏支持证据，经不起可信性测试，或缺乏科学形式，伪科学常常使用模糊的、自相矛盾的、夸张的或无法证明的主张，过度依赖确认而不是严格的反驳，缺乏其它专家的公开确认，缺乏系统化、理性化的理论过程。</li><li>中医是“伪科学”还是“非科学”？</li><li>科学还原论试图将各种领域完全祛魅，进行彻底的科学化。中医是否需要像艺术、宗教一样进行科学化？人的身体和医学一定要“科学化”吗？</li></ul><h2 id="物理世界是否必须科学化？"><a href="#物理世界是否必须科学化？" class="headerlink" title="物理世界是否必须科学化？"></a>物理世界是否必须科学化？</h2><ul><li>物理世界的分类：<ol><li>真实感受建构的世界：食物-味觉，按摩-触觉；</li><li>目的建构的世界：与目的高度相关——交通、建筑；</li><li>数学建构的世界：完全的抽象世界。</li></ol></li><li>真实感受的物理世界的语汇与科学的语汇存在范式差异：如味觉「鲜」（厨师烹饪时加糖提鲜）实际并非用科学语境下的「鲜味」。所以并非所有场景都要用科学语汇来替代真实感受的物理世界的语汇。</li><li>目的的物理世界由于存在理论与实践的差异，但并非所有实践都需要确切的理论认识：如鸟的飞行行为本身并不依赖于理论认识；部分尖端科技的发现（认识）是实践（实验）中的偶然，并非现有认识才有实践。</li><li>数学（及其相关）的物理世界由于完全抽象而进行了科学化：如天文学的观测结果、基因层面的理论等。</li></ul><h2 id="医学是否应该属于数学的物理世界？"><a href="#医学是否应该属于数学的物理世界？" class="headerlink" title="医学是否应该属于数学的物理世界？"></a>医学是否应该属于数学的物理世界？</h2><ul><li>基础假设：科学构筑了现象世界以外的不能被感官感知的现象，这些东西是比被感官感知的东西更本质的原因。即如果能找到非无感现象的原因，则五感现象基本都是偏见和错误。</li><li>相信科学即相信上述基础假设。</li><li>现代医学的专业化细分使其可以属于数学的物理世界这一范畴。西医对细节化学现象的分析、对人体化学还原的做法是逻辑自洽的。</li><li>医学自洽是对细节化学现象的自洽，而非对人整体的自洽。</li><li>副作用的存在没有证伪任何化学理论，而是提出了更多难以解释的现象。</li></ul><h2 id="证伪是什么意思？证伪很重要吗？"><a href="#证伪是什么意思？证伪很重要吗？" class="headerlink" title="证伪是什么意思？证伪很重要吗？"></a>证伪是什么意思？证伪很重要吗？</h2><ul><li>「证伪 = 求真」是语言误用。</li><li>被证伪不代表因果性不存在。</li><li>只有科学可以被证伪，但日常医学实践并未以证伪的方式推进科学。</li><li>证伪、实证并非最重要的方法论。</li></ul><h2 id="西医的现状和逻辑问题"><a href="#西医的现状和逻辑问题" class="headerlink" title="西医的现状和逻辑问题"></a>西医的现状和逻辑问题</h2><ul><li>西医治疗的是微观的现象（症状），而非整个人体本身。</li><li>人体的健康状况不是细节现象，而整体宏观秩序。</li><li>西医的统计学基础决定了受众是社会整体，而非单个个体，西医以社会工程学为基础，而非个体研究为基础。临床检验流程，是从社会工程学角度确定药物对社会的安全性，而非对独立个体的安全性。同时，统计样本的选取，也左右着西医实际参考价值。个体差异的复杂性导致个体参与医学治疗的差异性。</li></ul><h2 id="中医有没有理论？"><a href="#中医有没有理论？" class="headerlink" title="中医有没有理论？"></a>中医有没有理论？</h2><ul><li>专家崇拜是现代性的一大问题。以信托的方式相信专家，是存在实际风险和问题的。</li><li>中医并非没有理论，而是非科学理论。</li><li>中医的理论前提是阴阳五行的信念，西医的理论前提是数学理论的实在。</li><li>实用主义角度来看，阴阳五行理论在某种程度上阐释了身体的现象和关系。我们承认其有理，但为何我们否认其「真」？</li></ul><h2 id="我们需要的一种“本体论”清醒"><a href="#我们需要的一种“本体论”清醒" class="headerlink" title="我们需要的一种“本体论”清醒"></a>我们需要的一种“本体论”清醒</h2><ul><li>认为科学发展可以一往无前，将有科学宗教和科学迷信的风险。</li><li>大多数科学的发现是应用领域的新应用，而非原理领域的新发现。</li><li>科学意义的「存在」和我们五感的「存在」并非相同意义，我们虽未以五感方式认知其科学「存在」，但我们对其有信任。这与阴阳五行理论的「存在」并无本质差异。</li><li>真理掌握我们，而非我们掌握真理。</li></ul><h2 id="为何中医话题敏感？"><a href="#为何中医话题敏感？" class="headerlink" title="为何中医话题敏感？"></a>为何中医话题敏感？</h2><ul><li>以公共说理和公共舆论为重要基础，科学的公共话题变得比较敏感。</li><li>人被隔绝的日常实践，通过口头表达和表达被人承认获得自我认知和实现。</li><li>随着互联网发展，公共言论和公共舆论与权力高度相关。</li><li>在公共说理领域，面对多变的环境和不确定性的受众，我们需要一种货币一样的硬通货来说理——普遍主义。</li><li>启蒙理性和科学，诞生于对神学的批判，但在批驳的同时继承了神学的确定性和普遍主义。</li><li>科学无法争取的普遍主义的领域，将被权力斥为不重要和无意义。如艺术、形而上学、人生价值。</li><li>认为「一个领域必须留给其专业的、有其实践经验的人」的想法，是十分傲慢、不负责任、导致社会进一步切割的观念。专家崇拜是现代性涌现的巨大问题，它带来社会盲目和个体自信心和安全感的丧失。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;翻转问答-VOL8-亲密关系&quot;&gt;&lt;a href=&quot;#翻转问答-VOL8-亲密关系&quot; class=&quot;headerlink&quot; title=&quot;翻转问答 VOL8 | 亲密关系&quot;&gt;&lt;/a&gt;翻转问答 VOL8 | 亲密关系&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://overcast.fm/+GsFgR-JZI&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Episode Archive&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;亲密关系的特点&quot;&gt;&lt;a href=&quot;#亲密关系的特点&quot; class=&quot;headerlink&quot; title=&quot;亲密关系的特点&quot;&gt;&lt;/a&gt;亲密关系的特点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;个人主义社会——代表排除共同体、排除外部主张的合理性，关注自我的合理性，且自我合理性不与所处共同体相关，是一种纯粹的根本的自我。&lt;/li&gt;
&lt;li&gt;亲密关系是一种纯粹关系，与个人主义的自我产生关联，过去的亲密关系属于共同体（家庭、集体），如今属于自我。&lt;/li&gt;
&lt;li&gt;现代自我拥有物理和心理意义上更多的私人空间，亲密关系与私人空间的冲突恰是其特殊性。&lt;/li&gt;
&lt;li&gt;亲密关系可以充分满足自我认可。因为：&lt;ol&gt;
&lt;li&gt;亲密关系是自信心和基础安全感的来源；&lt;/li&gt;
&lt;li&gt;亲密关系是制度化社会中几乎唯一的非制度要素的情景，用以释放制度压抑（福柯提出性和药物释放制度压抑）；&lt;/li&gt;
&lt;li&gt;荣格心理学认为，亲密关系是人与自身异性人格（anima 和 animus）达成和解的要素，即是自身自信。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;亲密关系为何脆弱&quot;&gt;&lt;a href=&quot;#亲密关系为何脆弱&quot; class=&quot;headerlink&quot; title=&quot;亲密关系为何脆弱&quot;&gt;&lt;/a&gt;亲密关系为何脆弱&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;现代生活中，维系亲密关系的外部必然性消失，促使人反思自身的亲密关系，但亲密关系本身禁不起反思。&lt;/li&gt;
&lt;li&gt;社会流动性越来越大，增加了更多亲密关系的选择。&lt;/li&gt;
&lt;li&gt;亲密关系博弈成为囚徒困境博弈，结合亲密关系边际效应使人更愿意考虑成本和收益而做出选择。&lt;/li&gt;
&lt;li&gt;开放式关系看似消解了亲密关系的囚徒困境，但依旧无法达成 anima 和 animus 和解，且个人主义的本质下，亲密关系是一对一的。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="播客札记" scheme="https://acuario.xyz/categories/%E6%92%AD%E5%AE%A2%E6%9C%AD%E8%AE%B0/"/>
    
    
      <category term="Podcast" scheme="https://acuario.xyz/tags/Podcast/"/>
    
      <category term="播客" scheme="https://acuario.xyz/tags/%E6%92%AD%E5%AE%A2/"/>
    
      <category term="翻转电台" scheme="https://acuario.xyz/tags/%E7%BF%BB%E8%BD%AC%E7%94%B5%E5%8F%B0/"/>
    
      <category term="亲密关系" scheme="https://acuario.xyz/tags/%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB/"/>
    
      <category term="中医" scheme="https://acuario.xyz/tags/%E4%B8%AD%E5%8C%BB/"/>
    
  </entry>
  
  <entry>
    <title>SS/SSR中转V2ray起飞教程</title>
    <link href="https://acuario.xyz/delegate-v2ray-traffic-to-ss-or-ssr/"/>
    <id>https://acuario.xyz/delegate-v2ray-traffic-to-ss-or-ssr/</id>
    <published>2019-04-01T07:58:18.000Z</published>
    <updated>2019-06-07T15:07:53.593Z</updated>
    
    <content type="html"><![CDATA[<p>本文目标读者：</p><ul><li>拥有自建 V2Ray 代理</li><li>有机场使用经验</li><li>没钱买高价机场 / 乐于使(bái)用(piáo)公益机场</li><li>使用机场服务，但忌惮流量安全</li></ul><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>目前市面上已经有很多机场（提供 SS/SSR 服务的网站），且不乏众多公益机场，这些机场因为拥有一些好线路的服务器，所以在使用的时候可以获得较好的突破网络封锁的体验。比起自己购买一个垃圾服务器，使用时的龟速；以及购买一个优质线路服务器，承受每月高额费用；更不用说还要担心自己服务器被 GFW 认证的风险——使用机场真是省钱省心。但是隐私问题也不容小觑，支付时的隐私泄露按下不表，本文的初衷是规避使用机场时流量隐私泄露的问题——如何使用机场服务的同时不暴露自己的流量隐私。</p><p>V2Ray 除了支持自有协议 VMess 之外，还支持 Socks、Shadowsocks 等协议，配合自带的流量中转功能，可以在保护流量隐私的同时，借助机场起飞，最大程度上提升代理使用体验。</p><p>前面说这么多，说人话就是——花最少的钱，用最好的线路，让偷窥流量 / 监控流量的机场见鬼去吧。</p><h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><p><img src="https://i.loli.net/2019/04/01/5ca1b95248225.png" alt="无标题.png"></p><a id="more"></a><p>基本原理大致如下：</p><ol><li>V2Ray 客户端先将流量使用 VMess 协议加密</li><li>按照不同的加密方法：<br> SS 中转：V2Ray 客户端再使用 SS 协议加密，把两次加密后的流量发送到机场服务器进行中转<br> SSR 中转：V2Ray 客户端把 VMess 加密流量发给 SSR 客户端，SSR 客户端再使用 SSR 协议加密，把两次加密后的流量发送到机场服务器进行中转</li><li>机场服务器对流量进行 SS/SSR 解密后再把流量（VMess 协议加密流量）发往我们自建的 V2Ray 服务器</li><li>V2Ray 服务器正常访问网站</li><li>网站返回的数据按上述步骤和处理方式原路返回</li></ol><p>由于机场服务器收到的是 VMess 协议加密后的流量，加密方法又是我们自定义的，所以机场几无可能掌握我们的真实流量。下面动手实操。</p><h1 id="SS-中转-V2Ray-流量"><a href="#SS-中转-V2Ray-流量" class="headerlink" title="SS 中转 V2Ray 流量"></a>SS 中转 V2Ray 流量</h1><p>V2Ray 自身支持 Shadowsocks 协议，所以 SS 中转 V2Ray 流量按照官方的<a href="https://toutyrater.github.io/advanced/outboundproxy.html" target="_blank" rel="noopener">白话文教程</a>来操作就行了。简单来说就是把配置文件中的 <code>outbounds</code> 部分设置为这样：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;outbounds&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;protocol&quot;: &quot;vmess&quot;,</span><br><span class="line">      &quot;settings&quot;: &#123; // 此处根据自己的V2Ray设置修改</span><br><span class="line">        &quot;vnext&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;address&quot;: &quot;1.1.1.1&quot;,</span><br><span class="line">            &quot;port&quot;: 8888,</span><br><span class="line">            &quot;users&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;alterId&quot;: 64,</span><br><span class="line">                &quot;id&quot;: &quot;b12614c5-5ca4-4eba-a215-c61d642116ce&quot;</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;proxySettings&quot;: &#123;</span><br><span class="line">          &quot;tag&quot;: &quot;transit&quot;  // 把 V2Ray 流量发给 tag 名为 transit 的代理进行转发</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;protocol&quot;: &quot;shadowsocks&quot;,</span><br><span class="line">      &quot;settings&quot;: &#123; // 此处填上机场某个 SS 服务器的配置</span><br><span class="line">        &quot;servers&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;address&quot;: &quot;2.2.2.2&quot;,</span><br><span class="line">            &quot;method&quot;: &quot;aes-256-cfb&quot;,</span><br><span class="line">            &quot;ota&quot;: false,</span><br><span class="line">            &quot;password&quot;: &quot;password&quot;,</span><br><span class="line">            &quot;port&quot;: 1024</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;tag&quot;: &quot;transit&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></p><h1 id="SSR-中转-V2Ray-流量"><a href="#SSR-中转-V2Ray-流量" class="headerlink" title="SSR 中转 V2Ray 流量"></a>SSR 中转 V2Ray 流量</h1><p>但是很多机场都是 SSR 机场，没有提供 SS 配置，那岂不是就不能用上面的骚操作了？既然 SSR 支持监听本地的 Socks 流量，V2Ray 又支持 Socks 协议传出，那我们只需要在本地同时打开 V2Ray 和 SSR 客户端，然后用 Socks 协议连接二者通信即可，相当于把上一节中 V2Ray 传出目标从服务器改为本地 SSR。那么配置文件中的 <code>outbounds</code> 部分就设置为这样：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;outbounds&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;protocol&quot;: &quot;vmess&quot;,</span><br><span class="line">      &quot;settings&quot;: &#123; // 此处根据自己的V2Ray设置修改</span><br><span class="line">        &quot;vnext&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;address&quot;: &quot;1.1.1.1&quot;,</span><br><span class="line">            &quot;port&quot;: 8888,</span><br><span class="line">            &quot;users&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;alterId&quot;: 64,</span><br><span class="line">                &quot;id&quot;: &quot;b12614c5-5ca4-4eba-a215-c61d642116ce&quot;</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;proxySettings&quot;: &#123;</span><br><span class="line">          &quot;tag&quot;: &quot;transit&quot;  // 把 V2Ray 流量发给 tag 名为 transit 的代理进行转发</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;protocol&quot;: &quot;socks&quot;,</span><br><span class="line">      &quot;settings&quot;: &#123;</span><br><span class="line">        &quot;servers&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">          &quot;address&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">          &quot;port&quot;: 1080  // 此处填写 SSR 客户端监听的本地端口</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;tag&quot;: &quot;transit&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></p><p>以 Windows 平台为例，我们可以在客户端的「选项设置」中「允许来自局域网的连接」，并且设置 SSR 客户端监听的本地端口：</p><p><img src="https://i.loli.net/2019/04/01/5ca1b95b997fe.png" alt="SSR设置"></p><p>完成设置后，在 SSR 客户端中选择想要使用的服务器节点，并且打开 V2Ray，需要代理的流量全部访问 <strong>V2Ray 客户端监听的端口</strong>即可。</p><p><img src="https://i.loli.net/2019/04/01/5ca1b95d2597b.png" alt="选择SSR服务器节点"></p><p>如果设置正确，访问不存在的网站时，可以在 V2Ray 服务端日志中看到流量全部来自于我们选择机场服务器节点。</p><p><img src="https://i.loli.net/2019/04/01/5ca1b95e30487.png" alt="V2Ray服务端日志"></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="V2Ray-配置文件"><a href="#V2Ray-配置文件" class="headerlink" title="V2Ray 配置文件"></a>V2Ray 配置文件</h2><p>刚开始使用 V2Ray 的人可能会困惑于 V2Ray 配置文件的繁琐，下面提供几个与本文相关的，本人目前正在使用的 V2Ray 完整配置文件，其中客户端配置文件集成了基本的广告屏蔽和大陆直连，本地监听端口为 <code>1082</code>，可根据自己需要进行修改。同时也提供了最简单的服务端配置文件，仅供参考：</p><ul><li><a href="https://gist.github.com/yhyy135/667251599e3e762ca6d86517d39554c8/raw/ba48ac317c5b658b55b4834516d897a4a201a473/ss-vmess-config.json" target="_blank" rel="noopener">SS 中转 V2Ray 客户端配置文件</a></li><li><a href="https://gist.github.com/yhyy135/667251599e3e762ca6d86517d39554c8/raw/ba48ac317c5b658b55b4834516d897a4a201a473/ssr-vmess-config.json" target="_blank" rel="noopener">SSR 中转 V2Ray 客户端配置文件</a></li><li><a href="https://gist.github.com/yhyy135/667251599e3e762ca6d86517d39554c8/raw/ba48ac317c5b658b55b4834516d897a4a201a473/server-config.json" target="_blank" rel="noopener">V2Ray 服务端配置文件</a></li></ul><p>另外，由于 SSR 中转 V2Ray 流量需要同时使用 SSR 客户端和 V2Ray 客户端，所以目前暂时无法在移动设备上实现，略有遗憾。但是既然都可以如此白嫖机场了，还是知足吧。如果你有什么好想法，不妨在评论区交流。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文目标读者：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;拥有自建 V2Ray 代理&lt;/li&gt;
&lt;li&gt;有机场使用经验&lt;/li&gt;
&lt;li&gt;没钱买高价机场 / 乐于使(bái)用(piáo)公益机场&lt;/li&gt;
&lt;li&gt;使用机场服务，但忌惮流量安全&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;目前市面上已经有很多机场（提供 SS/SSR 服务的网站），且不乏众多公益机场，这些机场因为拥有一些好线路的服务器，所以在使用的时候可以获得较好的突破网络封锁的体验。比起自己购买一个垃圾服务器，使用时的龟速；以及购买一个优质线路服务器，承受每月高额费用；更不用说还要担心自己服务器被 GFW 认证的风险——使用机场真是省钱省心。但是隐私问题也不容小觑，支付时的隐私泄露按下不表，本文的初衷是规避使用机场时流量隐私泄露的问题——如何使用机场服务的同时不暴露自己的流量隐私。&lt;/p&gt;
&lt;p&gt;V2Ray 除了支持自有协议 VMess 之外，还支持 Socks、Shadowsocks 等协议，配合自带的流量中转功能，可以在保护流量隐私的同时，借助机场起飞，最大程度上提升代理使用体验。&lt;/p&gt;
&lt;p&gt;前面说这么多，说人话就是——花最少的钱，用最好的线路，让偷窥流量 / 监控流量的机场见鬼去吧。&lt;/p&gt;
&lt;h1 id=&quot;基本原理&quot;&gt;&lt;a href=&quot;#基本原理&quot; class=&quot;headerlink&quot; title=&quot;基本原理&quot;&gt;&lt;/a&gt;基本原理&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/04/01/5ca1b95248225.png&quot; alt=&quot;无标题.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="https://acuario.xyz/categories/%E6%95%99%E7%A8%8B/"/>
    
      <category term="软件使用" scheme="https://acuario.xyz/categories/%E6%95%99%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="教程" scheme="https://acuario.xyz/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="VPS" scheme="https://acuario.xyz/tags/VPS/"/>
    
      <category term="ShadowsocksR" scheme="https://acuario.xyz/tags/ShadowsocksR/"/>
    
      <category term="v2ray" scheme="https://acuario.xyz/tags/v2ray/"/>
    
      <category term="Shadowsocks" scheme="https://acuario.xyz/tags/Shadowsocks/"/>
    
  </entry>
  
</feed>
